# -*- mode:org; fill-column:79; -*-
#+title:SQLite Tutorial
#+subtitle:{{{version}}}
#+date:2019-07-06 16:01
#+macro:version Version 0.0.27 {{{date}}}
* Introduction
- [[https://www.sqlite.org/index.html][SQLite Home]]
- [[https://www.sqlite.org/docs.html][SQLite Documentation]]
- [[https://www.sqlite.org/download.html][SQLite Download Page]]
- [[http://www.sqlitetutorial.net][SQLite Tutorial Home]]
- [[https://sqlite.org/src/doc/trunk/README.md][SQLite Source Repository and Compilation]]
- *Latest Release*: Version 3.28.0 (2019-04-16)


#+begin_src sh :results output :exports results
echo SQLite installed version:
sqlite3 --version
#+end_src

*SQLite* is an /open source/, /zero-configuration/, /self-contained/,
/stand-alone/, /transaction/ relational database engine designed to be
/embedded/ into an application.

This SQLite tutorial teaches you everything you need to know to start
using SQLite effectively. You will learn SQLite through extensive
hands-on practices.

* About the SQLite Tutorial
- http://www.sqlitetutorial.net

SQLite Tutorial website helps you master SQLite quickly and easily. It explains
the complex concepts in simple and easy-to-understand ways so that you can both
understand SQLite fast and know how to apply it in your software development
work more effectively.

* Getting started with SQLite
You should go through this section if this is the first time you have worked
with SQLite.  Follow these 3-easy steps to get started with SQLite fast.

- First, we help you answer the first important question: [[http://www.sqlitetutorial.net/what-is-sqlite/][what is SQLite]]?  You
  will have a brief overview of SQLite before you start working with it.

- Second, we show you step by step how to [[http://www.sqlitetutorial.net/download-install-sqlite/][download and install SQLite GUI tool]]
  on your computer.

- Third, we introduce you to an [[http://www.sqlitetutorial.net/sqlite-sample-database/][SQLite sample database]] and walk you through the
  steps of using the sample database for practicing.

** What is SQLite
- http://www.sqlitetutorial.net/what-is-sqlite/

- *Summary* :: this tutorial gives you a brief overview of SQLite and the
               SQLite’s distinctive features that make SQLite the most widely
               deployed SQL database engine.

SQLite is a software library that provides a relational database management
system.  The /lite/ in SQLite means light weight in terms of setup, database
administration, and required resource.

SQLite has the following noticeable features:
- self-contained,
- serverless,
- zero-configuration,
- transactional


SQLite is a C-language library that implements a small, fast, self-contained,
high-reliability, full-featured, SQL database engine.  The SQLite file format
is stable, cross-platform, and backwards compatible.  SQLite database files are
commonly used as containers to transfer rich content between systems and as a
long-term archival format for data.

*** Serverless
#+cindex:serverless
#+cindex:RDBMS
#+cindex:MySQL
#+cindex:PostgreSQL
#+cindex:TCP/IP
#+cindex:client/server architecture
Normally, an RDBMS such as MySQL, PostgreSQL, etc., requires a separate server
process to operate.  The applications that want to access the database server
use TCP/IP protocol to send and receive requests.  This is called client/server
architecture.

The following diagram illustrates the RDBMS client/server architecture:

#+caption:RDMBS Client-Server Architecture
#+name:fig:client-server-arch
[[file:figs/RDBMS-Client-Server-Architecture.jpg]]

*SQLite does NOT work this way.* SQLite does *NOT* require a server to run.

SQLite database is integrated with the application that accesses the database.
The applications interact with the SQLite database to read and write directly
from the database files stored on disk.

The following diagram illustrates the SQLite server-less architecture:

#+caption:SQLite Serverless Architecture
#+name:fig:sqlite-serverless-arch
[[file:figs/What-is-SQLite.jpg]]

*** Detailed Description of Features
- [[https://www.sqlite.org/features.html][Features]]
- [[https://www.sqlite.org/omitted.html][Omitted Features]]


  #+cindex:transactions, ACID
  #+cindex:ACID transactions
- Transactions are /atomic/, /consistent/, /isolated/, and /durable/ (*ACID*)
  even after system crashes and power failures.

  #+cindex:zero-configuration
  #+cindex:configuration, none
- *Zero-configuration* --- no setup or administration needed.

  #+cindex:indexes, partial, on expressions
  #+cindex:JSON
  #+cindex:table expressions
  #+cindex:window functions
- Full-featured SQL implementation with advanced capabilities like /partial
  indexes/, /indexes on expressions/, /JSON/, /common table expressions/, and /window
  functions/.

  #+cindex:application file format
- A complete database is stored in a *single cross-platform disk file*.  Great
  for use as an [[https://www.sqlite.org/appfileformat.html][application file format]].[fn::An "application file format" is
  the file format used to persist application state to disk or to exchange
  information between programs.]

  #+cindex:terabyte-sized databases
  #+cindex:gigabyte-sized strings, blobs
- Supports *terabyte-sized databases* and gigabyte-sized strings and blobs.

  #+cindex:small footprint
- *Small code footprint*: less than 600KiB fully configured or much less with
  optional features omitted.

  #+cindex:API
- Simple, easy to use *API*.

  #+cindex:fast
- *Fast*: In some cases, SQLite is faster than direct filesystem I/O

  #+cindex:ANSI-C
  #+cindex:TCL bindings
- Written in *ANSI-C*. TCL bindings included.  Bindings for dozens of other
  languages available separately.

  #+cindex:source code well commented
- Well-commented *source code* with 100% branch test coverage.

  #+cindex:compile source code
- Available as a single *ANSI-C source-code file* that is easy to compile and
  hence is easy to add into a larger project.

  #+cindex:dependencies, none
  #+cindex:self-contained
- *Self-contained*: no external dependencies.

  #+cindex:cross-platform
  #+cindex:Android
  #+cindex:BSD
  #+cindex:iOS
  #+cindex:Linux
  #+cindex:Mac
  #+cindex:Solaris
  #+cindex:VxWorks
  #+cindex:Windows
- Cross-platform: Android, *BSD, iOS, Linux, Mac, Solaris, VxWorks, and Windows
  (Win32, WinCE, WinRT) are supported out of the box.  Easy to port to other
  systems.

  #+cindex:public domain
- Sources are in the *public domain*.  Use for any purpose.

  #+cindex:command-line interface (CLI)
  #+cindex:CLI, command-line interface
- Comes with a standalone command-line interface (CLI) client that can be used
  to administer SQLite databases.

*** Self-Contained
#+cindex:self-contained
#+cindex:iPhone
#+cindex:Android
#+cindex:game consoles
#+cindex:handheld media players
"SQLite is self-contained" means it requires minimal support from the operating
system or external library.  This makes SQLite usable in any environments---
especially in embedded devices like iPhones, Android phones, game consoles,
handheld media players, etc.

#+cindex:ANSI-C
#+cindex:source files
#+cindex:compile into code
SQLite is developed using ANSI-C.  The source code is available as a big
~sqlite3.c~ and its header file ~sqlite3.h~.  If you want to develop an
application that uses SQLite, you just need to drop these files into your
project and compile it with your code.

*** Zero-configuration
#+cindex:zero configuration
#+cindex:configuration files, none
Because of the serverless architecture, you don’t need to “install” SQLite
before using it.  There is no server process that needs to be configured,
started, and stopped.

In addition, SQLite does not use any configuration files.

*** Transactional
#+cindex:transactions
#+cindex:ACID-compliant
#+cindex:atomic
#+cindex:consistent
#+cindex:isolated
#+cindex:durable
All transactions in SQLite are fully ACID-compliant.  It means all queries and
changes are Atomic, Consistent, Isolated, and Durable.  In other words, all
changes within a transaction take place completely or not at all even when an
unexpected situation like application crash, power failure, or operating system
crash occurs.

*** SQLite distinctive features
#+cindex:dynamic types
#+cindex:data types, dynamic
SQLite uses dynamic types for tables.  It means you can store any value in any
column, regardless of the data type.

#+cindex:single database connection
#+cindex:connection, single
SQLite allows a single database connection to access multiple database files
simultaneously.  This brings many nice features like joining tables in different
databases or copying data between databases in a single command.

#+cindex:in-memory database
SQLite is capable of creating in-memory databases which are very fast to work
with.

*** SQLite is NOT Client-Server SQL
SQLite is not directly comparable to client/server SQL database engines such as
MySQL, Oracle, PostgreSQL, or SQL Server since SQLite is trying to solve a
different problem.

#+cindex:shared repository
*Client/server SQL database engines* strive to implement a /shared repository/ of
enterprise data.  They emphasize 
- scalability,
- concurrency,
- centralization, and
- control.


#+cindex:local data storage
*SQLite* strives to provide /local data storage/ for individual applications
and devices.  SQLite emphasizes 
- economy,
- efficiency,
- reliability,
- independence, and
- simplicity.


#+cindex:@code{fopen()}
SQLite does not compete with client/server databases.  SQLite competes with
~fopen()~.

** Use Cases for SQLite

For device-local storage with low writer concurrency and less than a terabyte
of content, SQLite is almost always a better solution than using a
client-server RDBMS.  SQLite is fast and reliable and it requires no
configuration or maintenance.  It keeps thing simple.  SQLite "just works".

#+cindex:use cases
#+cindex:embedded devices
- Embedded devices and the internet of things ::


  #+cindex:application file format
- Application file format ::

     SQLite is often used as the on-disk file format for desktop applications
     such as:

  - version control systems,

  - financial analysis tools,

  - media cataloging and editing suites,

  - CAD packages,

  - record keeping programs,

    #+cindex:@code{sqlite3_open()}
    #+cindex:File/Open operation
    #+cindex:File/Save menu
    and so forth.  The traditional File/Open operation calls ~sqlite3_open()~
    to attach to the database file.  Updates happen automatically as
    application content is revised so the File/Save menu option becomes
    superfluous.  The =File/Save_As= menu option can be implemented using the
    backup API.  There are many benefits to this approach, including improved
    performance, reduced cost and complexity, and improved reliability.

  #+cindex:websites
- Websites ::

              SQLite works great as the database engine for most low to medium
              traffic websites (which is to say, most websites).  The amount of
              web traffic that SQLite can handle depends on how heavily the
              website uses its database.  Generally speaking, any site that
              gets fewer than 100K hits/day should work fine with SQLite.  The
              100K hits/day figure is a conservative estimate, not a hard upper
              bound.  SQLite has been demonstrated to work with 10 times that
              amount of traffic.

  #+cindex:data analysis
- Data analysis ::

                   #+cindex:command-line shell
                   #+cindex:TCL
                   #+cindex:Python
                   #+cindex:R
                   People who understand SQL can employ the sqlite3
                   command-line shell (or various third-party SQLite access
                   programs) to analyze large datasets.  Raw data can be
                   imported from CSV files, then that data can be sliced and
                   diced to generate a myriad of summary reports.  More complex
                   analysis can be done using simple scripts written in Tcl or
                   Python (both of which come with SQLite built-in) or in R or
                   other languages using readily available adaptors.

                   The same thing can be done with an enterprise client/server
                   database, of course.  The advantage of SQLite is that it is
                   easier to install and use and the resulting database is a
                   single file that can be written to a USB memory stick or
                   emailed to a colleague.

- Cache for enterprise data ::

  #+cindex:server-side database
- Server-side database ::

     #+cindex:data store
     Systems designers report success using SQLite as a data store on server
     applications running in the datacenter, or in other words, using SQLite as
     the underlying storage engine for an application-specific database server.

     With this pattern, the overall system is still client/server: clients send
     requests to the server and get back replies over the network. But instead
     of sending generic SQL and getting back raw table content, the client
     requests and server responses are high-level and application-specific. The
     server translates requests into multiple SQL queries, gathers the results,
     does post-processing, filtering, and analysis, then constructs a
     high-level reply containing only the essential information.

- Data transfer format ::

     #+cindex:cross-platform format
     Because an SQLite database is a single compact file in a well-defined
     cross-platform format, it is often used as a container for transferring
     content from one system to another.  The sender gathers content into an
     SQLite database file, transfers that one file to the receiver, then the
     receiver uses SQL to extract the content as needed.

  #+cindex:file archive
- File archive and/or data container ::

     #+cindex:SQLite Archive
     #+cindex:ZIP archives
     #+cindex:incremental update
     #+cindex:metadata, rich
     The [[https://www.sqlite.org/sqlar.html][SQLite Archive]] idea shows how SQLite can be used as a substitute for
     ZIP archives or Tarballs.  An archive of files stored in SQLite is only
     very slightly larger, and in some cases actually smaller, than the
     equivalent ZIP archive.  And an SQLite archive features incremental and
     atomic updating and the ability to store much richer metadata.

     #+cindex:network transfer
     SQLite is a good solution for any situation that requires bundling diverse
     content into a self-contained and self-describing package for shipment
     across a network.  Content is encoding in a well-defined, cross-platform,
     and stable file format.  The encoding is efficient, and receivers can
     extract small subsets of the content without having to read and parse the
     entire file.

  #+cindex:disk files, ad hoc
- Replacement for ad hoc disk files ::


  #+cindex:internal database
- Internal or temporary databases ::

     For programs that have a lot of data that must be sifted and sorted in
     diverse ways, it is often easier and quicker to load the data into an
     in-memory SQLite database and use queries with joins and ORDER BY clauses
     to extract the data in the form and order needed rather than to try to
     code the same operations manually.  Using an SQL database internally in
     this way also gives the program greater flexibility since new columns and
     indices can be added without having to recode every query.

- Stand-in for an enterprise database during demos or testing ::


- Education and Training ::


- Experimental SQL language extensions ::

** Download and Install SQLite

#+cindex:download SQLite
#+cindex:install SQLite
- *Summary* :: This tutorial shows you step by step how to download and install
               SQLite on your computer.

{{{heading(Download SQLite)}}}

1. First, go to the https://www.sqlite.org website.
2. Second, open the download page https://www.sqlite.org/download.html


#+cindex:platforms
SQLite provides various versions for various platforms e.g., Windows, Linux,
and Mac.  You should choose an appropriate version to download.

{{{heading(Install SQLite)}}}

#+cindex:install SQLite
#+cindex:@file{sqlite3.exe}
1. First, create a new folder e.g., ~/usr/local/sqlite~.
2. Second, extract the content of the file that you downloaded in the previous
   section to the ~/usr/local/sqlite~ folder.  You should see the ~sqlite3.exe~
   is in the ~/usr/local/sqlite~ folder.


{{{subheading(Working With the Installation)}}}

1. First, open the command line window and navigate to the ~/usr/local/sqlite~
   folder.

2. Second, type =sqlite3= and press enter, you should see the following output:

   #+begin_example
   ? sqlite3
   SQLite version 3.28.0 2019-04-16 19:49:53
   Enter ".help" for usage hints.
   Connected to a transient in-memory database.
   Use ".open FILENAME" to reopen on a persistent database.
   sqlite>
   #+end_example

3. Third, you can type the ~.help~ command from the =sqlite>= prompt to see all
   available commands in sqlite3.

   #+begin_example
   sqlite> .help
   .archive ...             Manage SQL archives
   .auth ON|OFF             Show authorizer callbacks
   .backup ?DB? FILE        Backup DB (default "main") to FILE
   .bail on|off             Stop after hitting an error.  Default OFF
   .binary on|off           Turn binary output on or off.  Default OFF
   .cd DIRECTORY            Change the working directory to DIRECTORY
   .changes on|off          Show number of rows changed by SQL
   .check GLOB              Fail if output since .testcase does not match
   .clone NEWDB             Clone data into NEWDB from the existing database
   .databases               List names and files of attached databases
   .dbconfig ?op? ?val?     List or change sqlite3_db_config() options
   .dbinfo ?DB?             Show status information about the database
   .dump ?TABLE? ...        Render all database content as SQL
   .echo on|off             Turn command echo on or off
   .eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN
   .excel                   Display the output of next command in a spreadsheet
   .exit ?CODE?             Exit this program with return-code CODE
   .expert                  EXPERIMENTAL. Suggest indexes for specified queries
   .fullschema ?--indent?   Show schema and the content of sqlite_stat tables
   .headers on|off          Turn display of headers on or off
   .help ?-all? ?PATTERN?   Show help text for PATTERN
   .import FILE TABLE       Import data from FILE into TABLE
   .imposter INDEX TABLE    Create imposter table TABLE on index INDEX
   .indexes ?TABLE?         Show names of indexes
   .limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT
   .lint OPTIONS            Report potential schema issues.
   .load FILE ?ENTRY?       Load an extension library
   .log FILE|off            Turn logging on or off.  FILE can be stderr/stdout
   .mode MODE ?TABLE?       Set output mode
   .nullvalue STRING        Use STRING in place of NULL values
   .once (-e|-x|FILE)       Output for the next SQL command only to FILE
   .open ?OPTIONS? ?FILE?   Close existing database and reopen FILE
   .output ?FILE?           Send output to FILE or stdout if FILE is omitted
   .parameter CMD ...       Manage SQL parameter bindings
   .print STRING...         Print literal STRING
   .progress N              Invoke progress handler after every N opcodes
   .prompt MAIN CONTINUE    Replace the standard prompts
   .quit                    Exit this program
   .read FILE               Read input from FILE
   .restore ?DB? FILE       Restore content of DB (default "main") from FILE
   .save FILE               Write in-memory database into FILE
   .scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off
   .schema ?PATTERN?        Show the CREATE statements matching PATTERN
   .selftest ?OPTIONS?      Run tests defined in the SELFTEST table
   .separator COL ?ROW?     Change the column and row separators
   .sha3sum ...             Compute a SHA3 hash of database content
   .shell CMD ARGS...       Run CMD ARGS... in a system shell
   .show                    Show the current values for various settings
   .stats ?on|off?          Show stats or turn stats on or off
   .system CMD ARGS...      Run CMD ARGS... in a system shell
   .tables ?TABLE?          List names of tables matching LIKE pattern TABLE
   .testcase NAME           Begin redirecting output to 'testcase-out.txt'
   .timeout MS              Try opening locked tables for MS milliseconds
   .timer on|off            Turn SQL timer on or off
   .trace ?OPTIONS?         Output each SQL statement as it is run
   .vfsinfo ?AUX?           Information about the top-level VFS
   .vfslist                 List all available VFSes
   .vfsname ?AUX?           Print the name of the VFS stack
   .width NUM1 NUM2 ...     Set column widths for "column" mode
   sqlite>
   #+end_example

- Fourth, to quit the =sqlite>=, you use  ~.quit~ command.

** The SQLite Studio GUI Tool

*** About SQLite Studio
#+cindex:SQLite Studio GUI tool
#+cindex:GUI tool
- [[https://github.com/pawelsalawa/sqlitestudio/wiki][Wiki]]
- [[https://github.com/pawelsalawa/sqlitestudio/wiki/User_Manual][User Manual]]

SQLiteStudio is a SQLite database manager with the following features:

- Portable :: no need to install or uninstall. Just download, unpack and run.
- Intuitive interface ::
- Powerful, yet light and fast ::
- All SQLite3 and SQLite2 features wrapped within simple GUI ::
- Cross-platform :: runs on Windows 9x/2k/XP/2003/Vista/7, Linux, MacOS X and
  should work on other Unixes (not tested yet)
- Exporting to various formats :: SQL statements, CSV, HTML, XML, PDF, JSON
- Importing data from various formats :: CSV, custom text files [regular
  expressions]
- Numerous small additions :: like formatting code, history of queries executed
     in editor windows, on-the-fly syntax checking, and more,
- Unicode support ::
- Skinnable :: interface can look native for Windows 9x/XP, KDE, GTK, Mac OS X,
               or draw widgets to fit for other environments, WindowMaker,
               etc),
- Configurable colors, fonts and shortcuts ::
- Open source and free :: Released under GPLv3 license

*** Install the SQLite GUI Tool
#+cindex:GUI tool
#+cindex:SQLite Studio
In this tutorial, we would like to introduce you to a free GUI tool for
managing SQLite databases named [[http://sqlitestudio.pl/][SQLite Studio]].  The SQLite studio is free,
portable, intuitive, and cross-platform.  It also provides some of the most
important features to work with SQLite databases such as importing, exporting
data in various formats including CSV, XML, and JSON.

You can download the SQLite studio at the homepage of SQLite, extract the file
into a folder e.g., ~/usr/local/sqlite/gui/~ and run it.

** The SQLite Sample Database
- http://www.sqlitetutorial.net/sqlite-sample-database/

- *Summary* :: in this tutorial, we first introduce you to an SQLite sample
               database.  Then, we will give you the links to download the
               sample database and its diagram.  At the end of the tutorial, we
               will show you how to connect to the sample database using the
               ~sqlite3~ tool.

*** Introduction to chinook SQLite sample database
#+cindex:@file{chinook.db}
#+cindex:sample database, @file{chinook.db}
We provide you with the SQLite sample database named =chinook=.  The =chinook=
sample database is a good database for practicing with SQL, especially SQLite.

The following database diagram illustrates the chinook database tables and
their relationships.

#+caption:The Chinook Database Tables and Relationships
#+name:fig:chinook-db-tables
[[file:figs/sqlite-sample-database-color.jpg]]

{{{heading(The Tables)}}}

#+cindex:@file{chinook.db} tables
There are 11 tables in the chinook sample database.

- =employees= ::

                 #+cindex:employees
                 stores employees data such as employee id, last name, first
                 name, etc.  It also has a field named =ReportsTo= to specify
                 who reports to whom.

- =customers= ::

                 #+cindex:customers
                 stores customers data.

- =invoices= & =invoice_items= ::

     #+cindex:invoices
     #+cindex:invoice_items
     these two tables store invoice data.  The =invoices= table stores invoice
     header data and the =invoice_items= table stores the invoice line items
     data.

- =artists= ::

               #+cindex:artists
               stores artists data.  It is a simple table that contains only
               artist id and name.

- =albums= ::

              #+cindex:albums
              stores data about a list of tracks.  Each album belongs to one
              artist.  However, one artist may have multiple albums.

- =media_types= ::

                   #+cindex:media_types
                   stores media types such as MPEG audio and AAC audio file.

- =genres= ::

              #+cindex:genres
              stores music types such as rock, jazz, metal, etc.

- =tracks= ::

              #+cindex:tracks
              store the data of songs.  Each track belongs to one album.

- =playlists= & =playlist_track= ::

     #+cindex:playlists
     #+cindex:playlist_tracks
     =playlists= table store data about playlists.  Each playlist contains a
     list of tracks.  Each track may belong to multiple playlists.  The
     relationship between the =playlists= table and =tracks= table is
     many-to-many.  The =playlist_track= table is used to reflect this
     relationship.

*** Download the SQLite Sample Database
#+cindex:@file{chinook.db} download
#+cindex:download @file{chinook.db}
You can download the SQLite sample database using the following link:

- [[http://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip][Download SQLite Sample Database]]

#+name:download-chinook-db
#+begin_src sh :dir db :results output
curl -O http://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip
#+end_src

#+RESULTS: download-chinook-db

*** Connect to SQLite Sample Database

#+cindex:connect to sample database
The name of the file is ~chinook.db~.

- Navigate to the SQLite installation directory (~/usr/local/sqlite/~) where
  the ~sqlite3.exe~ file is located.

- Second, you use the following command to connect to the =chinook= sample
  database located in the ~db/~ folder, which is a subfolder of the ~sqlite/~
  folder:
  : sqlite3 db/chinook.db
  : sqlite>

- Third, you can try a simple command e.g., ~.tables~ to view all the tables
  available in the sample database:
  : sqlite> .tables

   #+begin_example
   ? sqlite3 db/chinook.db
   SQLite version 3.28.0 2019-04-16 19:49:53
   Enter ".help" for usage hints.
   sqlite> .tables
   albums          employees       invoices        playlists
   artists         genres          media_types     tracks
   customers       invoice_items   playlist_track
   sqlite>
   #+end_example

** Commands Tutorial
- http://www.sqlitetutorial.net/sqlite-commands/

  #+cindex:@command{sqlite3} command-line tool
- *Summary* :: in this tutorial, we will introduce you to the most commonly
               used SQLite commands of the ~sqlite3~ command line program.

The SQLite project delivers a simple command-line tool named ~sqlite3~ (or
~sqlite3.exe~ on Windows) that allows you to interact with the SQLite databases
using SQL statements and commands.

*** Connect to an SQLite database

{{{heading(Connect using ~sqlite3~)}}}

To start the ~sqlite3~, you type the ~sqlite3~ as follows:

#+begin_src sh
>sqlite3
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
#+end_src

#+cindex:in-memory database
By default, an SQLite session uses the in-memory database; therefore all
changes will be gone when the session ends.

#+cindex:connect to database file
#+cindex:@command{.open} command
To open a database file, you use the ~.open FILENAME~ command.  The following
statement opens the ~chinook.db~ database:

: sqlite> .open c:\sqlite\chinook.db

#+cindex:open database file
#+cindex:database file, open
If you want to open a specific database file when you connect to the SQlite
database, you use the following command:

#+begin_src sh
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

If you start a session with a database name that does not exist, the ~sqlite3~
tool will create the database file.

For example, the following command creates a database named sales in the
C:\sqlite\ directory:

#+begin_src sh
>sqlite3 c:\sqlite\sales.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

*** Show all available commands and their purposes
#+cindex:@command{.help} command

{{{heading(All Available Commands: ~.help~)}}}

To show all available commands and their purpose, you use the ~.help~ command
as follows:

: .help

*** Show databases in the current database connection
#+cindex:@command{.databases} command
#+cindex:@code{main} database

{{{heading(All Connected Databases: ~.databases~)}}}

To show all databases in the current connection, you use the ~.databases~
command.  The ~.databases~ command displays at least one database with the
name: ~main~.

For example, the following command shows all the databases of the current
connection:

#+begin_src sql
sqlite> .database
seq  name             file
---  ---------------  --------------------------
0    main             c:\sqlite\sales.db
sqlite>
#+end_src

{{{heading(ATTACH DATABASE ... AS)}}}

#+cindex:@command{ATTACH DATABASE} statement
To add an additional database in the current connection, you use the =ATTACH
DATABASE= statement.  The following statement adds the =chinook= database to
the current connection.

: sqlite> ATTACH DATABASE "c:\sqlite\chinook.db" AS chinook;

Now if you run the ~.database~ command again, the ~sqlite3~ returns two
databases: =main= and =chinook=.

#+begin_src sql
sqlite> .databases
seq  name             file
---  ---------------  ---------------------
0    main             c:\sqlite\sales.db
2    chinook          c:\sqlite\chinook.db
#+end_src

*** Exit sqlite3

{{{heading(.exit Command)}}}

#+cindex:@command{.exit} command
To exit the ~sqlite3~ program, you use the ~.exit~ command.

: sqlite>.exit

*** Show tables in a database

{{{heading(Show Tables in DB: ~.tables~)}}}

#+cindex:@command{.tables} command
To display all the tables in the current database, you use the ~.tables~
command.  The following commands open a new database connection to the
=chinook= database and display the tables in the database.

#+begin_src sql
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite> .tables
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
sqlite>
#+end_src

{{{subheading(.tables <pattern>)}}}

#+cindex:@command{.table} pattern command
#+cindex:@command{LIKE} operator
If you want to find tables based on a specific pattern, you use the ~.table~
pattern command.  The ~sqlite3~ uses the =LIKE= operator for pattern matching.

For example, the following statement returns the table that ends with the
string =es=.

#+begin_src sql
sqlite> .table '%es'
employees    genres       invoices     media_types
sqlite>
#+end_src

*** Show the structure of a table

{{{heading(Show Table Structure: ~.schema <table | pattern>~)}}}

#+cindex:@command{.schema} command
To display the structure of a table, you use the ~.schema TABLE~ command.  The
=TABLE= argument could be a pattern.  If you omit it, the ~.schema~ command will
show the structures of all the tables.

The following command shows the structure of the =albums= table.

#+begin_src sql
sqlite> .schema albums
CREATE TABLE "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON "albums" ([ArtistId]);
sqlite>
#+end_src

{{{subheading(~.fullschema~)}}}

#+cindex:@command{.fullschema} command
To show the schema and the content of the =sqlite_stat= tables, you use the
~.fullschema~ command.

: sqlite>.fullschema

*** Show indexes

{{{heading(Show All Indexes of DB: ~.indexes <table | pattern>~)}}}

#+cindex:@command{.indexes} command
To show all indexes of the current database, you use the ~.indexes~ command as
follows:

#+begin_src sh
sqlite> .indexes
IFK_AlbumArtistId
IFK_CustomerSupportRepId
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
IFK_InvoiceLineInvoiceId
IFK_InvoiceLineTrackId
IFK_PlaylistTrackTrackId
IFK_TrackAlbumId
IFK_TrackGenreId
IFK_TrackMediaTypeId
#+end_src

To show the indexes of a specific table, you use the ~.indexes TABLE~ command.
For example, to show indexes of the =albums= table, you use the following
command:

#+begin_src text
sqlite> .indexes albums
IFK_AlbumArtistId
#+end_src

#+cindex:@command{LIKE} operator
To show indexes of the tables whose names end with =es=, you use a pattern of
the =LIKE= operator.

#+begin_src text
sqlite> .indexes %es
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
#+end_src

*** Save the result of a query into a file

{{{heading(Save Query Results in File: ~.output <filename>~)}}}

{{{subheading(~.once <filename>~)}}}

#+cindex:@command{.output} command
#+cindex:@command{.once} command
To save the result of a query into a file, you use the ~.output FILENAME~
command.  Once you issue the ~.output~ command, all the results of the
subsequent queries will be saved to the file that you specified in the
=FILENAME= argument.  If you want to save the result of the next single query
only to the file, you issue the ~.once FILENAME~ command.

{{{subheading(~.output~)}}}

To display the result of the query to the standard output again, you issue the
~.output~ command without arguments.

The following commands select the title from the =albums= table and write the
result to the ~albums.txt~ file.

#+begin_src sql
sqlite> .output albums.txt
sqlite> SELECT title FROM albums;
#+end_src

*** Execute SQL statements from a file
Suppose we have a file named ~commands.txt~ in the ~c:/sqlite/~ folder with the
following content:

#+begin_src sql
SELECT albumid, title
FROM albums
ORDER BY title
LIMIT 10;
#+end_src

{{{heading(Execute SQL Statements from File: ~.read <filename>~)}}}

#+cindex:@command{.read} command
To execute the SQL statements in the ~commands.txt~ file, you use the ~.read
FILENAME~ command as follows:

#+begin_src text
sqlite> .mode column
sqlite> .read c:/sqlite/commands.txt
156         ...And Justice For All
257         20th Century Masters -
296         A Copland Celebration,
94          A Matter of Life and D
95          A Real Dead One
96          A Real Live One
285         A Soprano Inspired
139         A TempestadeTempestade
203         A-Sides
160         Ace Of Spades
#+end_src

* Basic SQLite tutorial
This section presents basic SQL statements that you can use with SQLite.  You
will first start querying data from the [[http://www.sqlitetutorial.net/sqlite-sample-database/][sample database]].

** Simple query
- http://www.sqlitetutorial.net/sqlite-select/

  #+cindex:SELECT statement
- SQLite Select ::

     - http://www.sqlitetutorial.net/sqlite-select/

     query data from a single table


#+cindex:@command{SELECT} statement
- *Summary* :: in this tutorial, you will learn how to use the SQLite =SELECT=
               statement to query data from a single table.

{{{heading(SELECT)}}}

The =SELECT= statement is the most commonly used statement in SQL.  The SQLite
=SELECT= statement provides all of the features of the =SELECT= statement in
the SQL standard.

*** Simple uses of the =SELECT= statement
You can use the =SELECT= statement to perform a simple calculation as follows:

#+begin_src sql
SELECT
 1 + 1;
#+end_src

#+cindex:expessions, multiple, @command{SELECT}
You can use multiple expressions in the SELECT statement as follows:

#+begin_src sql
SELECT
 10 / 5, 2 * 4 ;
#+end_src

*** Querying data from a table using the =SELECT= statement
We often use the =SELECT= statement to query data from one or more table.  The
syntax of the =SELECT= statement is as follows:

{{{heading(SELECT Syntax)}}}
#+cindex:@command{SELECT} syntax

#+begin_src sql
SELECT DISTINCT column_list
FROM table_list
  JOIN table ON join_condition
WHERE row_filter
ORDER BY column
LIMIT count OFFSET offset
GROUP BY column
HAVING group_filter;
#+end_src

The =SELECT= statement is the most complex statement in SQLite.  To help make
it easier to understand each part, we will break the =SELECT= statement into
multiple easy-to-understand tutorials.

#+cindex:@command{ORDER BY} clause
#+cindex:sort result set
- Use =ORDER BY= clause to sort the result set

  #+cindex:@command{DISTINCT} clause
  #+cindex:query unique rows
- Use =DISTINCT= clause to query unique rows in a table

  #+cindex:@command{WHERE} clause
  #+cindex:filter rows
- Use =WHERE= clause to filter rows in the result set

  #+cindex:@command{LIMIT OFFSET} clause
  #+cindex:constrain number of rows
- Use =LIMIT OFFSET= clauses to constrain the number of rows returned

  #+cindex:@command{INNER JOIN}
  #+cindex:@command{LEFT JOIN}
  #+cindex:query data from multiple tables
  #+cindex:join
- Use =INNER JOIN= or =LEFT JOIN= to query data from multiple tables using
  join.

  #+cindex:@command{GROUP BY}
  #+cindex:groups
  #+cindex:aggregrate function
- Use =GROUP BY= to get the group rows into groups and apply aggregate function
  for each group.

  #+cindex:@command{HAVING} clause
  #+cindex:filter groups
- Use =HAVING= clause to filter groups


{{{subheading(SELECT <column-list> FROM <table-list>)}}}

#+cindex:query data from single table
#+cindex:@command{FROM} clause, with @command{SELECT} clause
In this tutorial, we are going to focus on the simplest form of the =SELECT=
statement that allows you to query data from a single table.

#+begin_src sql
SELECT column_list
FROM table;
#+end_src

Even if the =SELECT= clause appears before the =FROM= clause, SQLite evaluates
the =FROM= clause first and then the =SELECT= clause; therefore:

#+cindex:@command{FROM} clause
- First, you specify the table where you want to get data from in the =FROM=
  clause.  Notice that you can have more than one table in the =FROM= clause.
  We will discuss it in the subsequent tutorial.

  #+cindex:column, specify using @command{SELECT}
  #+cindex:@command{SELECT} clause
- Second, you specify a column or a list of comma-separated columns in the
  =SELECT= clause.


You use the semicolon (=;=) to terminate the statement.

*** SQLite =SELECT= examples
Let’s take a look at the =tracks= table in the sample database.

[[file:figs/tracks.png]]

The =tracks= table contains columns and rows.  It looks like a spreadsheet.

[[file:figs/Tracks-Table-data.jpg]]

To get data from the tracks table such as =trackid=, =track name=, =composer=,
and =unit price=, you use the following statement:

#+begin_src sql
SELECT
 trackid,
 name,
 composer,
 unitprice
FROM
 tracks;
#+end_src

You specify a list column names, which you want to get data, in the =SELECT=
clause and the tracks table in the =FROM= clause.  SQLite returns the following
result:

[[file:figs/Tracks-Table-partial-data.jpg]]

To get data from all columns, you specify the columns of the =tracks= table in
the =SELECT= clause as follows:

#+begin_src sql
SELECT
 trackid,
 name,
 albumid,
 mediatypeid,
 genreid,
 composer,
 milliseconds,
 bytes,
 unitprice
FROM
 tracks;
#+end_src

For a table with many columns, the query would be too long and time-consuming
to type.  To avoid this, you can use the asterisk (=*=), which is the shorthand
for all columns of the table as follows:

#+begin_src sql
SELECT
 *
FROM
 tracks;
#+end_src

The query is shorter and cleaner now.

However…

You should use the asterisk (=*=) for the testing purpose only, not in the real
application development.

Because…

When you develop an application, you should control what SQLite returns to your
application.  Suppose, a table has 3 columns, and you use the asterisk (=*=) to
retrieve the data from all three columns.

What if someone removes a column? Your application would not be working
properly, because it assumes that there are three columns returned and the
logic to process those three columns would be broken.

If someone adds more columns, your application may work but it gets more data
than needed, which creates more I/O overhead between the database and
application.

So try to avoid using the asterisk (=*=) as a good habit when you use the
=SELECT= statement.

** Sorting rows
- http://www.sqlitetutorial.net/sqlite-order-by/

- SQLite Order By ::

     sort the result set in ascending or descending order

#+cindex:@command{ORDER BY} clause
#+cindex:sort result set, @command{ORDER BY}
- *Summary* :: in this tutorial, you will learn how to sort the result set
               using SQLite =ORDER BY= clause.

*** Introduction to SQLite =ORDER BY= clause
SQLite stores rows in a table in an unspecified order.  It means that the rows
in the table may or may not be in the order that they were inserted.

{{{heading(ORDER BY)}}}

If you use the =SELECT= statement to query data from a table, the order of rows
in the result set is unspecified.  To sort the result set, you add the =ORDER
BY= clause in the =SELECT= statement as follows:

#+begin_src sql
SELECT
 column_list
FROM
 table
ORDER BY
 column_1 ASC,
 column_2 DESC;
#+end_src

{{{subheading(after FROM clause)}}}

The =ORDER BY= clause comes after the =FROM= clause.  The =ORDER BY= clause
allows you to sort the result set based on one or more columns in different
orders: ascending and descending.

#+cindex:@command{ASC} keyword
#+cindex:@command{DESC} keyword
#+cindex:ascending order
#+cindex:descending order
#+cindex:order of sert, ascending or descending
You put the column name that you want to use to sort after the =ORDER BY=
clause followed by the =ASC= or =DESC= keyword.  The =ASC= keyword means
ascending order, and =DESC= keyword means descending orders.

If you don’t specify the =ASC= or =DESC= keyword, SQLite uses =ASC= or
ascending order by default.

#+cindex:sort multiple columns
In case you want to sort the result set by multiple columns, you use a comma
(=,=) to separate columns.  The =ORDER BY= clause sorts rows using columns from
left to right.  In other words, the =ORDER BY= clause sorts the rows using the
first column in the list.  Then, it sorts the sorted rows using the second
column, and so on.

You can sort the result set using a column that does not appear in the column
list of the =SELECT= clause.

#+cindex:@code{NULL} value
SQLite processes =NULL= value differently.  A row with a =NULL= value is higher
than rows with regular values in ascending order, and it is reversed for
descending order.

*** SQLite =ORDER BY= clause example
Let’s take the =tracks= table in the sample database for the demonstration.

[[file:figs/tracks.png]]

Suppose, you want to get data from =name=, =milliseconds=, and =album id=
columns, you use the following statement:

#+begin_src sql
SELECT
 name,
 milliseconds,
 albumid
FROM
 tracks;
#+end_src

[[file:figs/tracks-table-data-without-sorting.jpg]]

The =SELECT= statement that does not use =ORDER BY= clause returns a result set
that is not in any order.

Suppose you want to sort the result set based on =AlbumId= column in ascending
order, you use the following statement:

#+begin_src sql
SELECT
 name,
 milliseconds,
 albumid
FROM
 tracks
ORDER BY
 albumid ASC;
#+end_src

[[file:figs/SQLite-ORDER-BY-example.jpg]]

The result set now is sorted by the =AlbumId= column in ascending order as
shown in the screenshot.

SQLite uses =ASC= by default so you can omit it in the above statement as
follows:

#+begin_src sql
SELECT
 name,
 milliseconds, 
 albumid
FROM
 tracks
ORDER BY
 albumid;
#+end_src

Suppose you want to sort the sorted result (by =AlbumId=) above by the
=Milliseconds= column in descending order.  In this case, you need to add the
=Milliseconds= column to the =ORDER BY= clause as follows:

#+begin_src sql
SELECT
 name,
 milliseconds, 
 albumid
FROM
 tracks
ORDER BY
 albumid ASC,
 milliseconds DESC;
#+end_src

[[file:figs/SQLite-ORDER-BY-multiple-columns-example.jpg]]

SQLite sorts rows by =AlbumId= column in ascending order first.  Then, it sorts
the sorted result set by the =Milliseconds= column in descending order.

If you look at the tracks of the album with =AlbumId= 1, you find that the order
of tracks changes between the two statements.

*** SQLite =ORDER BY= with the column position

Instead of specifying the names of columns, you can use the column’s position
in the =ORDER BY= clause.

For example, the following statement sorts the tracks by both =AlbumId= and
=Milliseconds= in ascending order.

#+begin_src sql
SELECT
 name,
 milliseconds, 
 albumid
FROM
 tracks
ORDER BY
 3,2;
#+end_src

The number 3 and 2 refers to the =AlbumId= and =Milliseconds= in the column
list that appears in the =SELECT= clause.

[[file:figs/SQLite-ORDER-BY-multiple-columns-by-positions.jpg]]

** Filtering data
*** SQLite Select Distinct
- http://www.sqlitetutorial.net/sqlite-select-distinct

- query unique rows from a table using the [[http://www.sqlitetutorial.net/sqlite-select-distinct][=DISTINCT=]] clause.

#+cindex:@code{SELECT DISTINCT} clause
- *Summary* :: in this tutorial, you will learn how to use the SQLite =SELECT
               DISTINCT= clause to remove duplicate rows in the result set.

**** Introduction to SQLite =SELECT DISTINCT= clause
The =DISTINCT= clause is an optional clause of the =SELECT= statement.  The
=DISTINCT= clause allows you to remove the duplicate rows in the result set.

{{{heading(DISTINCT: remove duplicates)}}}

The following statement illustrates the syntax of the DISTINCT clause:

#+begin_src sql
SELECT DISTINCT
 column_list
FROM
 table;
#+end_src

The =DISTINCT= clause must appear after the =SELECT= clause.

You put a column or a list of columns after the =DISTINCT= clause.  If you use
one column, SQLite uses that column to evaluate the duplicate.  In case you use
multiple columns, SQLite uses the combination of those columns to evaluate the
duplicate.

SQLite considers =NULL= values as duplicates.  If you use the =DISTINCT= clause
with a column that has =NULL= values, SQLite will keep one row of a =NULL=
value.

**** SQLite =SELECT DISTINCT= examples

**** SQLite =SELECT DISTINCT= on multiple columns
The following statement gets all the cities and countries of all customers.

#+begin_src sql
SELECT
 city,
 country
FROM
 customers
ORDER BY
 country;
#+end_src

[[file:figs/SQLite-DISTINCT-multiple-columns.jpg]]

The result set contains duplicate city and country e.g., Sao Paulo in Brazil as
shown in the screenshot above.

To remove duplicate city and country, you apply the =DISTINCT= clause to both
city and country columns as the shown in the following query:

#+begin_src sql
SELECT  DISTINCT
 city,
 country
FROM
 customers
ORDER BY
 country;
#+end_src

As mentioned earlier, SQLite uses the combination of city and country to
evaluate the duplicate.

**** SQLite SELECT DISTINCT with NULL values example

To find the names of companies of our customers, you query data from company
column of the =customers= table.

#+begin_src sql
SELECT
 company
FROM
 customers;
#+end_src

It returns 59 rows with many =NULL= values.

Now, if you apply the =DISTINCT= clause to the statement, it will keep only one
row with a =NULL= value.

#+begin_src sql
SELECT DISTINCT
 company
FROM
 customers;
#+end_src

[[file:figs/SQLite-SELECT-with-DISTINCT-NULL-values.jpg]]

The statement returns 11 rows with one =NULL= value.

*** SQLite Where
- http://www.sqlitetutorial.net/sqlite-where/

- filter rows of a result set using various conditions


- *Summary* :: in this tutorial, you will learn how to use SQLite =WHERE=
               clause to specify the search condition for rows returned by the
               query.

**** Introduction to SQLite =WHERE= clause
#+cindex:@command{WHERE} clause
The =WHERE= clause is an optional clause of the =SELECT= statement.  It appears
after the =FROM= clause as the following statement:

{{{heading(WHERE: filter data)}}}

#+begin_src sql
SELECT
 column_list
FROM
 table
WHERE
 search_condition;
#+end_src

#+cindex:filter data using @command{WHERE} clause
#+cindex:predicate list, @command{HWERE} clause
You add a =WHERE= clause to the =SELECT= statement to filter data returned by
the query.  The =WHERE= clause is also known as a set of conditions or a
predicate list.

When evaluating a SELECT statement with a WHERE clause, SQLite uses the
following steps:

1. First, check the table in the =FROM= clause.

2. Second, evaluate the conditions in the =WHERE= clause to get the rows that
   met the conditions.

3. Third, make the final result set based on the rows in the previous step with
   columns in the =SELECT= clause.


The search condition in the =WHERE= has the following form:

: left_expression COMPARISON_OPERATOR right_expression

For example, you can form a search condition as follows:

#+cindex:@command{IN}
#+cindex:@command{LIKE}
#+cindex:@command{BETWEEN}
#+begin_src sql
WHERE column_1 = 100;

WHERE column_2 IN (1,2,3);

WHERE column_3 LIKE 'An%';

WHERE column_4 BETWEEN 10 AND 20;
#+end_src

#+cindex:@command{UPDATE} statement
#+cindex:@command{DELETE}
Besides the =SELECT= statement, you can use the =WHERE= clause in the =UPDATE=
and =DELETE= statements.

**** SQLite comparison operators
#+cindex:comparison operator
A comparison operator tests if two expressions are the same.  The following
table illustrates the comparison operators that you can use to construct
expressions.

| Operator | Meaning                  |
|----------+--------------------------|
| =        | Equal to                 |
| <> or != | Not equal to             |
| <        | Less than                |
| >        | Greater than             |
| <=       | Less than or equal to    |
| >=       | Greater than or equal to |
|----------+--------------------------|

**** SQLite logical operators
#+cindex:logical operators
Logical operators allow you to test the truth of some expressions.  A logical
operator returns 1, 0, or a =NULL= value.

Notice that SQLite does not provide Boolean data type therefore 1 means =TRUE=,
and 0 means =FALSE=.

The following table illustrates the SQLite logical operators:

| Operator | Meaning                                                                             |
|----------+-------------------------------------------------------------------------------------|
| ALL      | returns 1 if all expressions are 1.                                                 |
| AND      | returns 1 if both expressions are 1, and 0 if one of the expressions is 0.          |
| ANY      | returns 1 if any one of a set of comparisons is 1.                                  |
| BETWEEN  | returns 1 if a value is within a range.                                             |
| EXISTS   | returns 1 if a subquery contains any rows.                                          |
| IN       | returns 1 if a value is in a list of values.                                        |
| LIKE     | returns 1 if a value matches a pattern                                              |
| NOT      | reverses the value of other operators such as NOT EXISTS, NOT IN, NOT BETWEEN, etc. |
| OR       | returns true if either expression is 1                                              |
|----------+-------------------------------------------------------------------------------------|

**** SQLite =WHERE= clause examples
We will use the =tracks= table in the sample database to demonstrate how to use
the =WHERE= clause.

**** SQLite =WHERE= clause with =LIKE= operator example
#+cindex:@command{LIKE} operator
Sometimes, you may not remember exactly the data that you want to search.  In
this case, you perform an inexact search using the =LIKE= operator.

For example, to find which tracks composed by Smith, you use the =LIKE= operator
as follows:

#+begin_src sql
SELECT
 name,
 albumid,
 composer
FROM
 tracks
WHERE
 composer LIKE '%Smith%'
ORDER BY
 albumid;
#+end_src

**** SQLite =WHERE= clause with the =IN= operator example
#+cindex:@command{IN} operator
The =IN= operator allows you to check whether a value is in a list of
comma-separated list of values.  For example, to find tracks that have media
type id is 1 or 2, you use the =IN= operator as the following statement:

#+begin_src sql
SELECT
 name,
 albumid,
 mediatypeid
FROM
 tracks
WHERE
 mediatypeid IN (2, 3);
#+end_src

*** SQLite Limit
- http://www.sqlitetutorial.net/sqlite-limit/

- constrain the number of rows that you want to return.  The =LIMIT= clause
  helps you get the necessary data returned by a query.


- *Summary* :: in this tutorial, you will learn how to use SQLite =LIMIT=
               clause to constrain the number of rows returned by a query.

**** Introduction to SQLite LIMIT clause
#+cindex:@command{LIMIT} clause
#+cindex:constrail number of rows, @command{LIMIT}
The =LIMIT= clause is an optional part of the =SELECT= statement.  You use the
=LIMIT= clause to constrain the number of rows returned by the query.

For example, a =SELECT= statement returns one million rows.  However, if you
just need the first 10 rows in the result set, you add the =LIMIT= clause to the
=SELECT= statement to get exact 10 rows.

The following illustrates the syntax of the =LIMIT= clause.

#+begin_src sql
SELECT
 column_list
FROM
 table
LIMIT row_count;
#+end_src

#+cindex:@code{row_count}
The =row_count= is a positive integer that specifies the number of rows
returned.

For example, to get the first 10 rows in the =tracks= table, you use the
following statement:

#+begin_src sql
SELECT
 trackId,
 name
FROM
 tracks
LIMIT 10;
#+end_src

#+cindex:@command{OFFSET} keyword
If you want to get the first 10 rows starting from the 10th row of the result
set, you use =OFFSET= keyword as the following:

#+begin_src sql
SELECT
 column_list
FROM
 table
LIMIT row_count OFFSET offset;
#+end_src

#+cindex:@command{LIMIT OFFSET} clause shorthand syntax
Or you can use the following shorthand syntax of the =LIMIT OFFSET= clause:

#+begin_src sql
SELECT
 column_list
FROM
 table
LIMIT offset, row_count;
#+end_src

For example, to get 10 rows starting from the 10th row in the =tracks= table, you
use the following statement:

#+begin_src sql
SELECT
 trackId,
 name
FROM
 tracks
LIMIT 10 OFFSET 10;
#+end_src

#+cindex:paginate result sets, @command{OFFSET}
You often find the uses of =OFFSET= in web applications for paginating result
sets.

**** SQLite =LIMIT= and =ORDER BY= clause
#+cindex:@command{LIMIT ORDER BY}
We typically use the =LIMIT= clause with =ORDER BY= clause, because we are
interested in getting the number of rows in a specified order, not in
unspecified order.

The =ORDER BY= clause appears before the =LIMIT= clause in the =SELECT=
statement.  SQLite sorts the result set before getting the number of rows
specified in the =LIMIT= clause.

#+begin_src sql
SELECT
 column_list
FROM
 table
ORDER BY
 column_1
LIMIT row_count;
#+end_src

For example, to get the top 10 largest tracks in bytes, you use the following
query:

#+begin_src sql
SELECT
 trackid,
 name,
 bytes
FROM
 tracks
ORDER BY
 bytes DESC
LIMIT 10;
#+end_src

To get 5 shortest tracks, you sort the tracks by length specified by
milliseconds column using =ORDER BY= clause and get first 5 rows using =LIMIT=
clause.

#+begin_src sql
SELECT
 trackid,
 name,
 milliseconds
FROM
 tracks
ORDER BY
 milliseconds ASC
LIMIT 5;
#+end_src

**** Getting the n^th highest and lowest values
#+cindex:nth highest, lowest
You can use the =ORDER BY= and =LIMIT= clauses to get the n^th highest or lowest
value row.  For example, you may want to know the second longest track, the
third smallest track, etc.

To do this, you use the following steps:

1. First, use =ORDER BY= to sort the result set in ascending order in case you
   want to get the n^th lowest value, or descending order if you want to get the
   n^th highest value.

2. Second, use the =LIMIT OFFSET= clause to get the n^th highest or the n^th
   lowest row.


The following statement returns the second longest track in the tracks table.

#+begin_src sql
SELECT
 trackid,
 name,
 milliseconds
FROM
 tracks
ORDER BY
 milliseconds DESC
LIMIT 1 OFFSET 1;
#+end_src

The following statement gets the third smallest track on the =tracks= table.

#+begin_src sql
SELECT
 trackid,
 name,
 bytes
FROM
 tracks
ORDER BY
 bytes
LIMIT 1 OFFSET 2;
#+end_src

*** SQLite BETWEEN
- http://www.sqlitetutorial.net/sqlite-between/

- test whether a value is in a range of values


- *Summary* :: in this tutorial, you will learn how to use the SQLite =BETWEEN=
               operator to test whether a value is in a range of values.

**** Introduction to SQLite =BETWEEN= Operator
#+cindex:@command{BETWEEN} operator
#+cindex:range of values
The =BETWEEN= operator is a logical operator that tests whether a value is in
range of values.  If the value is in the specified range, the =BETWEEN=
operator returns =true=.  The =BETWEEN= operator can be used in the =WHERE=
clause of the =SELECT=, =DELETE=, =UPDATE=, and =REPLACE= statements.

The following illustrates the syntax of the SQLite =BETWEEN= operator:
: test_expression BETWEEN low_expression AND high_expression

In this syntax:

- =test_expression= is an expression to test for in the range defined by
  =low_expression= and =high_expression=.

- =low_expression= and =high_expression= is any valid expression that specify
  the low and high values of the range.  The =low_expression= should be less
  than or equal to =high_expression=, or the =BETWEEN= is always returns
  =false=.

  #+cindex:@command{AND} keyword
- The =AND= keyword is a placeholder which indicates the =test_expression=
  should be within the range specified by =low_expression= and
  =high_expression=.


Note that the BETWEEN operator is inclusive.  It returns =true= when the
=test_expression= is less than or equal to =high_expression= and greater than
or equal to the value of =low_expression=:
: test_expression >= low_expression AND test_expression <= high_expression

To specify an exclusive range, you use the greater than (=>=) and less than
operators (=<=).

Note that if any input to the =BETWEEN= operator is =NULL=, the result is
=NULL=, or unknown to be precise.

{{{heading(NOT BETWEEN Operator)}}}

#+cindex:@command{NOT BETWEEN} operator
To negate the result of the =BETWEEN= operator, you use the =NOT BETWEEN=
operator as follows:
: test_expression NOT BETWEEN low_expression AND high_expression

The =NOT BETWEEN= returns =true= if the value of =test_expression= is less than
the value of =low_expression= or greater than the value of =high_expression=:
: test_expression < low_expression OR test_expression > high_expression

**** SQLite =BETWEEN= operator examples

We will use the =invoices= table from the sample database for the
demonstration:

[[file:figs/invoices.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/invoices.png]]

***** SQLite =BETWEEN= numeric values example

The following statement finds invoices whose total is =BETWEEN= 14.96 and
18.86:

#+begin_src sql
SELECT
    InvoiceId,
    BillingAddress,
    Total
FROM
    invoices
WHERE
    Total BETWEEN 14.91 and 18.86    
ORDER BY
    Total; 
#+end_src

Here is the output:

[[file:figs/SQLite-BETWEEN-Numbers-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-BETWEEN-Numbers-example.png]]

***** SQLite =NOT BETWEEN= numeric values example

To find the invoices whose total are not between 1 and 20, you use the =NOT
BETWEEN= operator as shown in the following query:

#+begin_src sql
SELECT
    InvoiceId,
    BillingAddress,
    Total
FROM
    invoices
WHERE
    Total NOT BETWEEN 1 and 20
ORDER BY
    Total;
#+end_src

***** SQLite =BETWEEN= dates example

The following example finds invoices whose invoice dates are from January 1
2010 and January 31 2010:

#+begin_src sql
SELECT
    InvoiceId,
    BillingAddress,
    InvoiceDate,
    Total
FROM
    invoices
WHERE
    InvoiceDate BETWEEN '2010-01-01' AND '2010-01-31'
ORDER BY
    InvoiceDate;
#+end_src

*** SQLite IN
- http://www.sqlitetutorial.net/sqlite-in/

- check if a value matches any value in a list of value or subquery


#+cindex:@command{IN} operator
#+cindex:match values
- *Summary* :: in this tutorial, you will learn how to use the SQLite =IN=
               operator to determine whether a value matches any value in a
               list of values or a subquery.

**** Introduction to the SQLite =IN= operator
The SQLite =IN= operator is used to determine whether a value matches any value
in a list or a subquery.  The syntax of the =IN= operator is as follows:

: expression [NOT] IN (value_list|subquery);

The =expression= can be any valid expression.  It can be a column of a table.

A list of values is a fixed value list or a result set of one column returned
by a subquery.  The returned type of the expression and values in the list must
be the same.

#+cindex:@command{NOT IN} operator
The =IN= operator returns =true= or =false= depending on whether the expression
matches any value in a list of values or not.  To negate the list of values, you
use the =NOT IN= operator.

**** SQLite =IN= operator examples

We will use the =tracks= table in the sample database for the demonstration.

[[file:figs/tracks.png]]

The following statement uses the =IN= operator to query the tracks whose media
type id is 1 or 2.

#+begin_src sql
SELECT
 trackid,
 name,
 mediatypeid
FROM
 tracks
WHERE
 mediatypeid IN (1, 2)
ORDER BY
 name ASC;
#+end_src

[[file:figs/SQLite-IN-Operator.jpg]]


#+cindex:@command{OR} operator
You can achieve the same result using the =OR= operator.

#+begin_src sql
SELECT
 trackid,
 name,
 MediaTypeId
FROM
 tracks
WHERE
 mediatypeid = 1 OR mediatypeid = 2
ORDER BY
 name ASC;
#+end_src

Using the =IN= operator is much shorter.  If you have a query that uses many
=OR= operators in an expression, you can use the =IN= operator to replace the
=OR= operators to make the query more readable.

**** SQLite =IN= operator with a subquery example
The following query returns a list of album id of the artist id 12:

#+begin_src sql
SELECT
 albumid
FROM
 albums
WHERE
 artistid = 12;
#+end_src

To get the tracks that belong to the artist id 12, you can combine the =IN=
operator with a subquery as follows:

#+begin_src sql
SELECT
 trackid,
 name,
 albumid
FROM
 tracks
WHERE
 albumid IN (
 SELECT
 albumid
 FROM
 albums
 WHERE
 artistid = 12
 );
#+end_src

[[file:figs/SQLite-IN-subquery-example.jpg]]

*** SQLite Like
- http://www.sqlitetutorial.net/sqlite-like/

- query data based on pattern matching using wildcard characters: percent sign
  (=%=) and underscore (=_=)


- *Summary* :: in this tutorial, you will learn how to query data based on
               pattern matching using SQLite LIKE operator.

**** Introduction to SQLite =LIKE= operator

Sometimes, you don’t know exactly the complete keyword that you want to
query.  For example, you may know that your most favorite song contains the
word, "elevator" but you don’t know exactly the name.

#+cindex:@command{LIKE} operator
To query data based on partial information, you use the SQLite =LIKE= operator
in the =WHERE= clause of the =SELECT= statement as follows:

#+begin_src sql
SELECT
 column_list
FROM
 table_name
WHERE
 column_1 LIKE pattern;
#+end_src

Note that you can also use the =LIKE= operator in the =WHERE= clause of other
statements such as =DELETE= and =UPDATE=.

There are two ways to construct a pattern: using percent sign =%= and
underscore =_= wildcards:

1. The percent sign =%= wildcard matches any sequence of zero or more
   characters.

2. The underscore =_= wildcard matches any single character.

**** The percent sign =%= wildcard examples
The percent sign =s%= matches any string that starts with =s=, e.g., =son=,
=so=, etc.  The =%er= pattern matches any string that ends with er e.g.,
=peter=, =clever=, etc.  And the =%per%= pattern matches any string that
contains =per= such as =percent=, =peeper=, etc.

**** The underscore =_= wildcard examples
The =h_nt= pattern matches =hunt=, =hint=, etc.  The =__pple= pattern matches
=topple=, =supple=, =tipple=, etc.


#+cindex:case sensitive, insensitive
#+cindex:Unicode
#+cindex:ASCII
#+cindex:@command{PRAGMA}, case sensitive
Note that SQLite =LIKE= operator is case-insensitive.  It means ="A" LIKE "a"=
is =true=.  However, for Unicode characters that are not in the ASCII range,
SQLite =LIKE= operator is case sensitive e.g., ="Ä" LIKE "ä"= is =false=.  In
case you want to make =LIKE= case sensitive, you use the following =PRAGMA=:

: PRAGMA case_sensitive_like = true;

**** SQLite =LIKE= and escape character
#+cindex:escape character
#+cindex:@command{ESCAPE} clause
If the pattern that you want to match contains =%= or =_=, you must use an
escape character in an optional =ESCAPE= clause as follows:

: column_1 LIKE pattern ESCAPE "escape_character";

For example, you want to find =get_value= in the table, you put the =_= as the
escape character like the following expression:

: column_1 LIKE '%get_value%' ESCAPE '_';

**** SQLite LIKE examples

We use the =tracks= table in the sample database for the purpose of
demonstration.

[[file:figs/tracks.png]]

To find the tracks whose names start with the =Wild= literal string, you use the
percent sign =%= wildcard at the end of the pattern.

#+begin_src sql
SELECT
 trackid,
 name 
FROM
 tracks
WHERE
 name LIKE 'Wild%'
#+end_src

[[file:figs/SQLite-LIKE-percentage-wildcard.png]]

To find the tracks whose names end with =Wild= word, you use =%= wildcard at
the beginning of the pattern.

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name LIKE '%Wild'
#+end_src

[[file:figs/SQLite-LIKE-example.png]]

To find the tracks whose names contain the =Wild= literal string, you use =%=
wildcard at the beginning and end of the pattern:

#+begin_src sql
SELECT
 trackid,
 name 
FROM
 tracks
WHERE
 name LIKE '%Wild%';
#+end_src

[[file:figs/SQLite-LIKE-wildcard-example.png]]

The following statement finds the tracks whose names contain: zero or more
characters (=%=), followed by =Br=, followed by a character (=_=), followed by
=wn=, and followed by zero or more characters (=%=):

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name LIKE '%Br_wn%';
#+end_src

*** SQLite Glob
- http://www.sqlitetutorial.net/sqlite-glob/

- determine whether a string matches a specific UNIX-pattern


- *Summary* :: in this tutorial, you will learn how to use the SQLite GLOB
               operator to determine whether a string matches a specific
               pattern.

**** Introduction to the SQLite =GLOB= operator
The =GLOB= operator is similar to the LIKE operator.  The =GLOB= operator
determines whether a string matches a specific pattern.

Unlike the =LIKE= operator, the =GLOB= operator is case sensitive and uses the
=UNIX= wildcards.  In addition, the =GLOB= patterns do not have escape
character.

The following shows the =GLOB= wildcards:

- the asterisk (=*=) wildcard matches any number of characters.

- the question mark (=?=) wildcard matches exactly one character.


In addition, you can use the list wildcard =[]= to match one character from a
list of characters.  For example =[xyz]= match any single x, y, or z character.

The list wildcard also allows a range of characters e.g., =[a-z]= matches any
single lowercase character from a to z. The =[a-zA-Z0-9]= pattern matches any
single alphanumeric character, both lowercase and uppercase.

You use the =^= at the beginning of the list to match any character except any
character in the list.  For example, the =[^0-9]= pattern matches any single
character except a numeric character.

**** SQLite GLOB examples
The following statement finds tracks whose names start with the string =Man=.  The
pattern =Man*= matches any string that starts with =Man=.

#+begin_src sql
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB 'Man*';
#+end_src

The following statement gets the tracks whose names end with =Man=.  The
pattern =*Man= matches any string that ends with =Man=.

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*Man';
#+end_src

The following query finds the tracks whose names start with any single
character (=?=), followed by the string ere and then any number of character
(=*=).

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '?ere*';
#+end_src

To find the tracks whose names contain numbers, you can use the list wildcard
=[0-9]= as follows:

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*[1-9]*';
#+end_src

Or to find the tracks whose name does not contain any number, you place the =^=
at the beginning of the list:

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*[^1-9]*';
#+end_src

The following statement finds the tracks whose names end with a number.

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*[1-9]';
#+end_src

** Joining tables
- SQLite Inner Join ::

     query data from multiple tables using inner join clause.

- SQLite Left Join ::

     combine data from multiple tables using left join clause.

- SQLite Cross Join ::

     show you how to use the cross join clause to produce a cartesian product
     of result sets of the tables involved in the join.

- SQLite Self Join ::

     join a table to itself to create a result set that joins rows with other
     rows within the same table.

- SQLite Full Outer Join ::

     show you how to emulate the full outer join in the SQLite using left join
     and union clauses.

** Grouping data

*** SQLite =GROUP BY= Clause
- http://www.sqlitetutorial.net/sqlite-group-by/

- SQLite Group By ::

     combine a set of rows into groups based on specified criteria. The GROUP
     BY clause helps you summarize data for reporting purposes.


- *Summary* :: in this tutorial, you will learn how to use SQLite GROUP BY
               clause to make a set of summary rows from a set of rows.

**** Introduction to SQLite GROUP BY clause
#+cindex:@command{GROUP BY} clause
#+cindex:summary rows, @command{GROUP BY}
The =GROUP BY= clause is an optional clause of the =SELECT= statement.  The
=GROUP BY= clause a selected group of rows into summary rows by values of one
or more columns.

The =GROUP BY= clause returns one row for each group.  For each group, you can
apply an aggregate function such as =MIN=, =MAX=, =SUM=, =COUNT=, or =AVG= to
provide more information about each group.

The following statement illustrates the syntax of the SQLite GROUP BY clause.

#+begin_src sql
SELECT
    column_1,
    aggregate_function(column_2)
FROM
    table
GROUP BY
    column_1,
    column_2;
#+end_src

The =GROUP BY= clause comes after the =FROM= clause of the =SELECT= statement.
In case a statement contains a =WHERE= clause, the =GROUP BY= clause must come
after the =WHERE= clause.

Following the =GROUP BY= clause is a column or a list of comma-separated
columns used to specify the group.

**** SQLite =GROUP BY= examples

**** SQLite =HAVING=
- http://www.sqlitetutorial.net/sqlite-having/

- SQLite Having ::

                   specify the conditions to filter the groups summarized by
                   the =GROUP BY= clause.



- *Summary* :: in this tutorial, you will learn how to use SQLite HAVING clause
               to specify a filter condition for a group or an aggregate.

**** Introduction to SQLite =HAVING= clause
#+cindex:@command{HAVING} clause
#+cindex:search condition, @command{HAVING}
SQLite =HAVING= clause is an optional clause of the =SELECT= statement.  The
=HAVING= clause specifies a search condition for a group.

You often use the =HAVING= clause with the =GROUP BY= clause.  The =GROUP BY=
clause groups a set of rows into a set of summary rows or groups.  Then the
=HAVING= clause filters groups based on specified conditions.

If you use a =HAVING= clause without the =GROUP BY= clause, the =HAVING= clause
behaves like a =WHERE= clause.  Note that the =HAVING= clause is applied after
=GROUP BY= clause, while the =WHERE= clause is applied before.

The following illustrates the syntax of the =HAVING= clause:

#+begin_src sql
SELECT
 column_1,
 aggregate_function (column_2)
FROM
 table
GROUP BY
 column_1
HAVING
 search_condition;
#+end_src

SQLite evaluates the =search_condition= for each group as a Boolean expression.
It only includes a group in the final result set if the evaluation is =true=.

**** SQLite =HAVING= clause examples
We will use the =tracks= table in the sample database for demonstration.

To find the number of tracks for each album, you use =GROUP BY= clause as
follows:

#+begin_src sql
SELECT
 albumid,
 COUNT(trackid)
FROM
 tracks
GROUP BY
 albumid;
#+end_src

To find the numbers of tracks for the album with id 1, we add a =HAVING= clause
to the following statement:

#+begin_src sql
SELECT
 albumid,
 COUNT(trackid)
FROM
 tracks
GROUP BY
 albumid
HAVING albumid = 1;
#+end_src

We have referred to the =AlbumId= column in the =HAVING= clause.

To find albums that have the number of tracks between 18 and 20, we refer to
the aggregate function in the =HAVING= clause as the following statement:

#+begin_src sql
SELECT
 albumid,
 COUNT(trackid)
FROM
 tracks
GROUP BY
 albumid
HAVING count(albumid) BETWEEN 18 AND 20
ORDER BY albumid;
#+end_src

**** SQLite =HAVING= clause with =INNER JOIN= example

** Set operators
- SQLite Union ::

                  combine result sets of multiple queries into a single result
                  set.  We also discuss the differences between =UNION= and =UNION
                  ALL= clauses.

- SQLite Except ::

                   compare the result sets of two queries and returns distinct
                   rows from the left query that are not output by the right
                   query.

- SQLite Intersect ::

     compare the result sets of two queries and returns distinct rows that are
     output by both queries.

** Subquery
- SQLite Subquery ::

     introduce you to the SQLite subquery and correlated subquery.

- SQLite EXISTS ::

                   test for the existence of rows returned by a subquery.

** More querying techniques
- SQLite Case ::

                 add conditional logic to the query.

** Changing data
This section guides you how to update data in the table using insert, update,
and delete statements.

*** SQLite =INSERT=---inserting a single row into a table
- http://www.sqlitetutorial.net/sqlite-insert/

- SQLite Insert ::

                   insert rows into a table


- *Summary* :: in this tutorial, you will learn how to use SQLite =INSERT=
               statement to insert new rows into a table.

To insert data into a table, you use the =INSERT= statement.  SQLite provides
various forms of the =INSERT= statements that allow you to insert a single row,
multiple rows, and default values into a table.

In addition, you can insert a row into a table using data provided by a
=SELECT= statement.

**** SQLite INSERT --- inserting a single row into a table
#+cindex:@command{INSERT} statement
To insert a single row into a table, you use the following form of the =INSERT=
statement:

#+begin_src sql
INSERT INTO table1 (
 column1,
 column2 ,..)
VALUES
 (
 value1,
 value2 ,...);
#+end_src

Let’s examine the =INSERT= statement in more detail:

- First, specify a table to which you want to insert data after the =INSERT
  INTO= clause.

- Second, add a comma-separated list of columns.  This list is optional.

- Third, add a comma-separated list of values after the =VALUES= clause.  If
  you omit the column list, you have to specify values for all columns in the
  value list.  The number of values must be the same as the number of columns.


We will take the =artists= table in the sample database for the demonstration.

For example, to insert a new row into the =artists= table, you use the
following statement.

#+begin_src sql
INSERT INTO artists (name)
VALUES
 ('Bud Powell');
#+end_src

Because the =artistid= column is an auto-increment column, you can ignore it in
the statement.  SQLite takes the next number to insert into the =artistid=
column.

You can verify the insert operation using the following =SELECT= statement:

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists
ORDER BY
 artistid DESC
LIMIT 1;
#+end_src

As you see, we have a new row in the =artists= table.

**** SQLite =INSERT= --- Inserting multiple rows into a table
To insert multiple rows into a table, you use the following form of the
=INSERT= statement:

#+begin_src sql
INSERT INTO table1 (
 column1,
 column2 ,..)
VALUES
 (
 value1,
 value2 ,...),
 (
 value1,
 value2 ,...),
        ...
 (
 value1,
 value2 ,...);
#+end_src

Each values list following the =VALUES= clause is a row that you want to insert
into the table.  For example, to insert three new rows into the artists table,
you use the following statement:

#+begin_src sql
INSERT INTO artists (name)
VALUES
 ("Buddy Rich"),
 ("Candido"),
 ("Charlie Byrd");
#+end_src

SQLite issued a message: =Row Affected: 3=

You can verify the result using the following statement:

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists
ORDER BY
 artistid DESC
LIMIT 3;
#+end_src

**** SQLite =INSERT= --- Inserting default values
When you created a new table using =CREATE TABLE= statement, you defined
default values for columns, or a =NULL= value if a default value is not
specified.

#+cindex:@command{INSERT DEFAULT VALUES} statement
The third form of the =INSERT= statement is =INSERT DEFAULT VALUES=.  It
inserts a new row into a table using the default values or =NULL= values of the
column.

For example, to insert a new row into the artists table using =INSERT DEFAULT
VALUES=, you use the following statement:

: INSERT INTO artists DEFAULT VALUES;

To verify the insert, you use the following statement:

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists
ORDER BY
 artistid DESC;
#+end_src

The default value of the =artistid= column is the next integer in the sequence.

However, the =name= column does not have any default value, the =INSERT DEFAULT
VALUES= statement inserts a =NULL= value into the =name= column.

**** SQLite =INSERT= --- Inserting new rows with data provided by a =SELECT= statement
Suppose you want to backup the =artists= table, you create a new table named
=artists_backup= as follows:

#+begin_src sql
CREATE TABLE artists_backup(
 artistid INTEGER PRIMARY KEY AUTOINCREMENT,
 name NVARCHAR
);
#+end_src

To insert data into the =artists_backup= table with the data from the =artists=
table, you use the =INSERT INTO SELECT= statement as follows:

#+begin_src sql
INSERT INTO artists_backup SELECT
 artistid,
 name
FROM
 artists;
#+end_src

If you query data from the =artists_backup= table, you will see all data in the
=artists= table.

#+begin_src sql
SELECT
 *
FROM
 artists_backup;
#+end_src

*** SQLite =UPDATE=
- http://www.sqlitetutorial.net/sqlite-update/

- SQLite Update ::

      update existing rows in a table.


- *Summary* :: in this tutorial, you will learn how to use SQLite
               =UPDATE=statement to update data of existing rows in the table.

**** Introduction to SQLite =UPDATE= statement
#+cindex:@command{UPDATE} statement
To update existing data in a table, you use SQLite =UPDATE= statement.  The
following illustrates the syntax of the =UPDATE= statement:

#+begin_src sql
UPDATE table
SET column_1 = new_value_1,
    column_2 = new_value_2
WHERE
    search_condition 
ORDER column_or_expression
LIMIT row_count OFFSET offset;
#+end_src

First, you specify the table where you want to update after the =UPDATE=
clause.

Second, the =SET= clause allows you to update data in one or more columns
determined by a list of comma-separated assignments.  Each assignment specifies
a column name on the left side the assignment operator (=) and a literal value,
an expression, or data from a subquery on the right side of the assignment
operator.

Third, the =WHERE= clause specifies the rows that you want to update.  The
=WHERE= clause is an optional clause.  If you omit the =WHERE= clause, the
=UPDATE= statement updates data in all rows of the table.

Fourth, SQLite allows you to use the =ORDER BY= and =LIMIT= clauses in the
=UPDATE= statement.  The =LIMIT= clause specifies the number of rows to be
updated.

Notice that if use a negative value in the =LIMIT= clause, SQLite assumes that
there are no limit and updates all rows that meet the condition in the
preceding =WHERE= clause.

The =ORDER BY= clause goes with the =LIMIT= clause to control exactly which
rows to update.  Otherwise, you will never know which row will actually be
updated.  Because without the =ORDER BY= clause, the order of the result set is
unspecified.

**** SQLite =UPDATE= statement examples
We will use the =employees= table in the sample database for the demonstration
of the =UPDATE= statement.

The following =SELECT= statement gets partial data from the =employees= table:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 title,
 email
FROM
 employees;
#+end_src

***** Update one column example
Suppose, Jane got married and she wanted to change her last name to her
husband’s last name i.e., Smith.  In this case, you can update Jane’s last name
using the following statement:

#+begin_src sql
UPDATE employees
SET lastname = 'Smith'
WHERE
 employeeid = 3;
#+end_src

The expression in the =WHERE= clause makes sure that we update Jane’s record
only.  We set the =lastname= column to a literal string =Smith=.

To verify the =UPDATE=, you use the following statement:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 title,
 email
FROM
 employees
WHERE
 employeeid = 3;
#+end_src

***** Update multiple columns example
Suppose Park Margaret locates in Toronto and you want to change his address,
city, and state information.  You can use the =UPDATE= statement to update
multiple columns as follows:

#+begin_src sql
UPDATE employees
SET city = 'Toronto',
    state = 'ON',
    postalcode = 'M5P 2N7'
WHERE
    employeeid = 4;
#+end_src

To verify the =UPDATE=, you use the following statement:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 state,
 city,
 PostalCode
FROM
 employees
WHERE
 employeeid = 4;
#+end_src

***** Update with =ORDER BY= and =LIMIT= clauses example
Note that you need to build SQLite with =SQLITE_ENABLE_UPDATE_DELETE_LIMIT=
option in order to perform =UPDATE= statement with optional =ORDER BY= and
=LIMIT= clauses.

Let’s check the email addresses of employees in the employees table:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 email
FROM
 employees;
#+end_src

To update one row in the employees table, you use =LIMIT 1= clause.  To make
sure that you update the first row of employees sorted by the first name, you
add the =ORDER BY firstname= clause.

So the following statement updates email of Andrew Adams:

#+begin_src sql
UPDATE employees
SET email = lower(
 firstname || "." || lastname || "@chinookcorp.com"
)
ORDER BY
 firstname
LIMIT 1;
#+end_src

The new email is the combination of the first name, dot (=.=), last name and the
suffix =@chinookcorp.com=

The =LOWER= function converts the email to lower case.

***** Update all rows example
To update all rows in the =employees= table, you skip the =WHERE= clause.  For
example, to standardize the email addresses of all employees, you use the
following statement:

#+begin_src sql
UPDATE employees
SET email = lower(
 firstname || "." || lastname || "@chinookcorp.com"
);
#+end_src

*** SQLite =DELETE=
- http://www.sqlitetutorial.net/sqlite-delete/

- SQLite Delete ::

                   delete rows from a table.


- *Summary* :: this tutorial shows you how to use SQLite DELETE statement to
               remove rows from a table.

**** Introduction to SQLite =DELETE= statement
#+cindex:@command{DELETE} statement
You have learned how to insert a new row into a table and update existing data
of a table.  Sometimes, you need to remove rows from a table.  In this case, you
use SQLite =DELETE= statement.

The SQLite =DELETE= statement allows you to delete one row, multiple rows, and
all rows in a table.  The syntax of the SQLite =DELETE= statement is as
follows:

#+begin_src sql
DELETE
FROM
 table
WHERE
 search_condition;
#+end_src

In this syntax:

- First, specify the table where you want to remove rows after the =DELETE FROM=
  clause.

- Second, add a search condition in the =WHERE= clause to identify which row to
  remove.  The =WHERE= clause is an optional part of the =DELETE= statement.
  If you omit the =WHERE= clause, all rows in the table will be removed.


SQLite also provides an extension to the =DELETE= statement by adding =ORDER
BY= and =LIMIT= clauses.  If you compile SQLite with the
=SQLITE_ENABLE_UPDATE_DELETE_LIMIT= compile-time option, you can use the =ORDER
BY= and =LIMIT= clause in the =DELETE= statement like the following form:

#+begin_src sql
DELETE
FROM 
   table
WHERE search_condition
ORDER BY criteria
LIMIT row_count OFFSET offset;
#+end_src

The =ORDER BY= clause sorts the rows filtered by the preceding
=search_condition= in the =WHERE= clause and the =LIMIT= clause specifies the
number of rows that will be deleted.

#+cindex:truncate optimization
Notice that when you use the =DELETE= statement without a =WHERE= clause on a
table that has no triggers, SQLite will delete all rows in one shot instead of
visiting and deleting each row.  This feature is known as =truncate
optimization=.

**** SQLite =DELETE= statement examples
We will use the =artists_backup= table that we created in the how to insert
rows into table tutorial.

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists_backup;
#+end_src

We have 280 rows in the =artists_backup= table.

To remove an artist with =id 1=, you use the following statement:

#+begin_src sql
DELETE
FROM
 artists_backup
WHERE
 artistid = 1;
#+end_src

Because we use =artistid= to identify the artist, the statement removed exactly
1 row.

Suppose we want to remove artists whose names contain the literal string
=Santana=:

#+begin_src sql
DELETE
FROM
 artists_backup
WHERE
 name LIKE '%Santana%';
#+end_src

There are 9 rows whose values in the name column contain the =Santana= literal
string; therefore, these 9 rows were removed.

To remove all rows in the =artists_backup= table, you just need to omit the
=WHERE= clause as the following statement:

#+begin_src sql
DELETE
FROM
 artists_backup;
#+end_src

*** SQLite =REPLACE=
- http://www.sqlitetutorial.net/sqlite-replace-function/

- SQLite Replace ::

                    insert a new row or replace the existing row in a table.


#+cindex:@command{REPLACE()} function
- *Summary* :: in this tutorial, you will learn how to use SQLite ~REPLACE()~
               function to replace all occurrences of a specified string with
               another string.

**** Introduction to SQLite ~REPLACE()~ function
The SQLite ~REPLACE()~ function is a string function that allows you to replace
all occurrences of a specified string with another string.

The following shows the syntax of the ~REPLACE()~ function:

: REPLACE(string,pattern,replacement)

In this syntax:

- =string= is the string that you want to perform the replacement.

- =pattern= is the substring to be found in the original string

- =replacement= is the replacement string.


The ~REPLACE()~ function is useful for updating character data in a table e.g.,
update the dead links and typos.

**** SQLite ~REPLACE()~ function examples
Let’s take some examples of using the ~REPLACE()~ function.

***** SQLite ~REPLACE()~ function simple example
The following example replaces the string 'A' in the string 'AA B CC AAA' with
the new string 'Z':

#+begin_src sql
SELECT
    REPLACE('AA B CC AAA','A','Z');
#+end_src

The following statement uses the ~REPLACE()~ function to replace the string
'This' in the string 'This is a cat' with the new string 'That':

#+begin_src sql
SELECT
    REPLACE('This is a cat','This','That');
#+end_src

***** SQLite ~REPLACE()~ string in a table example
First, create a new table named =contacts= that consists of four columns:
=contact_id=, =first_name=, =last_name=, and =phone=:

#+begin_src sql
CREATE TABLE contacts (
    contact_id INT PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    phone TEXT NOT NULL
);
#+end_src

Next, insert into the =contacts= table some rows:

#+begin_src sql
INSERT INTO contacts(first_name, last_name, phone)
VALUES('John','Doe','410-555-0168');
INSERT INTO contacts(first_name, last_name, phone)
VALUES('Lily','Bush','410-444-9862');
#+end_src

Then, query data from the =contacts= table:

#+begin_src sql
SELECT 
    first_name, 
    last_name,
    phone
FROM 
    contacts;
#+end_src

After that, update the phone area code from local (410) to international
one(+1-410):

#+begin_src sql
UPDATE
    contacts
SET
    phone = REPLACE(phone,'410','+1-410');
#+end_src

Finally, query data from the contacts table to verify if the phone has been
updated:

#+begin_src sql
SELECT 
    first_name, 
    last_name,
    phone
FROM 
    contacts;
#+end_src

** Transactions
- http://www.sqlitetutorial.net/sqlite-transaction/

- SQLite Transaction ::

     show you how to handle transactions.


- *Summary* :: in this tutorial, we will show you how to use the SQLite
               transaction to ensure the integrity and reliability of the data.

*** SQlite & ACID
#+cindex:ACID
#+cindex:transactional database
SQlite is a transactional database, ensuring that all /changes/ and /queries/
are (ACID):
- atomic,
- consistent,
- isolated, and
- durable


#+cindex:transactions
SQLite guarantees all the transactions are ACID compliant even if the
transaction is interrupted by program crash, operation system dump, or power
failure to the computer.


- Atomic :: a transaction should be atomic. It means that a change cannot be
            broken down into smaller ones. When you commit a transaction,
            either the entire transaction is applied or not applied. It cannot
            be only part of the transaction to be applied.

- Consistent :: a transaction must ensure to change the database from one valid
                state to another. When a transaction starts and executes
                statements to modify data, the database becomes
                inconsistent. However, when the transaction is committed or
                rolled back, it is important that the transaction must keep the
                database consistent.

- Isolation :: a pending transaction must be isolated from other clients. When
               a client starts a transaction and executes the INSERT or UPDATE
               statement to change the data, those changes are only visible to
               the client, not other clients. On the other hand, the changes
               committed by other clients after the transaction started should
               not be visible to this client.

- Durable :: if a transaction is successfully committed, the changes must be
             permanent in the database regardless of the condition such as
             power failure or program crash. On the contrary, if the program
             crashes before the transaction is committed, the change should not
             be present.


**** SQLite transaction statements
#+cindex:auto-commit mode
By default, SQLite is in auto-commit mode.  It means that for each command,
SQLite starts, processes, and commits the transaction automatically.

#+cindex:transaction, start
To start a transaction explicitly, you use the following steps:

#+cindex:@command{BEGIN TRANSACTION} command
First, open a transaction by issuing the =BEGIN TRANSACTION= command.

: BEGIN TRANSACTION;

#+cindex:transaction, open
#+cindex:open transaction
After executing the =BEGIN TRANSACTION= statement, the transaction is open until
it is explicitly committed or rolled back.

Second, issue the SQL commands to select or update data in the database.  Note
that the change is only visible to the client.

#+cindex:@command{COMMIT} statement
#+cindex:@command{COMMIT TRANSACTION} statement
Third, to commit the changes to the database, you use the =COMMIT= or =COMMIT
TRANSACTION= statement.

: COMMIT;

#+cindex:@command{ROLLBACK} statement
For any reason, if you do not want to commit the transaction, you can roll it
back using the =ROLLBACK= or =ROLLBACK TRANSACTION= statement.

: ROLLBACK;

**** SQLite transaction example
We will create two new tables: =accounts= and =account_changes= for the
demonstration.

The =accounts table stores data about the account numbers and their balances.
The =account_changes= table stores changes of the accounts.

First, the following =CREATE TABLE= statements create the new tables.

#+begin_src sql
CREATE TABLE IF NOT EXISTS accounts (
    account_no INTEGER PRIMARY KEY
                       NOT NULL,
    balance    DECIMAL NOT NULL
                       DEFAULT 0
);

CREATE TABLE IF NOT EXISTS account_changes(
    account_no integer not null,
    flag text not null,
    amount decimal not null,
    changed_at text not null
);
#+end_src

Second, insert some sample data into the =accounts= table.

#+begin_src sql
INSERT INTO accounts (
                         account_no,
                         balance
                     )
                     VALUES (
                         100,
                         20100
                     );

INSERT INTO accounts (
                         account_no,
                         balance
                     )
                     VALUES (
                         200,
                         10100
                     );
#+end_src

#+begin_src sql
SELECT *
  FROM accounts;
#+end_src

Third, transfer 1000 from the account 100 to the account 200, and write the
changes to the =account_changes= table; perform all of the activities within the
same transaction.

#+begin_src sql
BEGIN TRANSACTION;

UPDATE accounts
   SET balance = balance - 1000
 WHERE account_no = 100;

UPDATE accounts
   SET balance = balance + 1000
 WHERE account_no = 200;

INSERT INTO account_changes(account_no,flag,amount,changed_at)
values(100,'-',1000,datetime('now'));

INSERT INTO account_changes(account_no,flag,amount,changed_at)
values(200,'+',1000,datetime('now'));

COMMIT;
#+end_src

** Data Definitions
In this section, we show you how to create database objects such as tables,
views, and indexes using the SQL data definition language.

*** SQLite Data Types
- http://www.sqlitetutorial.net/sqlite-data-types/

- SQLite Data Types ::

     introduce you to the SQLite dynamic types system and its important
     concepts: storage classes, manifest typing, and type affinity.

- Summary :: in this tutorial, you will learn about the SQLite data types
             system and related concepts such as storage classes, manifest
             typing, and type affinity.

**** Introduction to SQLite data types
#+cindex:data types
#+cindex:static typing
#+cindex:MySQL
#+cindex:PostgreSQL
If you come from other database systems such as MySQL and PostgreSQL, you
notice that they use *static typing*.  This means that when you declare a column
with a specific data type, that column can store only data with the declared
data type.

#+cindex:dynamic typing
Different from other database systems, SQLite uses a *dynamic type* system.
For example, /the value stored in a column determines its data type/, not the
column’s data type.

In addition, you don’t have to declare a specific data type for a column when
you create a table.  Even in the case when you declare a column with the
=integer= data type, you can store any kind of data types such as text and
=BLOB=, and SQLite will not complain.

{{{heading(Storage Classes vs. Data Types)}}}

#+cindex:storage classes
#+cindex:primitive data types
SQLite provides five primitive data types which referred to as /storage
classes/.

The concept of /storage classes/ describes the format SQLite uses to store data
on disk.  A storage class is more general than a data type e.g., =INTEGER=
storage class includes 6 different types of integers.  In most cases, you can
use storage classes and data type interchangeably.

The following table illustrates 5 storage classes in SQLite:

| Storage Class | Meaning                                                                                                                           |
|---------------+-----------------------------------------------------------------------------------------------------------------------------------|
| NULL          | NULL values mean missing information or unknown.                                                                                  |
| INTEGER       | Integer values are whole numbers (either positive or negative). An integer can have variable sizes such as 1, 2,3, 4, or 8 bytes. |
| REAL          | Real values are real numbers with decimal values that use 8-byte floats.                                                          |
| TEXT          | TEXT is used to store character data. The maximum length of TEXT is unlimited. SQLite supports various character encodings.       |
| BLOB          | BLOB stands for a binary large object that can be used to store any kind of data. The maximum size of BLOBs is unlimited.         |
|---------------+-----------------------------------------------------------------------------------------------------------------------------------|

Based on the format of a value, SQLite determines its data type based on the
following rules:

- If a literal has no enclosing quotes and decimal point or exponent, SQLite
  assigns the INTEGER storage class.

- If a literal is enclosed by single or double quotes, SQLite assigns the TEXT
  storage class.

- If a literal is NULL without quotes, it assigns the NULL storage class.

- If a literal has the X’ABCD’ or x ‘abcd’, SQLite assigns the BLOB storage
  class.


{{{heading(No DATE or TIME Storage Classes)}}}

SQLite does not support built-in date and time storage classes. However, you
can use the TEXT, INT, or REAL to store date and time values.  For detailed
information on how to handle date and time values, check it out the [[http://www.sqlitetutorial.net/sqlite-date/][SQLite date
and time tutorial]].

{{{heading(TYPEOF() Function)}}}

SQLites provides the ~typeof()~ function that allows you to check the storage
class of a value based on its format.  See the following statement:

#+begin_src sql
SELECT
 typeof(100),
 typeof(10.0),
 typeof('100'),
 typeof(x'1000'),
 typeof(NULL);
#+end_src


{{{heading(Mixed Data Types)}}}


A single column in SQLite can store mixed data types.  See the following
example.

First, we create a new table named =test_datatypes= for testing.

#+begin_src sql
CREATE TABLE test_datatypes (
 id INTEGER PRIMARY KEY,
 val
);
#+end_src

Second, we insert data into the =test_datatypes= table.

#+begin_src sql
INSERT INTO test_datatypes (val)
VALUES
 (1),
 (2),
 (10.1),
 (20.5),
 ('A'),
 ('B'),
 (NULL),
 (x'0010'),
 (x'0011');
#+end_src

Third, we use the ~typeof()~ function to get the data type of each value stored
in the =val= column.

#+begin_src sql
SELECT
 id,
 val,
 typeof(val)
FROM
 test_datatypes;
#+end_src

{{{subheading(Sorting Columns of Mixed Data Types)}}}

You may ask how SQLite sorts data in a column with different storage classes
like =val= column above.

To resolve this, SQLite provides a set of rules when it comes to sorting.

- =NULL= storage class has the lowest value.  It less than any other value.
  Between =NULL= values, there is no order.

- The next higher storage classes are =INTEGER= and =REAL=.  SQLite compares
  =INTEGER= and =REAL= numerically.

- The next higher storage class is =TEXT=.  SQLite uses the collation of =TEXT=
  values when it compares the =TEXT= values.

- The highest storage class is the =BLOB=.  SQLite uses C ~memcmp()~ function
  to compare =BLOB= values.


When you use the =ORDER BY= clause to sort the data in a column with different
storage classes, SQLite performs the following steps:

- First, group values based on storage class: =NULL=, =INTEGER=, and =REAL=,
  =TEXT=, and =BLOB=.

- Second, sort the values in each group.

**** SQLite Manifest Typing and Type Affinity
Other important concepts related to SQLite data types are /manifest typing/ and
/type affinity/.

#+cindex:manifest typing
Manifest typing means two things:

- First, a column can have an associated data type.
- Second, the data type of the column can be inferred from values it stores.


#+cindex:type affinity
Type affinity of a column is the recommended type of data that a column stores.
It is only recommended, not required, and so therefore a column can store any
type of data.

*** SQLite =CREATE TABLE=
- http://www.sqlitetutorial.net/sqlite-create-table/

- SQLite Create Table ::

     #+cindex:create new table
     shows you how to create a new table in the database.


- *Summary* ::

               In this tutorial, you will learn how to create new tables using
               SQLite =CREATE TABLE= statement using various options.

**** Introduction to SQLite =CREATE TABLE= Statement
#+cindex:@command{CREATE TABLE} statement
To create a new table in SQLite, you use =CREATE TABLE= statement using the
following syntax:

#+begin_src sql
  CREATE TABLE [IF NOT EXISTS] [schema_name].table_name (
     column_1 data_type PRIMARY KEY,
     column_2 data_type NOT NULL,
     column_3 data_type DEFAULT 0,
     table_constraint
  ) [WITHOUT ROWID];
#+end_src

{{{heading(Attributes)}}}

#+cindex:attributes, @command{CREATE TABLE} statement
To create a table you specify the following /attributes/:

- name ::

          #+cindex:name attribute
          The name of the table.  You cannot create a table that already exists
          in the current database.  To avoid this, you can use an optional
          clause =IF NOT EXISTS= to instruct SQLite to create a new table if
          the table does not exist; otherwise, just ignore the statement.

- database ::

              #+cindex:database attribute
              The database to which table belongs.  It may be the main database,
              temp database or any attached database.

- column names, data type, [constraint] ::

     #+cindex:constraints
     The name of each column, its datatype, and an optional constraint.  SQLite
     supports the following constraints:

  - PRIMARY KEY: a column or group of columns that uniquely identifies a row in
    the table
  - UNIQUE,
  - NOT NULL, and
  - CHECK constraints.

- =WITHOUT ROWID= ::

     By default, a row in a table has an implicit column, which can be referred
     to as the =rowid=, =oid= or =_rowid_= column.  The =rowid= column stores a
     64-bit signed integer key that uniquely identifies the row inside the
     table.  If you don’t want SQLite to create the =rowid= column, you can
     specify the =WITHOUT ROWID= option in the =CREATE TABLE= statement.

**** SQLite =CREATE TABLE= Examples
Suppose you have to manage contacts using SQLite.

Each contact has the following information:
- first name
- last name
- email
- phone


Both email and phone must be unique.  In addition, each contact belongs to one
or many groups, and each group has zero or multiple contacts.  With these
requirements, you come up with three tables:

- The =contacts= table stores contact information.

- The =groups= table stores group information.

- The =contact_groups= table stores the relationship between contacts and
  groups.


The following database diagram illustrates these tables:

[[file:figs/SQLite-CREATE-TABLE-example.jpg]]

{{{heading(Contacts Table)}}}

The following statement creates the =contacts= table.

#+begin_src sql
CREATE TABLE contacts (
 contact_id INTEGER PRIMARY KEY,
 first_name TEXT NOT NULL,
 last_name TEXT NOT NULL,
 email text NOT NULL UNIQUE,
 phone text NOT NULL UNIQUE
);
#+end_src

#+cindex:@command{COLUMN PRIMARY KEY} constraint
The =contact_id= is the primary key of the =contacts= table.  Because the
primary key consists of one column, you can use =column= constraint to make the
=contact_id= column as the primary key.

#+cindex:@command{NOT NULL} constraint
The =first_name= and =last_name= columns have =TEXT= storage class and those
columns are =NOT NULL=.  It means you must provide values when you insert or
update rows in the =contacts= table.

#+cindex:@command{UNIQUE} constraint
The email and phone are unique therefore you use the =UNIQUE= constraint for
each column.

{{{heading(Groups Table)}}}

The following statement creates the =groups= table:

#+begin_src sql
CREATE TABLE groups (
 group_id integer PRIMARY KEY,
 name text NOT NULL
);
#+end_src

{{{heading(Contacts Group Table)}}}

#+begin_src sql
CREATE TABLE contact_groups (
 contact_id integer,
 group_id integer,
 PRIMARY KEY (contact_id, group_id),
 FOREIGN KEY (contact_id) REFERENCES contacts (contact_id) 
 ON DELETE CASCADE ON UPDATE NO ACTION,
 FOREIGN KEY (group_id) REFERENCES groups (group_id) 
 ON DELETE CASCADE ON UPDATE NO ACTION
);
#+end_src

#+cindex:@command{PRIMARY KEY} table constraint
The =contact_groups= table has a primary key that consists of two columns:
=contact_id=, =group_id=.  To add the primary key constraint you use =PRIMARY
KEY= table constraint:

: PRIMARY KEY (contact_id, group_id)

#+cindex:foreign key constraint
In addition, the =contact_id= and =group_id= are the foreign keys.  Therefore,
you use =FOREIGN KEY= constraint to define the foreign key for each column.

#+begin_src sql
FOREIGN KEY (contact_id) REFERENCES contacts (contact_id) 
 ON DELETE CASCADE ON UPDATE NO ACTION
#+end_src

#+begin_src sql
FOREIGN KEY (group_id) REFERENCES groups (group_id) 
 ON DELETE CASCADE ON UPDATE NO ACTION
#+end_src

Note that we will discuss this in the =FOREIGN KEY= constraint tutorial.

*** SQLite =PRIMARY KEY=
- http://www.sqlitetutorial.net/sqlite-primary-key/

- SQLite Primary Key ::

     show you how to define the primary key for a table.

- Summary ::

             #+cindex:@code{PRIMARY KEY} constraint
             in this tutorial, you will learn how to use SQLite =PRIMARY KEY=
             constraint to define the primary key for a table.

**** Introduction to SQLite Primary Key
#+cindex:primary key
A primary key is a column or group of columns used to identify the uniqueness
of rows in a table.  Each table has one and only one primary key.

SQLite allows you to define primary key in two ways:

#+cindex:@code{PRIMARY KEY} column constraint
1. First, if the primary key consists of one column, you use the =PRIMARY KEY=
   column constraint to define the primary key as follows:

   #+begin_example
   CREATE TABLE table_name(
   column_1 NOT NULL INTEGER PRIMARY KEY,
   ...
   );
   #+end_example

   #+cindex:@code{PRIMARY KEY} table constraint
2. Second, in case primary key consists of more than 2 columns, you use the
   =PRIMARY KEY= table constraint to define the primary as the following
   statement.

   #+begin_example
   CREATE TABLE table_name(
      column_1 NOT NULL INTEGER,
      column_2 NOT NULL INTEGER,
      ...
      PRIMARY KEY(column_1,column_2,...)
   );
   #+end_example

#+cindex:@code{NOT NULL} constraint, implicit
In the SQL-standard, the primary key column must not contain =NULL= values.  It
means that the primary key column has an implicit =NOT NULL= constraint.
However, to make the current version of SQLite compatible with the earlier
versions, SQLite allows the primary key column to contain =NULL= values.

**** SQLite primary key and rowid table
#+cindex:@code{WITHOUT ROWID} option
#+cindex:@code{rowid} column
#+cindex:@code{rowid table}
When you create a table without specifying the =WITHOUT ROWID= option, SQLite
adds an implicit column called =rowid= that stores 64-bit signed integer.  The
=rowid= column is a key that uniquely identifies the row within its table.  A
table that has the =rowid= column is called a =rowid table=.

#+cindex:alias for @code{rowid} column
If a table has a primary key that consists of one column, and that column is
defined as =INTEGER=, exactly =INTEGER= in any case, such as =INTEGER=,
=integer=, etc., then this primary key column becomes an alias for the =rowid=
column.  Notice that if you assign another integer type such as: =BIGINT=,
=UNSIGNED INT=, etc., to the primary key column, this column is not the alias
for the =rowid= column.

#+cindex:B-Tree
Because the =rowid table= stores data as a B-Tree, querying and sorting data
using =rowid= are very fast.  It is faster than using a primary key that is not
an alias of the =rowid=.

Another important note is that if you declare a column with the =INTEGER= type
and =PRIMARY KEY DESC= clause, it does not become an alias for the =rowid=
column.

**** Creating SQLite primary key examples
The following statement creates a table named =countries= with the =country_id=
column as the primary key.

#+begin_src sql
CREATE TABLE countries (
 country_id INTEGER PRIMARY KEY,
 name text NOT NULL
);
#+end_src

Because the primary key of the =countries= table consists of one column, we
define the primary key using =PRIMARY KEY= column constraint.

You can use the =PRIMARY KEY= table constraint to define the primary key that
consists of one column.  It works just fine as the following statement:

#+begin_src sql
CREATE TABLE languages (
 language_id integer,
 name text NOT NULL,
 PRIMARY KEY (language_id)
);
#+end_src

However, with the table whose primary key consists of more than one column, you
must use =PRIMARY KEY= table constraint to define the primary key.

The following statement creates the =country_languages= table whose primary key
consists of two columns.

#+begin_src sql
CREATE TABLE country_languages (
 country_id integer NOT NULL,
 language_id integer NOT NULL,
 PRIMARY KEY (country_id, language_id),
 FOREIGN KEY (country_id) REFERENCES countries (country_id) 
            ON DELETE CASCADE ON UPDATE NO ACTION,
 FOREIGN KEY (language_id) REFERENCES languages (language_id) 
            ON DELETE CASCADE ON UPDATE NO ACTION
);
#+end_src

**** Adding SQLite primary key example
Unlike other database systems e.g., MySQL, PostgreSQL, etc., you cannot use the
=ALTER TABLE= statement to add a primary key to an existing table.

To work around this, you need to:

1. First, set the foreign key check off.
2. Next, rename the table to another table name (=old_table=)
3. Then, create a new table (table) with the exact structure of the table you
   have been renamed.
4. After that, copy data from the =old_table= to the table.
5. Finally, turn on the foreign key check on


See the following statements:

#+begin_src sql
PRAGMA foreign_keys=off;

BEGIN TRANSACTION;

ALTER TABLE table RENAME TO old_table;

CREATE TABLE table ( ... );

INSERT INTO table SELECT * FROM old_table;

COMMIT;

PRAGMA foreign_keys=on;
#+end_src

**** SQLite AUTOINCREMENT---Why You Should Avoid Using It
Whenever you create a table without specifying the =WITHOUT ROWID= option, you
get an implicit auto increment column called =rowid=.  SQLite automatically
creates an implicit column named =rowid= and automatically assigns an integer
value whenever you insert a new row.

#+cindex:@code{rowid}
#+cindex:@code{_rowid_}
#+cindex:@code{oid}
You can refer to the =rowid= column using its two alias such as =_rowid_= or
=oid=.

If you create a table that has an =INTEGER PRIMARY KEY= column, this column
points to the =rowid= column.

How does SQLite assign an integer value to the =rowid= column?  If you don’t
specify the =rowid= value or you use a =NULL= value when you insert a new row,
SQLite assigns an integer that is one larger than the largest =rowid= in the
table.  In case you have never inserted any row, the =rowid= value is 1.  The
maximum value of =rowid= column is 9223372036854775807.  If you reach this
value and insert a new row, SQLite will find an unused integer and use it.  If
SQLite could not find one, it issues an =SQLITE FULL= error.

{{{heading(SQLite AUTOINCREMENT attribute)}}}

SQLite recommends that you should not use =AUTOINCREMENT= attribute because:

#+begin_quote
The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O
overhead and should be avoided if not strictly needed.  It is usually not
needed.
#+end_quote

In addition, the way SQLite assigns a value for the =AUTOINCREMENT= column is
slightly different from the way it does for the =rowid= column.

*** SQLite =FOREIGN KEY= Constraint

*** SQLite =NOT NULL= Constraint
- http://www.sqlitetutorial.net/sqlite-not-null-constraint/

- SQLite NOT NULL constraint ::

     ensure values in a column are not NULL.

**** Introduction to SQLite =NOT NULL= Constraint
#+cindex:@code{NOT NULL} constraint
When you create a table, you can specify whether a column accepts =NULL= values
or not.  By default, all columns in a table accept =NULL= values unless you
explicitly use the =NOT NULL= constraint.

To define a =NOT NULL= constraint for a column, you use the following syntax:

#+begin_src sql
CREATE TABLE table_name (
    ...,
    column_name type_name NOT NULL,
    ...
);
#+end_src

Unlike other constraints such as =PRIMARY KEY= and =CHECK=, you can only define
=NOT NULL= constraints at the column level, not the table level.

Based on the SQL standard, =PRIMARY KEY= should always imply =NOT NULL=.
However, SQLite allows =NULL= values in most =PRIMARY KEY= columns except that
a column is =INTEGER PRIMARY KEY= column or the table is a =WITHOUT ROWID=
table or the column is defined as a =NOT NULL= column.  This is due to a bug in
some early versions.  If this bug is fixed to conform with the SQL standard,
then it might break the legacy systems.  Therefore, it has been decided to
allow =NULL= values in most =PRIMARY KEY= columns.

#+cindex:constraint violation
Once a =NOT NULL= constraint is attached to a column, any attempt to set the
column value to =NULL= such as inserting or updating will cause a constraint
violation.

*** SQLite =UNIQUE= Constraint
- http://www.sqlitetutorial.net/sqlite-unique-constraint/

- SQLite UNIQUE constraint ::

     ensure values in a column or a group of columns are unique.

**** Introduction to SQLite =UNIQUE= Constraint
A =UNIQUE= constraint ensures all values in a column or a group of columns are
distinct from one another or unique.  To define a =UNIQUE= constraint, you use
the =UNIQUE= keyword followed by one or more columns.  You can define a
=UNIQUE= constraint at the column or the table level.  Only at the table level,
you can define a =UNIQUE= constraint across multiple columns.

The following shows how to define a =UNIQUE= constraint for a column at the
column level:

#+begin_src sql
CREATE TABLE table_name(
    ...,
    column_name type UNIQUE,
    ...
);
#+end_src

Or at the table level:

#+begin_src sql
CREATE TABLE table_name(
    ...,
    UNIQUE(column_name)
);
#+end_src

The following illustrates how to define a =UNIQUE= constraint for multiple
columns:

#+begin_src sql
CREATE TABLE table_name(
    ...,
    UNIQUE(column_name1,column_name2,...)
);
#+end_src

Once a =UNIQUE= constraint is defined, if you attempt to insert or update a
value that already exists in the column, SQLite will issue an error and abort
the operation.

{{{heading(UNIQUE Constraint and NULL Values)}}}

SQLite treats all =NULL= values as different; therefore, a column with a
=UNIQUE= constraint can have multiple =NULL= values.

*** SQLite =CHECK= Constraint
- http://www.sqlitetutorial.net/sqlite-check-constraint/

- SQLite CHECK constraint ::

     ensure the values in a column meet a specified condition defined by an
     expression.

**** Introduction to SQLite =CHECK= Constraint
#+cindex:@code{CHECK} constraint
SQLite =CHECK= constraint allows you to define expressions to test values
whenever they are inserted into or updated within a column.  If the values do
not meet the criteria defined by the expression, SQLite will issue a constraint
violation and abort the statement.

The =CHECK= constraint allow you to define additional data integrity checks
beyond =UNIQUE= or =NOT NULL= to suit your specific application.  You can
define a =CHECK= constraint at the column level or the table level.  The
following statement shows how to define a =CHECK= constraint at the column
level:

#+begin_src sql
CREATE TABLE table_name(
    ...,
    column_name data_type CHECK(expression),
    ...
);
#+end_src

and the following statement illustrates how to define a =CHECK= constraint at the
table level:

#+begin_src sql
CREATE TABLE table_name(
    ...,
    CHECK(expression)
);
#+end_src

In this syntax, whenever a row is inserted into a table or an existing row is
updated, the expression associated with each CHECK constraint is evaluated and
returned a numeric value 0 or 1.  If the result is zero, then a constraint
violation has occurred.  If the result is a non-zero value or =NULL=, it means
no constraint violation occurred.

Note that the expression of a =CHECK= constraint cannot contain a subquery.

**** SQLite =CHECK= Constraint Examples

{{{heading(SQLite CHECK constraint at the column level example)}}}

The following statement creates a new table named contacts:

#+begin_src sql
CREATE TABLE contacts (
    contact_id INTEGER PRIMARY KEY,
    first_name TEXT    NOT NULL,
    last_name  TEXT    NOT NULL,
    email      TEXT,
    phone      TEXT    NOT NULL
                    CHECK (length(phone) >= 10) 
);
#+end_src

If you attempt to execute the following statement, you will get a constraint
violation error:

#+begin_src sql
INSERT INTO contacts(first_name, last_name, phone)
VALUES('John','Doe','408123456');
#+end_src

Here is the error message:

#+begin_src sql
Error while executing SQL query on database 'chinook': NOT NULL
constraint failed: contacts.email
#+end_src

The reason was that the phone number that you attempted to insert just have 9
characters.

{{{heading(SQLite CHECK constraints at the table level example)}}}

The following statement creates a new table named products:

#+begin_src sql
CREATE TABLE products (
    product_id   INTEGER         PRIMARY KEY,
    product_name TEXT            NOT NULL,
    list_price   DECIMAL (10, 2) NOT NULL,
    discount     DECIMAL (10, 2) NOT NULL
                                DEFAULT 0,
    CHECK (list_price >= discount AND 
        discount >= 0 AND 
        list_price >= 0) 
);
#+end_src

In this example, the =CHECK= constraint is defined at the table level.  The
statement below violates the =CHECK= constraint because the discount is higher
than the list price.

#+begin_src sql
INSERT INTO products(product_name, list_price, discount)
VALUES('New Product',900,1000);
#+end_src

The following statement also violates the CHECK constraint because the discount
is negative:

#+begin_src sql
INSERT INTO products(product_name, list_price, discount)
VALUES('New XFactor',1000,-10);
#+end_src

**** Adding =CHECK= Constraints To An Existing Table
As of version 3.25.2, SQLite does not support adding a =CHECK= constraint to an
existing table.  However, you can follow these steps:

1. First, create a new table which is the same as the table that you want to
   add a =CHECK= constraint.  The structure of the new table should also have
   =CHECK= constraint definitions:

   #+begin_src sql
   CREATE TABLE new_table (
       [...],
       CHECK ([...])
   );
   #+end_src

   To get the structure of the old table, you can use the ~.schema~ command.
   Check it out the [[http://www.sqlitetutorial.net/sqlite-describe-table/][SQLite =DESCRIBE= table]] tutorial for more information.

2. Second, copy data from the old table to the new table.

   : INSERT INTO new_table SELECT * FROM old_table;

3. Third, drop the old table:

   : DROP TABLE old_table;

4. Fourth, rename the new table to the old one:

   : ALTER TABLE new_table RENAME TO old_table;


You should execute all of these steps within a transaction.  Here is the summary
script for doing so:

#+begin_src sql
BEGIN;
-- create a new table 
CREATE TABLE new_table (
    [...],
    CHECK ([...])
);
-- copy data from old table to the new one
INSERT INTO new_table SELECT * FROM old_table;

-- drop the old table
DROP TABLE old_table;

-- rename new table to the old one
ALTER TABLE new_table RENAME TO old_table;

-- commit changes
COMMIT;
#+end_src

*** SQLite =ALTER TABLE= Statement
- http://www.sqlitetutorial.net/sqlite-alter-table/

- SQLite Alter Table ::

     show you how to use modify the structure of an existing table


#+cindex:@code{ALTER TABLE} statement
Unlike SQL-standard and other database management systems, SQLite supports a
very limited functionality of the =ALTER TABLE= statement.

With SQLite ALTER TABLE statement, you can perform two actions:

1. Rename a table.

2. Add a new column to a table.


{{{heading(Renaming a table)}}}

#+cindex:@code{ALTER TABLE RENAME TO} statement
To rename a table, you use the following =ALTER TABLE RENAME TO= statement:

#+begin_src sql
ALTER TABLE existing_table
RENAME TO new_table;
#+end_src

There are some important points you should know before you rename a table:

- The =ALTER TABLE= only renames a table within a database.  It cannot be used
  to move the table between attached databases.

- The database objects, such as indexes, and triggers that are associated with
  the table are attached to the new table.

- If a table is referenced by views or statements in triggers, you must
  manually change the definition of views and triggers.


{{{heading(Adding a new column to a table)}}}

Another action you can perform with the SQLite =ALTER TABLE= statement is to
add a new column to an existing table.  In this case, SQLite appends the new
column at the end of the existing columns list.

#+cindex:@code{ALTER TABLE ADD COLUMN} statement
The following illustrates the syntax of =ALTER TABLE ADD COLUMN= statement:

#+begin_src sql
ALTER TABLE table
ADD COLUMN column_definition;
#+end_src

There are some restrictions of the new column:

- The new column cannot have a =UNIQUE= or =PRIMARY KEY= constraint.

- If the new column has a =NOT NULL= constraint, you must specify a default
  value for the column other than a =NULL= value.

- The new column cannot have a default of =CURRENT_TIMESTAMP=, =CURRENT_DATE=,
  and =CURRENT_TIME=, or an expression.

- If the new column is a foreign key and the foreign key constraint is enabled,
  the new column must accept a default value of =NULL=.


{{{heading(Other actions)}}}

If you want to perform other actions e.g., drop a column, rename a column,
etc., you use the following steps:

[[file:figs/SQLite-ALTER-TABLE-Steps.jpg]]

#+begin_src sql
PRAGMA foreign_keys=off;

BEGIN TRANSACTION;

ALTER TABLE table RENAME TO temp_table;

CREATE TABLE table
(
   column_definition,
   ...
);

INSERT INTO table (column_list)
  SELECT column_list
  FROM temp_table;

DROP TABLE temp_table;

COMMIT;

PRAGMA foreign_keys=on;
#+end_src

{{{subheading(Drop Column Example)}}}

SQLite does not support =ALTER TABLE DROP COLUMN= statement.  To do this, you
need to use the steps above.

For example, if you want to remove the location column of the equipment table,
you need to perform the following steps:

1. Begin transaction.
2. Rename the equipment table to =temp_equipment= table.
3. Recreate the equipment table without the location column.
4. Copy rows from the =temp_equipment= table to the equipment table.
5. Drop the =temp_equipment= table.
6. Commit transaction.


The following statements illustrate the steps above:

#+begin_src sql
BEGIN TRANSACTION;

ALTER TABLE equipment RENAME TO temp_equipment;

CREATE TABLE equipment (
 name text NOT NULL,
 model text NOT NULL,
 serial integer NOT NULL UNIQUE
);

INSERT INTO equipment
SELECT
 name, model, serial
FROM
 temp_equipment;

DROP TABLE temp_equipment;

COMMIT;
#+end_src

*** SQLite =DROP TABLE= Statement
- http://www.sqlitetutorial.net/sqlite-drop-table/

- SQLite Drop Table ::

     guide you how to remove a table from the database.


#+cindex:@code{DROP TABLE} statement
To remove a table in a database, you use SQLite =DROP TABLE= statement.  The
statement is simple as follows:

: DROP TABLE [IF EXISTS] [schema_name.]table_name;

You specify the table name, which you want to remove, after the =DROP TABLE=
clause.  SQLite allows you to drop one table at a time. To remove multiple
tables, you need to issue multiple =DROP TABLE= statements.  If you remove a
non-existent table, SQLite issues an error. If you use =IF EXISTS= option,
SQLite removes the table only if the table exists, otherwise, it just ignores
the statement and does nothing.  If you want to remove a table in a specific
database, you use the =[schema_name.]= explicitly.

In case the table has associated triggers and indexes, the =DROP TABLE=
statement also removes them all.  The =DROP TABLE= statement performs an
implicit =DELETE= statement before deleting the table.  However, the =DROP
TABLE= statement removes the triggers associated with the table before
performing the implicit =DELETE= statement; therefore, no triggers are fired.

#+cindex:foreign key constraint, @code{DROP TABLE}
If the foreign key constraint is enabled and you perform the =DROP TABLE=
statement, before SQLite performs the implicit =DELETE statement, it invokes
foreign key constraints check.  If the foreign key constraint is violated,
SQLite issues an error message and will not drop the table.

Notice that the =DROP TABLE= statement removes the table from the database and
the file on disk completely.  *You cannot undo or recover from this action*.
Therefore, you should perform the =DROP TABLE= statement with extra caution.

*** SQLite =VACUUM= Command
- http://www.sqlitetutorial.net/sqlite-vacuum/

- SQLite VACUUM ::

                   show you how to optimize database file.


{{{heading(Why the Vacuum Command)}}}

#+cindex:@command{VACUUM} command
First, when you drop database objects such as tables, views, indexes, and
triggers or delete data from tables, the database file size remains unchanged.
Because SQLite just marks the deleted objects as free and reserves it for the
future uses.  As a result, the size of the database file always grows in size.

Second, when you insert or delete data from the tables, the indexes and tables
become fragmented, especially for the database that has a high number of
inserts, updates, and deletes.

Third, the insert, update, and delete operations create unused data blocks
within individual database pages.  It decreases the number of rows that can be
stored in a single page.  Therefore, it increases the number of pages to hold a
table.  Because of this, it increases storage overhead for the table, takes
more time to read/write, and decreases the cache performance.

SQLite provides the VACUUM command to address all three issues above.

{{{heading(How the Vacuum Command Works)}}}

SQLite first copies data within a database file to a temporary database.  This
operation defragments the database objects, ignores the free spaces, and
repacks individual pages.  Then, SQLite copies the content of the temporary
database file back to the original database file.  The original database file
is overwritten.

Because the VACUUM command rebuilds the database, you can use it to change some
database-specific configuration parameters such as page size, page format,
default encoding, etc.  To do this, you set new values using pragma and then
vacuum the database.

**** The SQLite VACUUM command
The =VACUUM= command does not change the content of the database except the
=rowid= values.  If you use =INTEGER PRIMARY KEY= column, the =VACUUM= does not
change values of that column.  However, if you use unaliased =rowid=, the
=VACUUM= command will reset the =rowid= values.  Besides changing the =rowid=
values, the =VACUUM= command also builds the index from the scratch.

It is a good practice to perform the =VACUUM= command periodically, especially
when you delete the large table or index.

To run the =VACUUM= command, you need to issue it as simple as the following
statement:

#+begin_src sql
VACUUM;
#+end_src

Make sure that there is no open transaction while you run the command.

#+cindex:auto_vacuum pragma
The following statement enables full auto-vacuum mode:

#+begin_src sql
PRAGMA auto_vacuum = FULL;
#+end_src

To enable incremental vacuum, you use the following statement:

#+begin_src sql
PRAGMA auto_vacuum = INCREMENTAL;
#+end_src

The following statement disables auto-vacuum mode:

#+begin_src sql
PRAGMA auto_vacuum = NONE;
#+end_src

** Views
- http://www.sqlitetutorial.net/sqlite-create-view/

- SQLite Create View ::

      introduce you to the view concept and show you how to create a new view
     in the database.


- *Summary* :: in this tutorial, you will learn how to use the SQLite =CREATE
               VIEW= statement to create a view.

*** What is a view
#+cindex:view definition
#+cindex:stored query
#+cindex:query, pack into named object
In database theory, a /view/ is a result set of a stored query.  A view is the
way to pack a query into a named object.

#+cindex:base tables
You can access the data of the underlying tables through the view.  The tables
that the query in the view definition refers to are called /base tables/.

A view is useful in some cases:

  #+cindex:abstraction layer, view
- First, views provide an abstraction layer over tables.  You can add and remove
  the columns in the view without touching the schema of the underlying tables.

  #+cindex:encapsulate complex queries, view
- Second, you can use views to encapsulate complex queries with joins to
  simplify the data access.


SQLite view is read only.  It means you cannot use =INSERT=, =DELETE=, and
=UPDATE= statement to update data in the base tables through the view.

*** SQLite =CREATE VIEW= statement
#+cindex:@command{CREATE VIEW} statement
To create a view, you use the =CREATE VIEW= statement as follows:

#+begin_src sql
CREATE [TEMP] VIEW [IF NOT EXISTS] view_name(column-name-list)
AS
   select-statement;
#+end_src

#+cindex:@command{IF NOT EXISTS} option
First, you need to assign the view a name.  The =IF NOT EXISTS= option helps
you prevent an error of creating a view that already exists.

Second, if you want the view to be only visible in the current database
connection, you need to create a temporary view using the =TEMP= or =TEMPORARY=
option.  SQLite automatically removes the temporary views whenever the database
connection is closed.

Third, you specify the =SELECT= statement for the view.  By default, the
columns of the view derive from the result set of the =SELECT= statement.
However, you can use different columns for the view by specifying the columns
(=column-name-list=) explicitly after the view’s name.

*** SQLite =CREATE VIEW= example
The following query gets data from the tracks, albums, and genres tables in the
sample database using the inner join clause.

#+begin_src sql
SELECT
 trackid,
 tracks.name,
 albums.Title AS album,
 media_types.Name AS media,
 genres.Name AS genres
FROM
 tracks
INNER JOIN albums ON Albums.AlbumId = tracks.AlbumId
INNER JOIN media_types ON media_types.MediaTypeId = tracks.MediaTypeId
INNER JOIN genres ON genres.GenreId = tracks.GenreId;
#+end_src

To create a view based on this query, you use the following statement:

#+begin_src sql
CREATE VIEW v_tracks
AS
SELECT
 trackid,
 tracks.name,
 albums.Title AS album,
 media_types.Name AS media,
 genres.Name AS genres
FROM
 tracks
INNER JOIN albums ON Albums.AlbumId = tracks.AlbumId
INNER JOIN media_types ON media_types.MediaTypeId = tracks.MediaTypeId
INNER JOIN genres ON genres.GenreId = tracks.GenreId;
#+end_src

From now on, you just use the following simple query instead of the complex one
above.

#+begin_src sql
SELECT
 *
FROM
 v_tracks;
#+end_src

*** Removing views
#+cindex:@command{DROP VIEW} statement
To remove a view from the database, you use the =DROP VIEW= statement as
follows:

: DROP VIEW [IF EXISTS] view_name;

You need to specify the view name in the =DROP VIEW= statement to remove the
view.  Note that the =DROP VIEW= statement removes the view object only; no
actual data in the base tables is changed.

#+cindex:@command{IF EXISTS} option
If you remove an non-existent view, SQLite issues an error.  To avoid this, you
use the =IF EXISTS= option.  In case the view does not exist and you try to
remove it, SQLite just ignores the statement.

For example, the following statement removes the v_tracks view from the
database:

: DROP VIEW v_tracks;

** Indexes
*** SQLite Index
- http://www.sqlitetutorial.net/sqlite-index/

- SQLite Index ::

                  teach you about the index and how to utilize indexes to speed
                  up your queries.


- *Summary* :: in this tutorial, you will learn how to use SQLite indexes to
               query data faster, speed up sort operation, and enforce unique
               constraints.

**** What is an Index
#+cindex:table, definition
In relational databases, a table is a list of rows.  At the same time, each row
has the same column structure that consists of cells.  Each row also has a
consecutive =rowid= sequence number used to identify the row.  Therefore, we can
consider a /table/ as a list of pairs: =(rowid, row)=.

#+cindex:index, definition
Unlike a table, an index has an opposite relationship: =(row, rowid)=.  An
/index/ is an additional data structure that helps speed up querying, join, and
grouping operations.

[[file:figs/SQLite-Index.png]]

#+cindex:B-tree index
SQLite uses B-tree index.  =B= stands for /balanced/.  The B-tree keeps the
amount of data on its both side balanced so that the number of levels that must
be traversed to locate a row is always in the same approximate number.  In
addition, querying using equality and ranges on B-tree indexes are very
efficient.

**** How indexes work
Each index must be associated with a specific table.  An index consists of one
or more columns, but all columns of an index must be in the same table.  A table
may have multiple indexes.

Whenever you create an index, SQLite creates a B-tree structure to hold the
index data.

The index contains data from the columns that you specify in the index and the
corresponding rowid value.  This helps SQlite find the row quickly based on the
values of the indexed columns.

Imagine an index in the database like an index of a book.  By looking at the
index, you can quickly identify the page number based on the keyword.

**** SQLite =CREATE INDEX= statement
#+cindex:@command{CREATE INDEX} statement
To create an index, you use the =CREATE INDEX= statement.  The following
illustrates its syntax:

: CREATE [UNIQUE] INDEX index_name ON table_name(indexed_column);

To create an index, you specify three important items of information:

- The table that the index associated with.

- The a list of indexed column.

- The name of the index.


#+cindex:@command{UNIQUE} option
In case you want to make sure that the value of the column is unique like
email, phone, etc., you use the =UNIQUE= option in the =CREATE INDEX=
statement.

**** SQLite =UNIQUE= index example
Let’s create a new table named =contacts= for demonstration.

#+begin_src sql
CREATE TABLE contacts (
 first_name text NOT NULL,
 last_name text NOT NULL,
 email text NOT NULL
);
#+end_src

Suppose you want to enforce that the email is unique; you create a unique index
as follows:

: CREATE UNIQUE INDEX idx_contacts_email ON contacts (email);

To test this, first, you insert a row into the =contacts= table.

#+begin_src sql
INSERT INTO contacts (first_name, last_name, email)
VALUES
 (
 'John',
 'Doe',
 'john.doe@sqlitetutorial.net'
 );
#+end_src

Second, try to insert another row with a duplicate email.

#+begin_src sql
INSERT INTO contacts (first_name, last_name, email)
VALUES
 (
 'Johny',
 'Doe',
 'john.doe@sqlitetutorial.net'
 );
#+end_src

SQLite issued an error message that the unique constraint failed.  This is
because when you inserted the second row, SQLite checked and made sure that the
email is unique across of rows in the contacts table.

Let’s insert two more rows into the =contacts= table.

#+begin_src sql
INSERT INTO contacts (first_name, last_name, email)
VALUES
 (
 'David',
 'Brown',
 'david.brown@sqlitetutorial.net'
 ),
 (
 'Lisa',
 'Smith',
 'lisa.smith@sqlitetutorial.net'
 );
#+end_src

If you query data in the contacts table using the email column, SQLite will use
the index to locate the data.  See the following statement.

#+begin_src sql
SELECT
 first_name,
 last_name,
 email
FROM
 contacts
WHERE
 email = 'lisa.smith@sqlitetutorial.net';
#+end_src

#+cindex:@command{EXPLAIN QUERY PLAN} statement
To check if SQLite uses index or not, you use the =EXPLAIN QUERY PLAN=
statement as follows:

#+begin_src sql
EXPLAIN QUERY PLAN
SELECT
 first_name,
 last_name,
 email
FROM
 contacts
WHERE
 email = 'lisa.smith@sqlitetutorial.net';
#+end_src

**** SQLite multicolumn index example
If you create an index that consists of one column, SQLite uses that column as
the sort key.  In case you create an index that has multiple columns, SQLite
uses the additional columns as the second, third, … sort keys.

SQLite sorts the data on the multicolumn index by the first column specified in
the =CREATE INDEX= statement.  Then it sorts the duplicate values by the second
column, and so on.

Therefore, the column order is very important when you create the multicolumn
index.

To utilize a multicolumn index, the query must contain the condition that has
the same column order as defined in the index.

The following statement creates a multicolumn index on the =first_name= and
=last_name= columns of the contacts table:

#+begin_src sql
CREATE INDEX idx_contacts_name 
ON contacts (first_name, last_name);
#+end_src

If you query the contacts table with the one of following conditions in the
=WHERE= clause, SQLite will utilize the multicolumn index to search for data.

1. Querying by the =first_name= column.

   #+begin_src sql
   WHERE
    first_name = 'John';
   #+end_src

2. Querying by both =first_name= and =last_name= columns:

   #+begin_src sql
   WHERE
     first_name = 'John' AND last_name = 'Doe';
   #+end_src


However, SQLite will not use the multicolumn index if you use one of the
following conditions.

1. Querying by the =last_name= column only.

   #+begin_src sql
   WHERE
     last_name = 'Doe';
   #+end_src

2. Querying by =first_name= OR =last_name= columns.

   #+begin_src sql
   last_name = 'Doe' OR first_name = 'John';
   #+end_src


**** SQLite =DROP INDEX= statement
To remove an index, you use the =DROP INDEX= statement as follows:

: DROP INDEX [IF EXISTS] index_name;

The =IF EXISTS= option prevents you from an error of removing a non-existent
index.

For example, to remove the =idx_contact_name= index, you use the following
statement:

: DROP INDEX idx_contacts_name;

The =idx_contacts_name= index is removed completely from the disk.


*** SQLIte Expression-based Index
- http://www.sqlitetutorial.net/sqlite-index-expression/

- SQLite Index for Expressions ::

     show you how to use the expression-based index.

** Triggers

- SQLite Trigger ::

                    manage triggers in SQLite database.

** Full-text Search

- SQLite full-text search ::

     get started with the full-text search in SQLite.

*** Introduction to SQLite full-text search
#+cindex:virtual table
A virtual table is a custom extension to SQLite.  A virtual table is like a
normal table.  The difference between a virtual table and a normal table is
where the data come from, i.e., when you process a normal table, SQLite
accesses the database file to retrieve data.  However, when you access a
virtual table, SQLite calls the custom code to get the data.  The custom code
can have specified logic to handle certain tasks such as getting data from
multiple data sources.

#+cindex:FTS5 virtual table module
#+cindex:module, FTS5
To use full-text search in SQLite, you use =FTS5= virtual table module.

The following =CREATE VIRTUAL TABLE= statement creates an FTS5 table with two
columns:

#+begin_src sql
CREATE VIRTUAL TABLE table_name 
USING FTS5(column1,column2...);
#+end_src

Notice that you cannot add types, constraints, or =PRIMARY KEY= declaration in
the =CREATE VIRTUAL TABLE= statement for creating an FTS5 table.  If you do so,
SQLite will issue an error.

Like creating a normal table without specifying the primary key column, SQLite
adds an implicit =rowid= column to the FTS5 table.

The following example creates an FTS5 table named =posts= with two columns
=title= and =body=.

#+begin_src sql
CREATE VIRTUAL TABLE posts 
USING FTS5(title, body);
#+end_src

Similar to a normal table, you can insert data into the posts table as follows:

#+begin_src sql
INSERT INTO posts(title,body)
VALUES('Learn SQlite FTS5','This tutorial teaches you how to perform full-text search in SQLite using FTS5'),
('Advanced SQlite Full-text Search','Show you some advanced techniques in SQLite full-text searching'),
('SQLite Tutorial','Help you learn SQLite quickly and effectively');
#+end_src

And query data against it:

#+begin_src sql
SELECT * 
FROM posts;
#+end_src

*** Querying data using full-text search
You can execute a full-text query against an FTS5 table using one of these
three ways.

#+cindex:@code{MATCH} operator
1. First, use a =MATCH= operator in the =WHERE= clause of the =SELECT=
   statement.  For example, to get all rows that have the term =fts5=, you use
   the following query:

   #+begin_src sql
   SELECT * 
   FROM posts 
   WHERE posts MATCH 'fts5';
   #+end_src

2. Second, use an equal (~=~) operator in the =WHERE= clause of the SELECT
   statement.  The following statement returns the same result as the statement
   above:

   #+begin_src sql
   SELECT *
   FROM posts
   WHERE posts = 'fts5';
   #+end_src

3. Third, use a tabled-value function syntax.  In this way, you use the search
   term as the first table argument:

   #+begin_src sql
   SELECT *
   FROM posts('fts5');
   #+end_src


By default, FTS5 is case-independent.  It means that it treats the terms
=fts5=, =FTS5= and =Fts5= the same.

To sort the search results from the most to least relevant, you use the =ORDER
BY= clause as follows:

#+begin_src sql
SELECT *
FROM posts
WHERE posts MATCH 'text'
ORDER BY rank;
#+end_src

*** Using full-text query syntax
#+cindex:full-text search query
#+cindex:query, full-text search
A full-text search query is made up of phrases, where each phrase is an ordered
list of one or more tokens.  You can use the =+= operator to concatenate two
phrases as the following example:

#+begin_src sql
"learn SQLite"
"learn + SQLite"
#+end_src

FTS5 determines whether a document matches a phrase if the document contains at
least one subsequence of tokens that match the sequence of tokens used to
construct the phrase.

The following query returns all documents that match the search term =Learn
SQLite=:

#+begin_src sql
SELECT *
FROM posts
WHERE posts MATCH 'learn SQLite';
#+end_src

*** Prefix searches
#+cindex:prefix token
You can use the asterisk (=*=) as a prefix token.  When a phrase contains the
asterisk (=*=), it will match any document that contains the token that begins
with the phrase.  For example, =search*= matches with =search=, =searching=,
=searches=, etc.  See the following example:

#+begin_src sql
SELECT *
FROM posts
WHERE posts = 'search*';
#+end_src

*** Boolean operators
You can use the Boolean operators e.g., =NOT=, =OR=, or =AND= to combine
queries.

- q1 =AND= q2: matches if both q1 and q2 queries match.

- q1 =OR= q2: matches if either query q1 or q2 matches.

- q1 =NOT= q2: matches if query q1 matches and q2 doesn’t match.


For example, to get the documents that match the =learn= phrase but don't match
the =FTS5= phrase, you use the =NOT= operator as follows:

#+begin_src sql
SELECT *
FROM posts
WHERE posts MATCH 'learn NOT text';
#+end_src

To search for documents that match either phrase learn or text, you use the =OR=
operator as the following example:

#+begin_src sql
SELECT *
FROM posts
WHERE posts MATCH 'learn OR text';
#+end_src

To find the documents that match both SQLite and searching, you use the AND
operator as shown below:

#+begin_src sql
SELECT *
FROM posts
WHERE posts MATCH 'sqlite AND searching';
#+end_src

To change the operator precedence, you use parenthesis to group
expressions. For example:

#+begin_src sql
SELECT *
FROM posts
WHERE posts MATCH 'search AND sqlite OR help';
#+end_src

The statement returns documents that match search and sqlite or help. To find
the documents that match search and either sqlite or help, you use a
parenthesis as follows:

#+begin_src sql
SELECT * 
FROM posts 
WHERE posts MATCH 'search AND (sqlite OR help)';
#+end_src

*** Built-in auxiliary functions
#+cindex:auxiliary functions
#+cindex:functions, auxiliary
SQLite provides three built-in auxiliary functions that can be used within
full-text queries on the FTS5 table.

- The ~bm25()~ function returns a value that represents the accuracy of the
  current match; a lower value means a better match.

- The ~highlight()~ auxiliary function returns a copy of the text with search
  terms surrounded by a specified markup e.g., =<b>search term </b>=.

- The ~snippet()~ function selects a short fragment of text in order to
  maximize the number of search terms it contains.


For example, the following query uses the ~highlight()~ function to decorate
the search terms using the =<b>tag</b>=:

#+begin_src sql
SELECT highlight(posts,0, '<b>', '</b>') title,
       highlight(posts,1, '<b>', '</b>') body
FROM posts
WHERE posts MATCH 'SQLite'
ORDER BY rank;
#+end_src

* SQLite Advanced Tutorials
** SQLite Window Frame

** SQLite =CUME_DIST=

** SQLite =PERCENT_RANK=

** SQLite =DENSE_RANK=

** SQLite =NTILE=

** SQLite =NTH_VALUE=

** SQLite =LAST_VALUE=

** SQLite =FIRST_VALUE=

* SQLite Tools
** SQLite Commands
- http://www.sqlitetutorial.net/sqlite-commands/

- SQLite Commands ::

     show you the most commonly used command in sqlite3 program.


- *Summary* :: in this tutorial, we will introduce you to the most commonly
               used SQLite commands of the ~sqlite3~ command line program.

The SQLite project delivers a simple command-line tool named ~sqlite3~ (or
sqlite3.exe on Windows) that allows you to interact with the SQLite databases
using SQL statements and commands.

*** Connect to an SQLite database
To start the ~sqlite3~, you type the ~sqlite3~ as follows:

#+begin_src sh
>sqlite3
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
#+end_src

By default, an SQLite session uses the in-memory database; therefore all
changes will be gone when the session ends.

To open a database file, you use the ~.open FILENAME~ command.  The following
statement ~open~'S the ~chinook.db~ database:

: sqlite> .open c:\sqlite\chinook.db

If you want to open a specific database file when you connect to the SQlite
database, you use the following command:

#+begin_src sh
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

If you start a session with a database name that does not exist, the ~sqlite3~
tool will create the database file.

For example, the following command creates a database named =sales= in the
~C:\sqlite\ directory~:

#+begin_src sh
>sqlite3 c:\sqlite\sales.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

*** Show all available commands and their purposes
#+cindex:@command{.help} command
To show all available commands and their purpose, you use the ~.help~ command as
follows:

: .help

*** Show databases in the current database connection
#+cindex:@command{.databases} command
To show all databases in the current connection, you use the ~.databases~
command.  The ~.databases~ command displays at least one database with the
name: =main=.

For example, the following command shows all the databases of the current
connection:

#+begin_src sh
sqlite> .database
seq  name             file
---  ---------------  --------------------------
0    main             c:\sqlite\sales.db
sqlite>
#+end_src

To add an additional database in the current connection, you use the =ATTACH
DATABASE= statement.  The following statement adds the =chinook= database to
the current connection.

: sqlite> ATTACH DATABASE "c:\sqlite\chinook.db" AS chinook;

Now if you run the ~.database~ command again, the ~sqlite3~ returns two
databases: =main= and =chinook=.

#+begin_src sh
sqlite> .databases
seq  name             file
---  ---------------  ---------------------
0    main             c:\sqlite\sales.db
2    chinook          c:\sqlite\chinook.db
#+end_src

*** Exit ~sqlite3~ tool
#+cindex:@command{.exit} command
To exit the ~sqlite3~ program, you use the ~.exit~ command.

: sqlite>.exit

*** Show tables in a database
#+cindex:@command{.tables} command
To display all the tables in the current database, you use the ~.tables~
command.  The following commands open a new database connection to the
=chinook= database and display the tables in the database.

#+begin_src sh
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite> .tables
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
sqlite>
#+end_src

#+cindex:@command{.table pattern} command
#+cindex:@command{LIKE} operator
If you want to find tables based on a specific pattern, you use the ~.table
pattern~ command.  The ~sqlite3~ uses the =LIKE= operator for pattern matching.

For example, the following statement returns the table that ends with the
string =es=.

#+begin_src sh
sqlite> .table '%es'
employees    genres       invoices     media_types
sqlite>
#+end_src

*** Show the structure of a table
#+cindex:@command{.schema TABLE} command
#+cindex:schema
To display the structure of a table, you use the ~.schema TABLE~ command.  The
=TABLE= argument could be a pattern.  If you omit it, the ~.schema~ command
will show the structures of all the tables.

The following command shows the structure of the =albums= table.

#+begin_src sql
sqlite> .schema albums
CREATE TABLE "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON "albums" ([ArtistId]);
sqlite>
#+end_src

#+cindex:@command{.fullschema} command
To show the schema and the content of the =sqlite_stat= tables, you use the
~.fullschema~ command.

: sqlite>.fullschema

*** Show indexes
#+cindex:@command{.indexes} command
To show all indexes of the current database, you use the ~.indexes~ command as
follows:

#+begin_src sh
sqlite> .indexes
IFK_AlbumArtistId
IFK_CustomerSupportRepId
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
IFK_InvoiceLineInvoiceId
IFK_InvoiceLineTrackId
IFK_PlaylistTrackTrackId
IFK_TrackAlbumId
IFK_TrackGenreId
IFK_TrackMediaTypeId
#+end_src

#+cindex:@command{.indexes TABLE} command
To show the indexes of a specific table, you use the ~.indexes TABLE~ command.
For example, to show indexes of the =albums= table, you use the following
command:

#+begin_src sh
sqlite> .indexes albums
IFK_AlbumArtistId
#+end_src

To show indexes of the tables whose names end with =es=, you use a pattern of
the =LIKE= operator.

#+begin_src sh
sqlite> .indexes %es
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
#+end_src

*** Save the result of a query into a file
#+cindex:@command{.output FILENAME} command
#+cindex:@command{.once FILENAME} command
To save the result of a query into a file, you use the ~.output FILENAME~
command.  Once you issue the ~.output~ command, all the results of the
subsequent queries will be saved to the file that you specified in the FILENAME
argument.  If you want to save the result of the next single query only to the
file, you issue the ~.once FILENAME~ command.

To display the result of the query to the standard output again, you issue the
~.output~ command without arguments.

The following commands select the title from the =albums= table and write the
result to the ~albums.txt~ file.

#+begin_src sh
sqlite> .output albums.txt
sqlite> SELECT title FROM albums;
#+end_src

*** Execute SQL statements from a file
Suppose we have a file named ~commands.txt~ in the ~c:/sqlite/~ folder with the
following content:

#+begin_src sql
SELECT albumid, title
FROM albums
ORDER BY title
LIMIT 10;
#+end_src

#+cindex:@command{.read FILENAME} command
#+cindex:execute SQL from file
#+cindex:file, execute statements from
To execute the SQL statements in the ~commands.txt~ file, you use the ~.read
FILENAME~ command as follows:

#+begin_src sh
sqlite> .mode column
sqlite> .read c:/sqlite/commands.txt
156         ...And Justice For All
257         20th Century Masters -
296         A Copland Celebration,
94          A Matter of Life and D
95          A Real Dead One
96          A Real Live One
285         A Soprano Inspired
139         A TempestadeTempestade
203         A-Sides
160         Ace Of Spades
#+end_src

** SQLite =SHOW TABLES=
- http://www.sqlitetutorial.net

- SQLite Show Tables ::

     list all tables in a database.


- *Summary* :: in this tutorial, you will learn various ways to show tables
               from an SQLite database by using SQLite command line shell
               program or by querying data from =sqlite_master= tables.

*** Showing tables using the sqlite command line shell program
To show tables in a database using the ~sqlite3~ command line shell program,
you follow these steps:

First, open the database that you want to show the tables:

: sqlite> sqlite3 c:\sqlite\db\chinook.db

The above statement opened the database named ~chinook.db~ that locates in the
~c:\sqlite\db~ directory.

#+cindex:@command{.tables} command
Second, type the ~.tables~ command:

: sqlite> .tables

The ~.tables~ command lists all tables in the =chinook= database:

#+begin_src sh
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
#+end_src

#+cindex:@command{.table} command
#+cindex:@command{.ta} command
Note that both ~.tables~, ~.table~ have the same effect.  In addition, the
command ~.ta~ should work too.

The ~.tables~ command also can be used to show temporary tables.  See the
following example:

#+cindex:@command{CREATE TEMPORARY TABLE} command
First, create a new temporary table named =temp_table1=:

: sqlite> CREATE TEMPORARY TABLE temp_table1( name TEXT );

Second, list all tables from the database:

: sqlite> .tables

The following shows the output:

#+begin_src sh
albums            employees         invoices          playlists
artists           genres            media_types       temp.temp_table1
customers         invoice_items     playlist_track    tracks
#+end_src

Because the schema of temporary tables is =temp=, the command showed the names
of schema and table of the temporary table such as =temp.temp_table1=.

If you want to show tables with the specific name, you can add a matching
pattern:

: .tables pattern

The command works the same as =LIKE= operator.  The pattern must be surrounded
by single quotation marks (='=).

For example, to find tables whose names start with the letter ‘a’, you use the
following command:

: sqlite> .table 'a%'

Here is the output:

: albums   artists

To show the tables whose name contains the string =ck=, you use the =%ck%=
pattern as shown in the following command:

: sqlite> .tables '%ck%'

The output is as follows:

: playlist_track  tracks

*** Showing tables using SQL statement
Another way to list all tables in a database is to query them from the
=sqlite_master= table.

#+begin_src sql
SELECT 
    name
FROM 
    sqlite_master 
WHERE 
    type ='table' AND 
    name NOT LIKE 'sqlite_%';
#+end_src

In this query, we filtered out all tables whose names start with =sqlite_=n
such as =sqlite_stat1= and =sqlite_sequence= tables.  These tables are the
system tables managed internally by SQLite.

** SQLite =DESCRIBE TABLE=
- http://www.sqlitetutorial.net/sqlite-tutorial/sqlite-describe-table/

- SQLite Describe Table ::

     show the structure of a table.


- *Summary* :: in this tutorial, you will learn about various ways to show the
               structure of a table in SQLite.

*** Getting the structure of a table via the SQLite command line shell program
To find out the structure of a table via SQLite command line shell program, you
follow these steps:

First, connect to a database via the SQLite command line shell program:

: sqlite> sqlite3 c:\sqlite\db\chinook.db

Then, issue the following command:

#+cindex:@command{.schema TABLE_NAME} command
: .schema table_name

For example, to show the statement that created the =albums= table, you use the
following command:

: sqlite> .schema albums

Notice that you should /NOT/ use the semicolon (=;=).

Here is the output:

#+begin_src sql
CREATE TABLE IF NOT EXISTS "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON "albums" ([ArtistId]);
#+end_src

Another way to show the structure of a table is to use the following pragma
command:

#+begin_src sh
sqlite> .header on
sqlite> .mode column
sqlite> pragma table_info('albums');
#+end_src

Note that the first two commands are used to format the output nicely.

*** Getting the structure of a table using SQL statement
You can find the structure of a table by querying it from the =sqlite_master=
table as follows:

#+begin_src sql
SELECT
    sql 
FROM 
    sqlite_master 
WHERE 
    name = 'albums';
#+end_src

Here is the output:

#+begin_src sql
sql
----
CREATE TABLE "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
)
#+end_src

** SQLite ~.dump~ Command
- http://www.sqlitetutorial.net/sqlite-dump/

- SQLite Dump ::

                 how to use the ~.dump~ command to backup and restore a
                 database.

- *Summary* :: in this tutorial, you will learn how to use the SQLite dump
               command to backup and restore a database.

The SQLite project delivers the ~sqlite3~ tool that allows you to interact with
the SQLite database using a command-line shell program.

#+cindex:dot-commands
By using the ~sqlite3~ tool, you can use the SQL statements to query or update
data in the database.  In addition, you can use special commands, which are
known as /dot-commands/ to perform various useful database operations.

#+cindex:@command{.dump} command
#+cindex:backup a database
#+cindex:dump database into text file
One of these dot-commands is the ~.dump~ command that gives you the ability to
dump the entire database or tables into a text file.

*** Dump the entire database into a file using SQLite dump command
The following command opens a new SQLite database connection to the
~chinook.db~ file.

#+begin_src sh
C:\sqlite>sqlite3 c:/sqlite/chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

{{{heading(.output <file> ... .dump)}}}

To dump a database into a file, you use the ~.dump~ command.  The ~.dump~
command converts the entire structure and data of an SQLite database into a
single text file.

#+cindex:@command{.output FILENAME} command
By default, the ~.dump~ command outputs the SQL statements on screen.  To issue
the output to a file, you use the ~.output FILENAME~ command.

The following commands specify the output of the dump file to ~chinook.sql~ and
dump the =chinook= database into the ~chinook.sql~ file.

#+begin_src sh
sqlite> .output c:/sqlite/chinook.sql
sqlite> .dump
sqlite> .exit
#+end_src

*** Dump a specific table using the SQLite dump command
If you want to dump a specific table, you need to specify the table name
followed the ~.dump~ command.  For example, the following command saves the
=albums= table to the ~albums.sql~ file.

#+begin_src sh
sqlite> .output c:/sqlite/albums.sql
sqlite> .dump albums
sqlite> .quit
#+end_src

The following picture shows the content of the ~albums.sql~ file.

[[file:figs/SQLite-dump-example.png]]

*** Dump tables structure only using schema command
If you want to dump the structures of tables in a database, you use the
~.schema~ command.  The following commands set the output file to
=chinook_structure.sql= file and save the structures of tables into the
=chinook_structure.sql= file.

#+begin_src sh
sqlite> .output c:/sqlite/chinook_structure.sql
sqlite> .schema
sqlite> .quit
#+end_src

The following picture shows the content of the =chinook_structure.sql= file.

[[file:figs/SQLite-dump-structure.png]]

*** Dump data of one or more tables into a file
To dump the data of a table into a text file, you use these steps:

#+cindex:@command{.mode} command
#+cindex:mode
First, set the mode to =insert= using the ~.mode~ command as follows:

: sqlite> .mode insert

From now on, every =SELECT= statement will issue the result as the =INSERT=
statements instead of pure text data.

Second, set the output to a text file instead of the default standard output.
The following command sets the output file to the ~data.sql~ file.

: sqlite> .output data.sql

Third, issue the =SELECT= statements to query data from a table that you want
to dump.  The following command returns data from the =artists= table.

: sqlite> select * from artists;

Check the content of the ~data.sql~ file; if everything is fine, you will see
the following output:

[[file:figs/SQLite-dump-data-only.png]]

To dump data from other tables, you need to issue the =SELECT= statements to
query data from those tables.

** SQLite ~.import~ Command
- http://www.sqlitetutorial.net/sqlite-import-csv/

- SQLite Import CSV ::

     how to import CSV file into a table.


- *Summary* :: this tutorial shows you various ways to import CSV data into an
               SQLite table using ~sqlite3~ and SQLite Studio tools.

*** Importing a CSV file into a table using ~sqlite3~ tool
In the first scenario, you want to import data from a CSV file into a table
that does not exist in the SQLite database.

1. First, the ~sqlite3~ tool creates the table.  The ~sqlite3~ tool uses the
   first row of the CSV file as the names of the columns of the table.

2. Second, the ~sqlite3~ tool imports data from the second row onward of the
   CSV file into the table.


We will import a CSV file named ~city.csv~ with two columns: =name= and
=population=.  You can download it here for practicing.

[[http://www.sqlitetutorial.net/wp-content/uploads/2016/05/city.csv][Download the city.csv file]]

To import the ~c:\sqlite\city.csv~ file into the =cities= table:

{{{heading(.mode CSV)}}}

#+cindex:CSV mode
#+cindex:mode, CSV
First, set the mode to =CSV= to instruct the command-line shell program to
interpret the input file as a CSV file.  To do this, you use the ~.mode~
command as follows:

: sqlite> .mode csv

{{{heading(.import <file> <table>)}}}

#+cindex:@command{.import FILE TABLE} command
Second, use the ~.import FILE TABLE~ command to import the data from the
~city.csv~ file into the =cities= table.

: sqlite>.import c:/sqlite/city.csv cities

To verify the import, you use the ~.schema~ command to display the structure of
the =cities= table.

#+begin_src sh
sqlite> .schema cities
CREATE TABLE cities(
  "name" TEXT,
  "population" TEXT
);
#+end_src

To view the data of the cities table, you use the following =SELECT= statement.

#+begin_src sql
SELECT name, 
       population
FROM cities;
#+end_src

In the second scenario, the table is already available in the database and you
just need to import the data.

First, remove the =cities= table that you have created.

: DROP TABLE IF EXISTS cities;

Second, use the following =CREATE TABLE= statement to create the =cities=
table.

#+begin_src sql
CREATE TABLE cities(
  name TEXT NOT NULL,
  population INTEGER NOT NULL 
);
#+end_src

If the table already exists, the ~sqlite3~ tool uses all the rows, including
the first row, in the CSV file as the actual data to import.  Therefore, you
should delete the first row of the CSV file.

The following commands import the =city_without_header.csv= file into the
=cities= table.

#+begin_src sh
sqlite> .mode csv
sqlite> .import c:/sqlite/city_no_header.csv cities
#+end_src

** SQLite ~.export~ Command
- http://www.sqlitetutorial.net//sqlite-tutorial/sqlite-export-csv/

- SQLite Export CSV ::

     how to export an SQLite database to CSV files.


- *Summary* :: in this tutorial, you will learn how to export SQLite database
               to a CSV file.

*** Export SQLite Database to a CSV file using sqlite3 tool
SQLite project provides you with a command-line program called ~sqlite3~ or
sqlite3.exe on Windows.  By using the ~sqlite3~ tool, you can use the SQL
statements and dot-commands to interact with the SQLite database.

#+cindex:exort data to CSV
#+cindex:CSV mode, export
To export data from the SQLite database to a CSV file, you use these steps:

1. Turn on the header of the result set using the ~.header on~ command.

2. Set the output mode to =CSV= to instruct the ~sqlite3~ tool to issue the
   result in the =CSV= mode.

3. Send the output to a CSV file.

4. Issue the query to select data from the table to which you want to export.


The following commands select data from the customers table and export it to
the ~data.csv~ file.

#+begin_src sh
>sqlite3 c:/sqlite/chinook.db
sqlite> .headers on
sqlite> .mode csv
sqlite> .output data.csv
sqlite> SELECT customerid,
   ...>        firstname,
   ...>        lastname,
   ...>        company
   ...>   FROM customers;
sqlite> .quit
#+end_src

If you check the ~data.csv~ file, you will see the following output.

[[file:figs/SQLite-Export-CSV-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-Export-CSV-example.png]]

Besides using the dot-commands, you can use the options of the ~sqlite3~ tool
to export data from the SQLite database to a CSV file.

For example, the following command exports the data from the =tracks= table to
a CSV file named ~tracks.csv~.

: >sqlite3 -header -csv c:/sqlite/chinook.db "select * from tracks;" > tracks.csv

[[file:figs/SQLite-Export-CSV-one-liner-option.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-Export-CSV-one-liner-option.png]]

If you have a file named ~query.sql~ that contains the script to query data,
you can execute the statements in the file and export data to a CSV file.

: >sqlite3 -header -csv c:/sqlite/chinook.db < query.sql > data.csv

** SQLite GUI tools

** Command Line Shell For SQLite
- https://www.sqlite.org/cli.html

* SQLite Functions
** SQLite Aggregate Functions
- http://www.sqlitetutorial.net/sqlite-aggregate-functions/

This tutorial shows you how to use the SQLite aggregate functions to find the
maximum, minimum, average, sum, and count of a set of values.

- *Summary* :: in this tutorial, you will learn about the SQLite aggregate
               functions to find the maximum, minimum, average, sum, and count
               of a set of values.

*** Overview of SQLite aggregate functions
Aggregate functions operate on a set of rows and return a single result.
Aggregate functions are often used in conjunction with =GROUP BY= and =HAVING=
clauses in the =SELECT= statement.

SQLite provides the following aggregate functions:

- AVG() – returns the average value of a group.

- COUNT() – returns the number of rows that match a specified condition

- MAX() – returns the maximum value in a group.

- MIN() – returns the minimum value in a group

- SUM() – returns the sum of values

- =GROUP_CONCAT(expression, separator)= – returns a string that is the
  concatenation of all non-NULL values of the input expression separated by the
  separator.
*** SQLite aggregate function syntax
The following shows the syntax of calling an aggregate function except for the
=GROUP_CONCAT()= function:

: aggregate_function (DISTINCT | ALL expression)

In this syntax:

- First, specify the name of the aggregate function such as =AVG=, =SUM=, or
  =COUNT=

- Second, specify the expression to which the aggregate function applies.


=DISTINCT= instructs the aggregate function to consider only unique values in
the calculation while =ALL= allows the aggregate function to take all values
including duplicates in its calculation.

*** SQLite aggregate function examples

** SQLite Date Functions
- http://www.sqlitetutorial.net/sqlite-date-functions/

This section provides you with SQLite date and time functions that help you
manipulate datetime data effectively.

| Name      | Description                                                                                           |
|-----------+-------------------------------------------------------------------------------------------------------|
| DATE      | calculate a date value based on multiple date modifiers.                                              |
| TIME      | calculate a time value based on multiple date modifiers.                                              |
| DATETIME  | calculate a date & time value based on one or more date modifiers.                                    |
| JULIANDAY | returns the Julian day, which is the number of days since noon in Greenwich on November 24, 4714 B.C. |
| STRFTIME  | format a date value based on a specified format string.                                               |
|-----------+-------------------------------------------------------------------------------------------------------|

** SQLite String Functions
- http://www.sqlitetutorial.net/sqlite-string-functions/


This section shows the most commonly used SQLite string functions that help you
manipulate character string data effectively.

The following table shows the commonly used SQLite string functions that
perform an operation on an input string and return a new string or a numeric
value.

** SQLite Window Functions
- http://www.sqlitetutorial.net/sqlite-window-functions/


SQLite window functions perform a calculation on a set of rows that are related
to the current row. Unlike aggregate functions, window functions do not cause
rows to become grouped into a single result row.

* PRAGMA Statements
- [[https://www.sqlite.org/pragma.html][PRAGMA Statements in Documentation]]


#+cindex:PRAGMA statement
The =PRAGMA= statement is an SQL extension specific to SQLite and used to
modify the operation of the SQLite library or to query the SQLite library for
internal (non-table) data.  The PRAGMA statement is issued using the same
interface as other SQLite commands (e.g. =SELECT=, =INSERT=) but is different
in the following important respects:

- Specific pragma statements may be removed and others added in future releases
  of SQLite.  There is no guarantee of backwards compatibility.

- No error messages are generated if an unknown pragma is issued.  Unknown
  pragmas are simply ignored.  This means if there is a typo in a pragma
  statement the library does not inform the user of the fact.

- Some pragmas take effect during the SQL compilation stage, not the execution
  stage.

- The pragma command is specific to SQLite and is not compatible with any other
  SQL database engine.

** Pragma Syntax
There are two forms; both yield identical results:

#+begin_example
pragma <pragma-name> (<pragma-value>)
pragma <pragma-name=<pragma-value>
#+end_example

In many pragmas, the argument is a boolean (1 for =yes true on=, 2 for =no
false off=.  When pragma takes a keyword argument, it will usually also take a
numeric equivalent as well (0 and "no" mean the same thing); many pragmas
return the number rather than the keyword.  Keyword arguments can optionally
appear in quotes.  Some pragmas take a string literal as their argument.

A pragma may have an optional <schema-name> before the pragma name
(=<schema-name>.<pragma-name>=).  The <schema-name> is the name of an
=ATTACH=-ed database or "main" or "temp" for the main and the =TEMP= databases.
If the optional schema name is omitted, "main" is assumed.

** Pragma Functions
PRAGMAs that return results and that have no side-effects can be accessed from
ordinary SELECT statements as [[https://www.sqlite.org/vtab.html#tabfunc2][table-valued functions]].  For each participating
PRAGMA, the corresponding table-valued function has the same name as the PRAGMA
with a 7-character "pragma_" prefix.

: PRAGMA index_info('idx52');
: SELECT * FROM pragma_index_info('idx52')

The advantage of the table-valued function format is that the query can return
just a subset of the =PRAGMA= columns, can include a =WHERE= clause, can use
aggregate functions, and the table-valued function can be just one of several
data sources in a join.

Table-valued functions exist only for PRAGMAs that return results and that have
no side-effects.  The table-valued functions for PRAGMA feature was added in
SQLite version 3.16.0 (2017-01-02).  Prior versions of SQLite cannot use this
feature.

** List Of PRAGMAs
- https://www.sqlite.org/pragma.html

* SQLite Programming Interfaces
** SQLite Java
This SQLite Java section teaches you step by step how to interact with SQLite
database using Java JDBC API.

** SQLite Python
This section guides you how to work with the SQLite database using Python
sqlite3 module.

** SQLite PHP
This section shows you how to use PHP PDO to interact with SQLite databases. We
will walk you through the steps of setting up PHP project structure, connecting
to the SQLite database, and performing the common database operations.

** SQLite Node.js
- http://www.sqlitetutorial.net/sqlite-nodejs/


#+cindex:Node.js applications
#+cindex:@code{sqlite3} module
This section shows you how to interact with SQLite databases from Node.js
applications using the node sqlite3 module.

In this section, you will learn how to interact with SQLite databases from a
Node.js application using the ~sqlite3~ module.  After the tutorial, you will
know how to open a database connection and perform common database operations
such as select, insert, update, and delete.  In addition, you will learn how to
execute SQL statements in serialized mode or in parallel mode.

*** The Node.js sqlite3 Module
#+cindex:@command{sqlite3} npm module
#+cindex:npm module, @command{sqlite3}
Asynchronous, non-blocking SQLite3 bindings for Node.js.

- [[https://www.npmjs.com/package/sqlite3][sqlite3 npm home]]
- [[https://github.com/mapbox/node-sqlite3/wiki][sqlite3 API Documentation]]


#+cindex:@command{sqlite3} features
The ~sqlite3~ module is actively maintained and provides a rich set of
features:

- Simple API for query execution
- Parameters binding support
- Control the query execution flow, supporting both serialized and parallel
  modes.
- Comprehensive debugging support
- Full caching / Blob support
- SQLite extension support
- Bundles SQLite as a fallback


#+cindex:function call serialization
#+cindex:@command{Database.close()} function
~node-sqlite3~ has built-in function call serialization and automatically waits
before executing a blocking action until no other action is pending.  /This
means that it's safe to start calling functions on the database object even if
it is not yet fully opened/.  The ~Database#close()~ function will wait until
all pending queries are completed before closing the database.

{{{heading(Sample Usage)}}}

#+begin_src js -n
var sqlite3 = require('sqlite3').verbose();
var db = new sqlite3.Database(':memory:');

db.serialize(function() {
  db.run("CREATE TABLE lorem (info TEXT)");

  var stmt = db.prepare("INSERT INTO lorem VALUES (?)");
  for (var i = 0; i < 10; i++) {
      stmt.run("Ipsum " + i);
  }
  stmt.finalize();

  db.each("SELECT rowid AS id, info FROM lorem", function(err, row) {
      console.log(row.id + ": " + row.info);
  });
});

db.close();
#+end_src

*** Node-SQLite3 API
**** Main

{{{heading(Database Constructor)}}}

#+attr_texinfo: :options Constructor sqlite3 {new Database} (filename, [mode], [callback])
#+begin_defop
Returns a new Database object and automatically opens the database.  There is
no separate method to open the database.

- FILENAME :: Valid values are
  - filenames
  - ":memory:" for an anonymous in-memory database; and
  - an empty string for an anonymous disk-based database.  Anonymous databases
    are not persisted and when closing the database handle, their contents are
    lost.

- MODE :: [optional] One or more of
  - =sqlite3.OPEN_READONLY=
  - =sqlite3.OPEN_READWRITE=
  - =sqlite3.OPEN_CREATE=
  - The default value is =OPEN_READWRITE | OPEN_CREATE=

- CALLBACK :: [optional] If provided, this function will be called when the
              database is opened successfully or when an error occurrs.

  The first argument is an =error= object.  When it is =null=, opening
              succeeded.

              : function (err) { ... }

  If no callback is provided and an error occurrs, an =error= event with the
              =error= object as the only parameter will be emitted on the
              database object.  If opening succeeded, an =open= event with no
              parameters is emitted, regardless of whether a callback was
              provided or not.

- Example ::

  : var db = new sqlite3.Database(':memory:');
#+end_defop

{{{heading(sqlite3.verbose() Method)}}}
#+cindex:stack trace, sqlite3
#+cindex:debugging, sqlite3

#+attr_texinfo: :options sqlite3 verbose ()
#+begin_defmethod
Sets the execution mode to verbose to produce long stack traces.  There is no
way to reset this.  See the wiki page on debugging for more information.
#+end_defmethod

**** Database

**** Statement

*** Connect To an SQLite Database Using Node.js
- http://www.sqlitetutorial.net/sqlite-nodejs/connect/


- Summary :: in this tutorial, you will learn how to connect to an SQLite
             database from Node.js applications.

**** Installing sqlite3 module
#+cindex:@command{sqlite3} module, Node.js
#+cindex:Node.js @command{sqlite3} module, install
#+cindex:@command{npm install}
To interact with the SQLite database, you need to download and install the
~sqlite3~ module.  You can use ~npm~ to do so using the following command:

#+name:tangle-js-code
#+begin_src emacs-lisp :results output :exports results
(org-babel-tangle-file "SQLiteTutorial.org")
#+end_src

#+RESULTS:
| /usr/local/dev/programming/DB/SQLite/SQLiteTutorial/src/connect.js |

#+begin_src sh :dir src :results output :exports results
yarn add sqlite3
#+end_src

#+RESULTS:
#+begin_example
yarn add v1.16.0
info No lockfile found.
[1/4] Resolving packages...
[2/4] Fetching packages...
[3/4] Linking dependencies...
[4/4] Building fresh packages...
success Saved lockfile.
success Saved 105 new dependencies.
info Direct dependencies
└─ sqlite3@4.0.9
info All dependencies
├─ abbrev@1.1.1
├─ ajv@6.10.0
├─ ansi-regex@2.1.1
├─ aproba@1.2.0
├─ are-we-there-yet@1.1.5
├─ asn1@0.2.4
├─ asynckit@0.4.0
├─ aws-sign2@0.7.0
├─ aws4@1.8.0
├─ balanced-match@1.0.0
├─ bcrypt-pbkdf@1.0.2
├─ brace-expansion@1.1.11
├─ caseless@0.12.0
├─ chownr@1.1.1
├─ code-point-at@1.1.0
├─ combined-stream@1.0.8
├─ concat-map@0.0.1
├─ console-control-strings@1.1.0
├─ core-util-is@1.0.2
├─ dashdash@1.14.1
├─ debug@3.2.6
├─ deep-extend@0.6.0
├─ delayed-stream@1.0.0
├─ delegates@1.0.0
├─ detect-libc@1.0.3
├─ ecc-jsbn@0.1.2
├─ extend@3.0.2
├─ extsprintf@1.3.0
├─ fast-deep-equal@2.0.1
├─ fast-json-stable-stringify@2.0.0
├─ forever-agent@0.6.1
├─ form-data@2.3.3
├─ fs-minipass@1.2.6
├─ fs.realpath@1.0.0
├─ gauge@2.7.4
├─ getpass@0.1.7
├─ glob@7.1.4
├─ har-schema@2.0.0
├─ har-validator@5.1.3
├─ has-unicode@2.0.1
├─ http-signature@1.2.0
├─ iconv-lite@0.4.24
├─ ignore-walk@3.0.1
├─ inflight@1.0.6
├─ inherits@2.0.3
├─ ini@1.3.5
├─ is-fullwidth-code-point@1.0.0
├─ is-typedarray@1.0.0
├─ isarray@1.0.0
├─ isstream@0.1.2
├─ json-schema-traverse@0.4.1
├─ json-schema@0.2.3
├─ json-stringify-safe@5.0.1
├─ jsprim@1.4.1
├─ mime-db@1.40.0
├─ mime-types@2.1.24
├─ minimist@0.0.8
├─ minizlib@1.2.1
├─ mkdirp@0.5.1
├─ ms@2.1.2
├─ nan@2.14.0
├─ needle@2.4.0
├─ node-pre-gyp@0.11.0
├─ nopt@4.0.1
├─ npm-bundled@1.0.6
├─ npm-packlist@1.4.1
├─ npmlog@4.1.2
├─ number-is-nan@1.0.1
├─ oauth-sign@0.9.0
├─ object-assign@4.1.1
├─ os-homedir@1.0.2
├─ os-tmpdir@1.0.2
├─ osenv@0.1.5
├─ path-is-absolute@1.0.1
├─ performance-now@2.1.0
├─ process-nextick-args@2.0.0
├─ psl@1.1.32
├─ punycode@1.4.1
├─ qs@6.5.2
├─ rc@1.2.8
├─ readable-stream@2.3.6
├─ request@2.88.0
├─ rimraf@2.6.3
├─ safe-buffer@5.1.2
├─ safer-buffer@2.1.2
├─ sax@1.2.4
├─ semver@5.7.0
├─ set-blocking@2.0.0
├─ signal-exit@3.0.2
├─ sqlite3@4.0.9
├─ sshpk@1.16.1
├─ string_decoder@1.1.1
├─ string-width@1.0.2
├─ strip-ansi@3.0.1
├─ strip-json-comments@2.0.1
├─ tar@4.4.10
├─ tough-cookie@2.4.3
├─ tunnel-agent@0.6.0
├─ tweetnacl@0.14.5
├─ uri-js@4.2.2
├─ util-deprecate@1.0.2
├─ uuid@3.3.2
├─ verror@1.10.0
├─ wide-align@1.1.3
└─ yallist@3.0.3
Done in 8.76s.
#+end_example

{{{heading(Connect to a Database using ~sqlite3~ Module)}}}

#+cindex:@command{sqlite3} connect to db
After installing the ~sqlite3~ module, you are ready to connect to a SQLite
database from a Node.js application.

To connect to an SQLite database, you need to:

1. First, import the ~sqlite3~ module

   #+cindex:@code{Database()} function
   #+cindex:database information
   #+cindex:mode, opening
2. Second, call the ~Database()~ function of the ~sqlite3~ module and pass the
   database information such as database file, opening mode, and a callback
   function.

**** Connecting to the in-memory database
To open a database connection to an in-memory database, you use the following
steps.

First, import the ~sqlite3~ module:

: const sqlite3 = require('sqlite3').verbose();

#+cindex:execution mode, verbose
#+cindex:verbose execution mode
Notice that the /execution mode/ is set to verbose to produce long stack
traces.

#+cindex:@code{Database} object
Second, create a =Database= object:

: let db = new sqlite3.Database(':memory:');

#+cindex:@code{Database} object
The ~sqlite3.Database()~ returns a =Database= object and opens the database
connection automatically.

{{{heading(Callback Function)}}}

#+cindex:callback, @command{Database()} function
The ~sqlite3.Database()~ accepts a callback function that will be called when
the database opens successfully or when an error occurrs.

{{{subheading(An Error During Open)}}}

#+cindex:@code{error} object
The callback function has the =error= object as the first parameter.  If an
error occurred, the =error= object is not =NULL=; otherwise, it is =NULL=.

#+cindex:error event
#+cindex:open event
#+cindex:events, error, open
If you don’t provide a callback function and an error occurrs during the
opening of the database, an =error= event will be emitted.  In case the
database is opened successfully, an =open= event is emitted regardless of
whether a callback is provided or not.

So you now can open an SQLite database and provide the detailed information if
an error occurred as follows:

#+begin_src js
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    return console.error(err.message);
  }
  console.log('Connected to the in-memory SQlite database.');
});
#+end_src

{{{heading(Close a Database Connection)}}}

#+cindex:close database connection
#+cindex:@code{clode()} method, @code{Database} object
It is a good practice to close a database connection when you are done with it.
To close a database connection, you call the ~close()~ method of the =Database=
object as follows:

: db.close();

The ~close()~ method will wait for all pending queries completed before
actually closing the database.

#+cindex:callback, @code{close()} method
Similar to the ~Database()~, the ~close()~ method also accepts a callback that
indicates whether an error occurred during closing the database connection.

#+begin_src js
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
  console.log('Close the database connection.');
});
#+end_src

**** JS Code for Opening and Closing an In-Memory Database

#+caption[In-memory database]:Open and close an in-memory SQLite database
#+name:connect.js
#+begin_src js :tangle src/connect.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open database in memory
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    return console.error(err.message);
  }
  console.log('Connected to the in-memory SQlite database.');
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
  console.log('Closed the database connection.');
});
#+end_src

#+RESULTS: connect.js

{{{heading(Running the Code)}}}

Let’s run the program to see how it works.

#+begin_src sh :dir src :results output :exports results
node connect.js
#+end_src

#+RESULTS:
: Connected to the in-memory SQlite database.
: Closed the database connection.

As you can see, it works perfectly as expected.

**** Connecting to a Disk File Database
#+cindex:@command{sqlite3} connect
To connect to a disk file database, instead of passing the =':memory:'= string,
you pass the path to the database file.

For example, to connect to the =chinook= database file stored in the ~db/~
folder, you use the following statement:

#+begin_src js
let db = new sqlite3.Database('../db/chinook.db', (err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Connected to the chinook database.');
});
#+end_src

{{{heading(Opening Modes)}}}

#+cindex:opening modes
#+cindex:modes, opening
There are three opening modes:

#+cindex:@code{OPEN_READONLY} mode
1. =sqlite3.OPEN_READONLY=: open the database for read-only.

   #+cindex:@code{OPEN_READWRITE} mode
2. =sqlite3.OPEN_READWRITE= : open the database for reading and writing.

   #+cindex:@code{OPEN_CREATE} mode
3. =sqlite3.OPEN_CREATE=: open the database, if the database does not exist,
   create a new database.


The ~sqlite3.Database()~ accepts one or more modes as the second argument.  By
default, it uses the =OPEN_READWRITE | OPEN_CREATE= modes.  This means that if
the database does not exist, the new database will be created and is ready for
reading and writing.

To open the =chinook= sample database for read and write, you can do it as
follows:

#+begin_src js
let db = new sqlite3.Database('../db/chinook.db', sqlite3.OPEN_READWRITE, (err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Connected to the chinook database.');
});
#+end_src

**** JS Code for Opening and Closing an SQLite Database
The following example shows the complete code for opening the =chinook=
database, querying data from the playlists =table=, and closing the database
connection.

#+caption[Open-Close Database]:Open, query, and close the Chinook database
#+name:chinook.js
#+begin_src js :tangle src/chinook.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('../db/chinook.db', sqlite3.OPEN_READWRITE, (err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Connected to the chinook database.');
});

db.serialize(() => {
  db.each(`SELECT PlaylistId as id,
                  Name as name
           FROM playlists`, (err, row) => {
    if (err) {
      console.error(err.message);
    }
    console.log(row.id + "\t" + row.name);
  });
});

db.close((err) => {
  if (err) {
    console.error(err.message);
  }
  console.log('Close the database connection.');
});
#+end_src

#+begin_src sh :dir src :results output :exports results
node chinook.js
#+end_src

#+RESULTS:
#+begin_example
Connected to the chinook database.
1	Music
2	Movies
3	TV Shows
4	Audiobooks
5	90’s Music
6	Audiobooks
7	Movies
8	Music
9	Music Videos
10	TV Shows
11	Brazilian Music
12	Classical
13	Classical 101 - Deep Cuts
14	Classical 101 - Next Steps
15	Classical 101 - The Basics
16	Grunge
17	Heavy Metal Classic
18	On-The-Go 1
Close the database connection.
#+end_example

*** Querying Data in SQLite Database from Node.js Applications
- http://www.sqlitetutorial.net/sqlite-nodejs/query/


- Summary :: in this tutorial, you will learn how to query data from the SQLite
             database from a Node.js application using sqlite3 API.


#+cindex:query data, @command{sqlite3} module
To query data in SQLite database from a Node.js application, you use these
steps:

1. Open a database connection.

2. Execute a =SELECT= statement and process the result set.

3. Close the database connection.


#+cindex:@code{all()} method
#+cindex:@code{each()} method
#+cindex:@code{get()} method
The ~sqlite3~ module provides you with some methods for querying data such as
~all()~, ~each()~ and ~get()~.

**** Querying all rows with ~all()~ method
#+cindex:@code{all()} method
The ~all()~ method allows you to execute an SQL query with specified parameters
and call a callback to access the rows in the result set.

#+cindex:@code{all()} method signature
#+cindex:signature, @code{all()} method
The following is the signature of the ~all()~ method:

#+begin_src js
db.all(sql, params, (err, rows) => {
    // process rows here
});
#+end_src

The ~err~ argument stores the error detail in case there an error occurred
during the execution of the query.  Otherwise, the ~err~ will be =NULL=.  If
the query is executed successfully, the ~rows~ argument contains the result set
of the query.

Because the ~all()~ method retrieves all rows and places them in memory, for
the large result set you should use the ~each()~ method instead.

{{{heading(How to query data using the ~all()~ method)}}}

#+cindex:query data using @code{all()} method
#+cindex:@code{all()} method, query data
The following example illustrates how to query data from the =playlists= table
in the sample database using the ~all()~ method:

#+caption[Query all() Method]:Query Data using ~all()~ Method
#+name:all.js
#+begin_src js :tangle src/all.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('../db/chinook.db');

let sql = `SELECT DISTINCT Name name FROM playlists
           ORDER BY name`;

db.all(sql, [], (err, rows) => {
  if (err) {
    throw err;
  }
  rows.forEach((row) => {
    console.log(row.name);
  });
});

// close the database connection
db.close();
#+end_src

Let’s run the program.

#+name:run-all.js
#+begin_src sh :dir src :results output :exports results
node all.js
#+end_src

#+RESULTS: run-all.js
#+begin_example
90’s Music
Audiobooks
Brazilian Music
Classical
Classical 101 - Deep Cuts
Classical 101 - Next Steps
Classical 101 - The Basics
Grunge
Heavy Metal Classic
Movies
Music
Music Videos
On-The-Go 1
TV Shows
#+end_example

The output shows all playlists as expected.

**** Query the first row in the result set
#+cindex:@code{get()} method
#+cindex:query using @code{get()} method
When you know that the result set contains zero or one row e.g., querying a row
based on the primary key or querying with only one aggregate function such as
~count~, ~sum~, ~max~, ~min~, etc., you can use the ~get()~ method of the
=Database= object.

#+begin_src js
db.get(sql, params, (err, row) => {
    // process the row here
});
#+end_src

#+cindex:@code{get()} method
The ~get()~ method executes an SQL query and calls the callback function on the
first result row.  In case the result set is empty, the row argument is
=undefined=.

The following ~get.js~ program demonstrates how to query a playlist by its
=id=:

#+caption[Query all()]:Query a playlist by its ~id~
#+name:get.js
#+begin_src js :tangle src/get.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('../db/chinook.db');

let sql = `SELECT PlaylistId id,
                  Name name
           FROM playlists
           WHERE PlaylistId  = ?`;
let playlistId = 1;

// first row only
db.get(sql, [playlistId], (err, row) => {
  if (err) {
    return console.error(err.message);
  }
  return row
    ? console.log(row.id, row.name)
    : console.log(`No playlist found with the id ${playlistId}`);

});

// close the database connection
db.close();
#+end_src

Let’s run the ~get.js~ program.

#+name:run-get.js
#+begin_src sh :dir src :results output :exports results
node get.js
#+end_src

#+RESULTS: run-get.js
: 1 'Music'

The output shows the =Music= playlist, which is correct.

If you change the =playlistId= to 0 and execute the ~get.js~ program again:

#+name:change-playlistId-to-0
#+begin_src sh :dir src :results output :exports results
sed -E -e '/playlistId = 1/ s/1/0/' get.js > get0.js
node get0.js
#+end_src

#+RESULTS: change-playlistId-to-0
: No playlist found with the id 0

It shows that no playlist found with =id= 0 as expected.

**** Query rows with ~each()~ method
#+cindex:@code{each()} method
#+cindex:query using @code{each()} method
The ~each()~ method executes an SQL query with specified parameters and calls a
callback for every row in the result set.

#+cindex:@code{each()} method signature
#+cindex:signature of @code{each()} method
The following illustrates the signature of the ~each()~ method:

#+begin_src js
db.each(sql,params, (err, result) => {
   // process each row here
});
#+end_src

If the result set is empty, the callback is never called.  In case there is an
error, the ~err~ parameter contains the detailed information.

The following ~each.js~ program illustrates how to use the ~each()~ method to
query customer’s data from the =customers= table.

#+caption[Query each()]:Query Data using the ~each()~ method
#+name:each.js
#+begin_src js :tangle src/each.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open the database
let db = new sqlite3.Database('../db/chinook.db');

let sql = `SELECT FirstName firstName,
                  LastName lastName,
                  Email email
            FROM customers
            WHERE Country = ?
            ORDER BY FirstName`;

db.each(sql, ['USA'], (err, row) => {
  if (err) {
    throw err;
  }
  console.log(`${row.firstName} ${row.lastName} - ${row.email}`);
});

// close the database connection
db.close();
#+end_src

#+RESULTS: each.js

Let’s run the ~each.js~ program:

#+name:run-each.js
#+begin_src sh :dir src :results output :exports results
node each.js
#+end_src

#+RESULTS: run-each.js
#+begin_example
Dan Miller - dmiller@comcast.com
Frank Harris - fharris@google.com
Frank Ralston - fralston@gmail.com
Heather Leacock - hleacock@gmail.com
Jack Smith - jacksmith@microsoft.com
John Gordon - johngordon22@yahoo.com
Julia Barnett - jubarnett@gmail.com
Kathy Chase - kachase@hotmail.com
Michelle Brooks - michelleb@aol.com
Patrick Gray - patrick.gray@aol.com
Richard Cunningham - ricunningham@hotmail.com
Tim Goyer - tgoyer@apple.com
Victor Stevens - vstevens@yahoo.com
#+end_example

As you see, the callback function was called for each row to print out the
customer’s information.

*** Controlling the Execution Flow of Statements
- http://www.sqlitetutorial.net/sqlite-nodejs/statements-control-flow/


- Summary :: in this tutorial, you will learn how to control the execution flow
             of statements.


#+cindex:execution flow, @command{sqlite3}
#+cindex:@code{serialize()} method, execution flow
#+cindex:@code{parallelize()} method, execution flow
The ~sqlite3~ module provides you with two methods for controlling the
execution flow of statements.  The ~serialize()~ method allows you to execute
statements in serialized mode, while the ~parallelize()~ method executes the
statements in parallel.

Let’s look into each method in detail to understand how it works.

**** Executing statement in serialized mode with ~Database.serialize~
#+cindex:@code{serialize()} method
#+cindex:mode, serialized
#+cindex:serialized mode
#+cindex:execution mode, serialized
#+cindex:mode, execution, serialized
The ~serialize()~ method puts the execution mode into *serialized mode*.  It
means that /only one statement can execute at a time/.  Other statements will
wait in a queue until all the previous statements are executed.

After the ~serialize()~ method returns, the execution mode is set to the
original mode again.

#+cindex:nest @code{serialize()} methods
It’s safe to nest the ~serialize()~ methods as follows:

#+begin_src js
db.serialize(() => {
  // queries will execute in serialized mode
  db.serialize(() => {
    // queries will execute in serialized mode
  });
  // queries will execute in serialized mode
});
#+end_src

Suppose, you want to execute the following three statements in sequence:

1. Create a new table.

2. Insert data into the table.

3. Query data from the table.


To do this, you place these statements in the ~serialize()~ method as follows:

#+caption[Serialize mode]:Running Queries in ~serialize~ mode
#+name:serialize.js
#+begin_src js :tangle src/serialize.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open the database connection
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  }
});

db.serialize(() => {
  // Queries scheduled here will be serialized.
  db.run('CREATE TABLE greetings(message text)')
    .run(`INSERT INTO greetings(message)
          VALUES('Hi'),
                ('Hello'),
                ('Welcome')`)
    .each(`SELECT message FROM greetings`, (err, row) => {
      if (err){
        throw err;
      }
      console.log(row.message);
    });
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});
#+end_src

#+cindex:chain method calls, @code{Database} object
Because the ~run()~ method returns a =Database= object, we can chain the method
calls.

Let’s run the program to see how it works.

#+name:run-serialize.js
#+begin_src sh :dir src :results output :exports results
node serialize.js
#+end_src

#+RESULTS: run-serialize.js
: Hi
: Hello
: Welcome

It works as expected.

Notice that if you don’t place three statements in the ~serialize()~ method,
the three statements may execute in parallel, which would cause an error.

**** Executing statements in parallel with ~Database.parallelize~
#+cindex:@code{parallelize()} method
#+cindex:parallelize mode
If you want the scheduled queries to execute in parallel, you place them in the
~parallelize()~ method.

Similar to the ~serialize()~ method, it is safe to nest the ~parallelize()~
method as follows:

#+begin_src js
db.parallelize(() => {
  // queries will execute in parallel mode
  db.parallelize(() => {
    // queries will execute in parallel mode
  });
  // queries will execute in parallel mode
});
#+end_src

For the demonstration, we will create a new function that calculates the sum of
two numbers using SQLite database and place the function calls in the
~parallelize()~ method as shown in the following example:

#+caption[Parallelize mode]:Run function calls in parallel using ~parallelize~ mode
#+name:parallelize.js
#+begin_src js :tangle src/parallelize.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open a database connection
let db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  }
});

db.parallelize(() => {
  dbSum(1, 1, db);
  dbSum(2, 2, db);
  dbSum(3, 3, db);
  dbSum(4, 4, db);
  dbSum(5, 5, db);
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});

function dbSum(a, b, db) {
  db.get('SELECT (? + ?) sum', [a, b], (err, row) => {
    if (err) {
      console.error(err.message);
    }
    console.log(`The sum of ${a} and ${b} is ${row.sum}`);
  });
}
#+end_src

Let’s run the parallelize.js program.

#+name:run-parallelize.js
#+begin_src sh :dir src :results output :exports results
node parallelize.js
#+end_src

#+RESULTS: run-parallelize.js
: The sum of 1 and 1 is 2
: The sum of 2 and 2 is 4
: The sum of 3 and 3 is 6
: The sum of 4 and 4 is 8
: The sum of 5 and 5 is 10

As you see in the output, the order of execution is not the same as it was
called in the program.

Notice that the statements execute in parallel; therefore, each time you run
the program, the order of execution may be different.[fn::It's always the same
on this machine.]

*** Inserting Data Into an SQLite Table from a Node.js Application
- http://www.sqlitetutorial.net/sqlite-nodejs/insert/


- Summary :: in this tutorial, you will learn how to insert one or more row
             into an SQLite table from a Node.js application.


#+cindex:insert data
To insert data into an SQLite table from a Node.js application, you follow
these steps:

1. Open a database connection.

2. Execute an =INSERT= statement.

3. Close the database connection.


For the demonstration, we will create a new database named ~sample.db~ in the
~db/~ folder.

{{{heading(Open a Database Connection)}}}

#+cindex:default mode, open database
When you open a database connection in the =default= mode, the database is
created if it does not exist.

: let db = new sqlite3.Database('./db/sample.db');

In the ~sample.db~ database, we create a table called =langs= for storing the
programming languages:

: db.run('CREATE TABLE langs(name text)');

You can run the program to create the ~sample.db~ database and =langs= table as
follows:

#+caption[Create new database]:Create the ~sample.db~ database and =langs= Table
#+name:sample.js
#+begin_src js :tangle src/sample.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

let db = new sqlite3.Database('../db/sample.db');

db.run('CREATE TABLE langs(name text)');

db.close();
#+end_src

#+name:run-sample.js
#+begin_src sh :dir src :results output :exports results
node sample.js
#+end_src

#+RESULTS: run-sample.js

Now, we are ready to insert data into the =langs= table.

{{{heading(Insert one row into a table)}}}

#+cindex:@code{INSERT} statement using @code{run()} method
#+cindex:@code{run()} method, @code{INSERT}
To execute an =INSERT= statement, you use the ~run()~ method of the =Database=
object:

#+begin_src js
db.run(sql, params, function(err){
  //
});
#+end_src

The ~run()~ method executes an =INSERT= statement with specified parameters and
calls a callback afterwards.  If an error occurred, you can find the detailed
information in the =err= argument of the callback function.  In case the
statement is executed successfully, the ~this~ object of the callback function
will contain two properties:

- =lastID= property stores the value of the last inserted row ID.

- =changes= property stores the rows affected by the query.


The following ~insert.js~ program illustrates how to insert a row into the
=langs= table:

#+caption[Insert row]:Insert a row into the =langs= table
#+name:insert.js
#+begin_src js :tangle src/insert.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

  let db = new sqlite3.Database('../db/sample.db');

  // insert one row into the langs table
  db.run(`INSERT INTO langs(name) VALUES(?)`, ['C'], function(err) {
    if (err) {
      return console.log(err.message);
    }
    // get the last insert id
    console.log(`A row has been inserted with rowid ${this.lastID}`);
  });

  // close the database connection
  db.close();
#+end_src

Let’s run the ~insert.js~ program:

#+name:run-insert.js
#+begin_src sh :dir src :results output :exports results
node insert.js
#+end_src

#+RESULTS: run-insert.js
: A row has been inserted with rowid 1

It worked as expected.

{{{heading(Insert multiple rows into a table at a time)}}}

#+cindex:insert multiple rows
#+cindex:@code{INSERT} multiple rows
To insert multiple rows at a time into a table, you use the following form of
the =INSERT= statement:

#+begin_src sql
INSERT INTO table_name(column_name)
VALUES(value_1), (value_2), (value_3),...
#+end_src

To simulate this in the Node.js application, we first need to construct the
=INSERT= statement with multiple placeholders:

#+begin_src sql
INSERT INTO table_name(column_name)
VALUES(?), (?), (?),...
#+end_src

Suppose, you want to insert rows into the =langs= table with the data from the
following =languages= array:

: let languages = ['C++', 'Python', 'Java', 'C#', 'Go'];

To construct the =INSERT= statement, we use the ~map()~ method to map each
element in the =languages= array into =(?)= and then join all placeholders
together.

#+begin_src js
let placeholders = languages.map((language) => '(?)').join(',');
let sql = 'INSERT INTO langs(name) VALUES ' + placeholders;
#+end_src

The following ~insert-many.js~ program illustrates how to insert multiple rows
into the =langs= table:

#+caption[Insert multiple rows]:Insert multiple rows into the =langs= table
#+name:insert-many.js
#+begin_src js :tangle src/insert-many.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open the database connection
let db = new sqlite3.Database('../db/sample.db');

let languages = ['C++', 'Python', 'Java', 'C#', 'Go'];

// construct the insert statement with multiple placeholders
// based on the number of rows
let placeholders = languages.map((language) => '(?)').join(',');
let sql = 'INSERT INTO langs(name) VALUES ' + placeholders;

// output the INSERT statement
console.log(sql);

db.run(sql, languages, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Rows inserted ${this.changes}`);
});

// close the database connection
db.close();
#+end_src

Let’s run the ~insert-many.js~ program to see how it works.

#+name:run-insert-many.js
#+begin_src sh :dir src :results output :exports results
node insert-many.js
#+end_src

#+RESULTS: run-insert-many.js
: INSERT INTO langs(name) VALUES (?),(?),(?),(?),(?)
: Rows inserted 5

It inserted 5 rows into the =langs= table, which is what we expected.

*** Updating Data in SQLite Database from a Node.js Application
- http://www.sqlitetutorial.net/sqlite-nodejs/update/


- Summary :: this tutorial shows you how to update data in the SQLite database
             from a Node.js application.


#+cindex:update data
#+cindex:@code{UPDATE} statement
To update data in the SQLite database from a Node.js application, you use these
steps:

1. Open a database connection.

2. Execute an =UPDATE= statement.

3. Close the database connection


For the demonstration, we will use the =langs= table in the ~sample.db~
database that we created in the previous tutorial.

{{{heading(Updating data example)}}}

#+cindex:@code{UDPATE} syntax
To update data in a table, you use the =UPDATE= statement as follows:

#+begin_src sql
UPDATE table_name
SET column_name = value_1
WHERE id = id_value;
#+end_src

To execute the =UPDATE statement in the Node.js application, you call the
~run()~ method of the =Database= object:

#+begin_src js
db.run(sql, params, function(err){
  //
});
#+end_src

The ~run()~ method executes an =UPDATE= statement with specified parameters and
calls a callback afterwards.  The =err= argument of the callback stores the
error detail in case the execution has any problem e.g., syntax error, locking,
etc.  If the =UPDATE= statement is executed successfully, the ~this~ object of
the callback function will contain the =changes= property that stores the
number of rows updated.

The following ~update.js~ program illustrates how to update a row in the
=langs= table from C to Ansi C:

#+caption[Update row]:How to update a row in the =langs= table
#+name:update.js
#+begin_src js :tangle src/update.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open a database connection
let db = new sqlite3.Database('../db/sample.db');

//
let data = ['Ansi C', 'C'];
let sql = `UPDATE langs
            SET name = ?
            WHERE name = ?`;

db.run(sql, data, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Row(s) updated: ${this.changes}`);

});

// close the database connection
db.close();
#+end_src

Let’s test the ~update.js~ program.

#+name:run-update.js
#+begin_src sh :dir src
node update.js
#+end_src

#+RESULTS: run-update.js
: Row(s) updated: 1

The output showed that one row has been updated which is correct.

*** Deleting Data in SQLite Database from a Node.js Application
- http://www.sqlitetutorial.net/sqlite-nodejs/delete/


- Summary :: in this tutorial, you will learn how to delete data in the SQLite
             database from a Node.js application.


#+cindex:delete data
#+cindex:@code{DELETE} statement
To delete data in the SQLite database from a Node.js application, you use the
following steps:

1. Open a database connection.

2. Execute a =DELETE= statement.

3. Close the database connection.


For the demonstration, we will use the =langs= table in the ~sample.db~
database that we created in the previous tutorial.

{{{heading(Deleting data example)}}}

#+cindex:@code{DELETE} syntax
To delete data from a table, you use the =DELETE= statement as follows:

#+begin_src sql
DELETE FROM table_name
WHERE column_name = value;
#+end_src

To execute the =DELETE= statement from a Node.js application, you call the
~run()~ method of the =Database= object as follows:

#+begin_src js
db.run(sql, params, function(err) {
  //
});
#+end_src

The ~run()~ method allows you to execute a =DELETE= statement with specified
parameters and calls a callback function afterwards.

If there was any error during the execution of =DELETE= statement, the =err=
argument of the callback function will provide the detail.  In case the
=DELETE= statement executed successfully, the ~this~ object of the callback
function will contain the =changes= property that stores the number of rows
deleted.

The following ~delete.js~ program illustrates how to delete a row from the
=langs= table:

#+caption[Delete row]:How to delete a row from the =langs= table
#+name:delete.js
#+begin_src js :tangle src/delete.js :mkdirp yes
const sqlite3 = require('sqlite3').verbose();

// open a database connection
let db = new sqlite3.Database('../db/sample.db', (err) => {
  if (err) {
    console.error(err.message);
  }
});

let id = 1;
// delete a row based on id
db.run(`DELETE FROM langs WHERE rowid=?`, id, function(err) {
  if (err) {
    return console.error(err.message);
  }
  console.log(`Row(s) deleted ${this.changes}`);
});

// close the database connection
db.close((err) => {
  if (err) {
    return console.error(err.message);
  }
});
#+end_src

Let’s test the ~delete.js~ program.

#+name:run-delete.js
#+begin_src sh :dir src :results output :exports results
node delete.js
#+end_src

#+RESULTS: run-delete.js
: Row(s) deleted 1

The output showed that one row has been deleted successfully.

* SQLite Resources
- http://www.sqlitetutorial.net/sqlite-resources/

* List of Figures
:PROPERTIES:
:unnumbered: t
:END:

#+texinfo:@listoffloats Figure

* List of Programs
:PROPERTIES:
:unnumbered: t
:END:

#+texinfo:@listoffloats Listing

* Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:
* Function Index
:PROPERTIES:
:unnumbered: t
:index:    fn
:END:
* Export Options                                                   :noexport:
** HTML Export Options
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t date:nil
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+subtitle:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.50 (<a href="https://orgmode.org">Org</a> mode 9.2.3)
#+latex_header:

** Texinfo Export Options
#+options: toc:nil H:4
#+texinfo_filename:sqlite-tutorial.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subtitle:
#+subauthor:
#+texinfo_dir_category: Databases
#+texinfo_dir_title:SQLite Tutorial
#+texinfo_dir_desc: Everything you need to know to start using SQLite effectively.
#+texinfo_printed_title:SQLite Tutorial

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h2>@@ $1 @@html:</h2>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h3>@@ $1 @@html:</h3>@@

* Local Variables                                                  :noexport:
# Local variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
