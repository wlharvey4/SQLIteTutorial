# -*- mode:org; fill-column:79; -*-
#+title:SQLite Tutorial
#+subtitle:{{{version}}}
#+date:2019-06-12 23:29
#+macro:version Version 0.0.6 {{{date}}}
* Introduction
- [[https://www.sqlite.org/index.html][SQLite Home]]
- [[https://www.sqlite.org/docs.html][SQLite Documentation]]
- [[https://www.sqlite.org/download.html][SQLite Download Page]]
- [[http://www.sqlitetutorial.net][SQLite Tutorial Home]]
- [[https://sqlite.org/src/doc/trunk/README.md][SQLite Source Repository and Compilation]]
- *Latest Release*: Version 3.28.0 (2019-04-16)


#+begin_src sh :results output :exports results
echo SQLite installed version:
sqlite3 --version
#+end_src

*SQLite* is an /open source/, /zero-configuration/, /self-contained/,
/stand-alone/, /transaction/ relational database engine designed to be
/embedded/ into an application.

This SQLite tutorial teaches you everything you need to know to start
using SQLite effectively. You will learn SQLite through extensive
hands-on practices.

* About the SQLite Tutorial
- http://www.sqlitetutorial.net

SQLite Tutorial website helps you master SQLite quickly and easily. It explains
the complex concepts in simple and easy-to-understand ways so that you can both
understand SQLite fast and know how to apply it in your software development
work more effectively.

* Getting started with SQLite
You should go through this section if this is the first time you have worked
with SQLite.  Follow these 3-easy steps to get started with SQLite fast.

- First, we help you answer the first important question: [[http://www.sqlitetutorial.net/what-is-sqlite/][what is SQLite]]?  You
  will have a brief overview of SQLite before you start working with it.

- Second, we show you step by step how to [[http://www.sqlitetutorial.net/download-install-sqlite/][download and install SQLite GUI tool]]
  on your computer.

- Third, we introduce you to an [[http://www.sqlitetutorial.net/sqlite-sample-database/][SQLite sample database]] and walk you through the
  steps of using the sample database for practicing.

** What is SQLite
- http://www.sqlitetutorial.net/what-is-sqlite/

*Summary*: this tutorial gives you a brief overview of SQLite and the SQLite’s
distinctive features that make SQLite the most widely deployed SQL database
engine.

SQLite is a software library that provides a relational database management
system.  The /lite/ in SQLite means light weight in terms of setup, database
administration, and required resource.

SQLite has the following noticeable features:
- self-contained,
- serverless,
- zero-configuration,
- transactional


SQLite is a C-language library that implements a small, fast, self-contained,
high-reliability, full-featured, SQL database engine.  The SQLite file format
is stable, cross-platform, and backwards compatible.  SQLite database files are
commonly used as containers to transfer rich content between systems and as a
long-term archival format for data.

*** Serverless
#+cindex:serverless
#+cindex:RDBMS
#+cindex:MySQL
#+cindex:PostgreSQL
#+cindex:TCP/IP
#+cindex:client/server architecture
Normally, an RDBMS such as MySQL, PostgreSQL, etc., requires a separate server
process to operate.  The applications that want to access the database server
use TCP/IP protocol to send and receive requests.  This is called client/server
architecture.

The following diagram illustrates the RDBMS client/server architecture:

#+caption:RDMBS Client-Server Architecture
#+name:fig:client-server-arch
[[file:figs/RDBMS-Client-Server-Architecture.jpg]]

*SQLite does NOT work this way.* SQLite does *NOT* require a server to run.

SQLite database is integrated with the application that accesses the database.
The applications interact with the SQLite database to read and write directly
from the database files stored on disk.

The following diagram illustrates the SQLite server-less architecture:

#+caption:SQLite Serverless Architecture
#+name:fig:sqlite-serverless-arch
[[file:figs/What-is-SQLite.jpg]]

*** Detailed Description of Features
- [[https://www.sqlite.org/features.html][Features]]
- [[https://www.sqlite.org/omitted.html][Omitted Features]]


  #+cindex:transactions, ACID
  #+cindex:ACID transactions
- Transactions are /atomic/, /consistent/, /isolated/, and /durable/ (*ACID*)
  even after system crashes and power failures.

  #+cindex:zero-configuration
  #+cindex:configuration, none
- *Zero-configuration* --- no setup or administration needed.

  #+cindex:indexes, partial, on expressions
  #+cindex:JSON
  #+cindex:table expressions
  #+cindex:window functions
- Full-featured SQL implementation with advanced capabilities like /partial
  indexes/, /indexes on expressions/, /JSON/, /common table expressions/, and /window
  functions/.

  #+cindex:application file format
- A complete database is stored in a *single cross-platform disk file*.  Great
  for use as an [[https://www.sqlite.org/appfileformat.html][application file format]].[fn::An "application file format" is
  the file format used to persist application state to disk or to exchange
  information between programs.]

  #+cindex:terabyte-sized databases
  #+cindex:gigabyte-sized strings, blobs
- Supports *terabyte-sized databases* and gigabyte-sized strings and blobs.

  #+cindex:small footprint
- *Small code footprint*: less than 600KiB fully configured or much less with
  optional features omitted.

  #+cindex:API
- Simple, easy to use *API*.

  #+cindex:fast
- *Fast*: In some cases, SQLite is faster than direct filesystem I/O

  #+cindex:ANSI-C
  #+cindex:TCL bindings
- Written in *ANSI-C*. TCL bindings included.  Bindings for dozens of other
  languages available separately.

  #+cindex:source code well commented
- Well-commented *source code* with 100% branch test coverage.

  #+cindex:compile source code
- Available as a single *ANSI-C source-code file* that is easy to compile and
  hence is easy to add into a larger project.

  #+cindex:dependencies, none
  #+cindex:self-contained
- *Self-contained*: no external dependencies.

  #+cindex:cross-platform
  #+cindex:Android
  #+cindex:BSD
  #+cindex:iOS
  #+cindex:Linux
  #+cindex:Mac
  #+cindex:Solaris
  #+cindex:VxWorks
  #+cindex:Windows
- Cross-platform: Android, *BSD, iOS, Linux, Mac, Solaris, VxWorks, and Windows
  (Win32, WinCE, WinRT) are supported out of the box.  Easy to port to other
  systems.

  #+cindex:public domain
- Sources are in the *public domain*.  Use for any purpose.

  #+cindex:command-line interface (CLI)
  #+cindex:CLI, command-line interface
- Comes with a standalone command-line interface (CLI) client that can be used
  to administer SQLite databases.

*** Self-Contained
#+cindex:self-contained
#+cindex:iPhone
#+cindex:Android
#+cindex:game consoles
#+cindex:handheld media players
"SQLite is self-contained" means it requires minimal support from the operating
system or external library.  This makes SQLite usable in any environments---
especially in embedded devices like iPhones, Android phones, game consoles,
handheld media players, etc.

#+cindex:ANSI-C
#+cindex:source files
#+cindex:compile into code
SQLite is developed using ANSI-C.  The source code is available as a big
~sqlite3.c~ and its header file ~sqlite3.h~.  If you want to develop an
application that uses SQLite, you just need to drop these files into your
project and compile it with your code.

*** Zero-configuration
#+cindex:zero configuration
#+cindex:configuration files, none
Because of the serverless architecture, you don’t need to “install” SQLite
before using it.  There is no server process that needs to be configured,
started, and stopped.

In addition, SQLite does not use any configuration files.

*** Transactional
#+cindex:transactions
#+cindex:ACID-compliant
#+cindex:atomic
#+cindex:consistent
#+cindex:isolated
#+cindex:durable
All transactions in SQLite are fully ACID-compliant.  It means all queries and
changes are Atomic, Consistent, Isolated, and Durable.  In other words, all
changes within a transaction take place completely or not at all even when an
unexpected situation like application crash, power failure, or operating system
crash occurs.

*** SQLite distinctive features
#+cindex:dynamic types
#+cindex:data types, dynamic
SQLite uses dynamic types for tables.  It means you can store any value in any
column, regardless of the data type.

#+cindex:single database connection
#+cindex:connection, single
SQLite allows a single database connection to access multiple database files
simultaneously.  This brings many nice features like joining tables in different
databases or copying data between databases in a single command.

#+cindex:in-memory database
SQLite is capable of creating in-memory databases which are very fast to work
with.

*** SQLite is NOT Client-Server SQL
SQLite is not directly comparable to client/server SQL database engines such as
MySQL, Oracle, PostgreSQL, or SQL Server since SQLite is trying to solve a
different problem.

#+cindex:shared repository
*Client/server SQL database engines* strive to implement a /shared repository/ of
enterprise data.  They emphasize 
- scalability,
- concurrency,
- centralization, and
- control.


#+cindex:local data storage
*SQLite* strives to provide /local data storage/ for individual applications
and devices.  SQLite emphasizes 
- economy,
- efficiency,
- reliability,
- independence, and
- simplicity.


#+cindex:@code{fopen()}
SQLite does not compete with client/server databases.  SQLite competes with
~fopen()~.

** Use Cases for SQLite

For device-local storage with low writer concurrency and less than a terabyte
of content, SQLite is almost always a better solution than using a
client-server RDBMS.  SQLite is fast and reliable and it requires no
configuration or maintenance.  It keeps thing simple.  SQLite "just works".

#+cindex:use cases
#+cindex:embedded devices
- Embedded devices and the internet of things ::


  #+cindex:application file format
- Application file format ::

     SQLite is often used as the on-disk file format for desktop applications
     such as:

  - version control systems,

  - financial analysis tools,

  - media cataloging and editing suites,

  - CAD packages,

  - record keeping programs,

    #+cindex:@code{sqlite3_open()}
    #+cindex:File/Open operation
    #+cindex:File/Save menu
    and so forth.  The traditional File/Open operation calls ~sqlite3_open()~
    to attach to the database file.  Updates happen automatically as
    application content is revised so the File/Save menu option becomes
    superfluous.  The =File/Save_As= menu option can be implemented using the
    backup API.  There are many benefits to this approach, including improved
    performance, reduced cost and complexity, and improved reliability.

  #+cindex:websites
- Websites ::

              SQLite works great as the database engine for most low to medium
              traffic websites (which is to say, most websites).  The amount of
              web traffic that SQLite can handle depends on how heavily the
              website uses its database.  Generally speaking, any site that
              gets fewer than 100K hits/day should work fine with SQLite.  The
              100K hits/day figure is a conservative estimate, not a hard upper
              bound.  SQLite has been demonstrated to work with 10 times that
              amount of traffic.

  #+cindex:data analysis
- Data analysis ::

                   #+cindex:command-line shell
                   #+cindex:TCL
                   #+cindex:Python
                   #+cindex:R
                   People who understand SQL can employ the sqlite3
                   command-line shell (or various third-party SQLite access
                   programs) to analyze large datasets.  Raw data can be
                   imported from CSV files, then that data can be sliced and
                   diced to generate a myriad of summary reports.  More complex
                   analysis can be done using simple scripts written in Tcl or
                   Python (both of which come with SQLite built-in) or in R or
                   other languages using readily available adaptors.

                   The same thing can be done with an enterprise client/server
                   database, of course.  The advantage of SQLite is that it is
                   easier to install and use and the resulting database is a
                   single file that can be written to a USB memory stick or
                   emailed to a colleague.

- Cache for enterprise data ::

  #+cindex:server-side database
- Server-side database ::

     #+cindex:data store
     Systems designers report success using SQLite as a data store on server
     applications running in the datacenter, or in other words, using SQLite as
     the underlying storage engine for an application-specific database server.

     With this pattern, the overall system is still client/server: clients send
     requests to the server and get back replies over the network. But instead
     of sending generic SQL and getting back raw table content, the client
     requests and server responses are high-level and application-specific. The
     server translates requests into multiple SQL queries, gathers the results,
     does post-processing, filtering, and analysis, then constructs a
     high-level reply containing only the essential information.

- Data transfer format ::

     #+cindex:cross-platform format
     Because an SQLite database is a single compact file in a well-defined
     cross-platform format, it is often used as a container for transferring
     content from one system to another.  The sender gathers content into an
     SQLite database file, transfers that one file to the receiver, then the
     receiver uses SQL to extract the content as needed.

  #+cindex:file archive
- File archive and/or data container ::

     #+cindex:SQLite Archive
     #+cindex:ZIP archives
     #+cindex:incremental update
     #+cindex:metadata, rich
     The [[https://www.sqlite.org/sqlar.html][SQLite Archive]] idea shows how SQLite can be used as a substitute for
     ZIP archives or Tarballs.  An archive of files stored in SQLite is only
     very slightly larger, and in some cases actually smaller, than the
     equivalent ZIP archive.  And an SQLite archive features incremental and
     atomic updating and the ability to store much richer metadata.

     #+cindex:network transfer
     SQLite is a good solution for any situation that requires bundling diverse
     content into a self-contained and self-describing package for shipment
     across a network.  Content is encoding in a well-defined, cross-platform,
     and stable file format.  The encoding is efficient, and receivers can
     extract small subsets of the content without having to read and parse the
     entire file.

  #+cindex:disk files, ad hoc
- Replacement for ad hoc disk files ::


  #+cindex:internal database
- Internal or temporary databases ::

     For programs that have a lot of data that must be sifted and sorted in
     diverse ways, it is often easier and quicker to load the data into an
     in-memory SQLite database and use queries with joins and ORDER BY clauses
     to extract the data in the form and order needed rather than to try to
     code the same operations manually.  Using an SQL database internally in
     this way also gives the program greater flexibility since new columns and
     indices can be added without having to recode every query.

- Stand-in for an enterprise database during demos or testing ::


- Education and Training ::


- Experimental SQL language extensions ::

** Download and Install SQLite

#+cindex:download SQLite
#+cindex:install SQLite
*Summary*: This tutorial shows you step by step how to download and install
SQLite on your computer.

{{{heading(Download SQLite)}}}

1. First, go to the https://www.sqlite.org website.
2. Second, open the download page https://www.sqlite.org/download.html


#+cindex:platforms
SQLite provides various versions for various platforms e.g., Windows, Linux,
and Mac.  You should choose an appropriate version to download.

{{{heading(Install SQLite)}}}

#+cindex:install SQLite
#+cindex:@file{sqlite3.exe}
1. First, create a new folder e.g., ~/usr/local/sqlite~.
2. Second, extract the content of the file that you downloaded in the previous
   section to the ~/usr/local/sqlite~ folder.  You should see the ~sqlite3.exe~
   is in the ~/usr/local/sqlite~ folder.


{{{subheading(Working With the Installation)}}}

1. First, open the command line window and navigate to the ~/usr/local/sqlite~
   folder.

2. Second, type =sqlite3= and press enter, you should see the following output:

   #+begin_example
   ? sqlite3
   SQLite version 3.28.0 2019-04-16 19:49:53
   Enter ".help" for usage hints.
   Connected to a transient in-memory database.
   Use ".open FILENAME" to reopen on a persistent database.
   sqlite>
   #+end_example

3. Third, you can type the ~.help~ command from the =sqlite>= prompt to see all
   available commands in sqlite3.

   #+begin_example
   sqlite> .help
   .archive ...             Manage SQL archives
   .auth ON|OFF             Show authorizer callbacks
   .backup ?DB? FILE        Backup DB (default "main") to FILE
   .bail on|off             Stop after hitting an error.  Default OFF
   .binary on|off           Turn binary output on or off.  Default OFF
   .cd DIRECTORY            Change the working directory to DIRECTORY
   .changes on|off          Show number of rows changed by SQL
   .check GLOB              Fail if output since .testcase does not match
   .clone NEWDB             Clone data into NEWDB from the existing database
   .databases               List names and files of attached databases
   .dbconfig ?op? ?val?     List or change sqlite3_db_config() options
   .dbinfo ?DB?             Show status information about the database
   .dump ?TABLE? ...        Render all database content as SQL
   .echo on|off             Turn command echo on or off
   .eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN
   .excel                   Display the output of next command in a spreadsheet
   .exit ?CODE?             Exit this program with return-code CODE
   .expert                  EXPERIMENTAL. Suggest indexes for specified queries
   .fullschema ?--indent?   Show schema and the content of sqlite_stat tables
   .headers on|off          Turn display of headers on or off
   .help ?-all? ?PATTERN?   Show help text for PATTERN
   .import FILE TABLE       Import data from FILE into TABLE
   .imposter INDEX TABLE    Create imposter table TABLE on index INDEX
   .indexes ?TABLE?         Show names of indexes
   .limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT
   .lint OPTIONS            Report potential schema issues.
   .load FILE ?ENTRY?       Load an extension library
   .log FILE|off            Turn logging on or off.  FILE can be stderr/stdout
   .mode MODE ?TABLE?       Set output mode
   .nullvalue STRING        Use STRING in place of NULL values
   .once (-e|-x|FILE)       Output for the next SQL command only to FILE
   .open ?OPTIONS? ?FILE?   Close existing database and reopen FILE
   .output ?FILE?           Send output to FILE or stdout if FILE is omitted
   .parameter CMD ...       Manage SQL parameter bindings
   .print STRING...         Print literal STRING
   .progress N              Invoke progress handler after every N opcodes
   .prompt MAIN CONTINUE    Replace the standard prompts
   .quit                    Exit this program
   .read FILE               Read input from FILE
   .restore ?DB? FILE       Restore content of DB (default "main") from FILE
   .save FILE               Write in-memory database into FILE
   .scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off
   .schema ?PATTERN?        Show the CREATE statements matching PATTERN
   .selftest ?OPTIONS?      Run tests defined in the SELFTEST table
   .separator COL ?ROW?     Change the column and row separators
   .sha3sum ...             Compute a SHA3 hash of database content
   .shell CMD ARGS...       Run CMD ARGS... in a system shell
   .show                    Show the current values for various settings
   .stats ?on|off?          Show stats or turn stats on or off
   .system CMD ARGS...      Run CMD ARGS... in a system shell
   .tables ?TABLE?          List names of tables matching LIKE pattern TABLE
   .testcase NAME           Begin redirecting output to 'testcase-out.txt'
   .timeout MS              Try opening locked tables for MS milliseconds
   .timer on|off            Turn SQL timer on or off
   .trace ?OPTIONS?         Output each SQL statement as it is run
   .vfsinfo ?AUX?           Information about the top-level VFS
   .vfslist                 List all available VFSes
   .vfsname ?AUX?           Print the name of the VFS stack
   .width NUM1 NUM2 ...     Set column widths for "column" mode
   sqlite>
   #+end_example

- Fourth, to quit the =sqlite>=, you use  ~.quit~ command.

** The SQLite Studio GUI Tool

*** About SQLite Studio
#+cindex:SQLite Studio GUI tool
#+cindex:GUI tool
- [[https://github.com/pawelsalawa/sqlitestudio/wiki][Wiki]]
- [[https://github.com/pawelsalawa/sqlitestudio/wiki/User_Manual][User Manual]]

SQLiteStudio is a SQLite database manager with the following features:

- Portable :: no need to install or uninstall. Just download, unpack and run.
- Intuitive interface ::
- Powerful, yet light and fast ::
- All SQLite3 and SQLite2 features wrapped within simple GUI ::
- Cross-platform :: runs on Windows 9x/2k/XP/2003/Vista/7, Linux, MacOS X and
  should work on other Unixes (not tested yet)
- Exporting to various formats :: SQL statements, CSV, HTML, XML, PDF, JSON
- Importing data from various formats :: CSV, custom text files [regular
  expressions]
- Numerous small additions :: like formatting code, history of queries executed
     in editor windows, on-the-fly syntax checking, and more,
- Unicode support ::
- Skinnable :: interface can look native for Windows 9x/XP, KDE, GTK, Mac OS X,
               or draw widgets to fit for other environments, WindowMaker,
               etc),
- Configurable colors, fonts and shortcuts ::
- Open source and free :: Released under GPLv3 license

*** Install the SQLite GUI Tool
#+cindex:GUI tool
#+cindex:SQLite Studio
In this tutorial, we would like to introduce you to a free GUI tool for
managing SQLite databases named [[http://sqlitestudio.pl/][SQLite Studio]].  The SQLite studio is free,
portable, intuitive, and cross-platform.  It also provides some of the most
important features to work with SQLite databases such as importing, exporting
data in various formats including CSV, XML, and JSON.

You can download the SQLite studio at the homepage of SQLite, extract the file
into a folder e.g., ~/usr/local/sqlite/gui/~ and run it.

** The SQLite Sample Database
- http://www.sqlitetutorial.net/sqlite-sample-database/

*Summary*: in this tutorial, we first introduce you to an SQLite sample
database.  Then, we will give you the links to download the sample database and
its diagram.  At the end of the tutorial, we will show you how to connect to
the sample database using the ~sqlite3~ tool.

*** Introduction to chinook SQLite sample database
#+cindex:@file{chinook.db}
#+cindex:sample database, @file{chinook.db}
We provide you with the SQLite sample database named =chinook=.  The =chinook=
sample database is a good database for practicing with SQL, especially SQLite.

The following database diagram illustrates the chinook database tables and
their relationships.

#+caption:The Chinook Database Tables and Relationships
#+name:fig:chinook-db-tables
[[file:figs/sqlite-sample-database-color.jpg]]

{{{heading(The Tables)}}}

#+cindex:@file{chinook.db} tables
There are 11 tables in the chinook sample database.

- =employees= ::

                 #+cindex:employees
                 stores employees data such as employee id, last name, first
                 name, etc.  It also has a field named =ReportsTo= to specify
                 who reports to whom.

- =customers= ::

                 #+cindex:customers
                 stores customers data.

- =invoices= & =invoice_items= ::

     #+cindex:invoices
     #+cindex:invoice_items
     these two tables store invoice data.  The =invoices= table stores invoice
     header data and the =invoice_items= table stores the invoice line items
     data.

- =artists= ::

               #+cindex:artists
               stores artists data.  It is a simple table that contains only
               artist id and name.

- =albums= ::

              #+cindex:albums
              stores data about a list of tracks.  Each album belongs to one
              artist.  However, one artist may have multiple albums.

- =media_types= ::

                   #+cindex:media_types
                   stores media types such as MPEG audio and AAC audio file.

- =genres= ::

              #+cindex:genres
              stores music types such as rock, jazz, metal, etc.

- =tracks= ::

              #+cindex:tracks
              store the data of songs.  Each track belongs to one album.

- =playlists= & =playlist_track= ::

     #+cindex:playlists
     #+cindex:playlist_tracks
     =playlists= table store data about playlists.  Each playlist contains a
     list of tracks.  Each track may belong to multiple playlists.  The
     relationship between the =playlists= table and =tracks= table is
     many-to-many.  The =playlist_track= table is used to reflect this
     relationship.

*** Download the SQLite Sample Database
#+cindex:@file{chinook.db} download
#+cindex:download @file{chinook.db}
You can download the SQLite sample database using the following link:

- [[http://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip][Download SQLite Sample Database]]

*** Connect to SQLite Sample Database

#+cindex:connect to sample database
The name of the file is ~chinook.db~.

- Navigate to the SQLite installation directory (~/usr/local/sqlite/~) where
  the ~sqlite3.exe~ file is located.

- Second, you use the following command to connect to the =chinook= sample
  database located in the ~db/~ folder, which is a subfolder of the ~sqlite/~
  folder:
  : sqlite3 db/chinook.db
  : sqlite>

- Third, you can try a simple command e.g., ~.tables~ to view all the tables
  available in the sample database:
  : sqlite> .tables

   #+begin_example
   ? sqlite3 db/chinook.db
   SQLite version 3.28.0 2019-04-16 19:49:53
   Enter ".help" for usage hints.
   sqlite> .tables
   albums          employees       invoices        playlists
   artists         genres          media_types     tracks
   customers       invoice_items   playlist_track
   sqlite>
   #+end_example

** Commands Tutorial
- http://www.sqlitetutorial.net/sqlite-commands/

  #+cindex:@command{sqlite3} command-line tool
*Summary*: in this tutorial, we will introduce you to the most commonly used
SQLite commands of the ~sqlite3~ command line program.

The SQLite project delivers a simple command-line tool named ~sqlite3~ (or
~sqlite3.exe~ on Windows) that allows you to interact with the SQLite databases
using SQL statements and commands.

*** Connect to an SQLite database
To start the ~sqlite3~, you type the ~sqlite3~ as follows:

#+begin_src sh
>sqlite3
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
#+end_src

#+cindex:in-memory database
By default, an SQLite session uses the in-memory database; therefore all
changes will be gone when the session ends.

#+cindex:connect to database file
#+cindex:@command{.open} command
To open a database file, you use the ~.open FILENAME~ command.  The following
statement opens the ~chinook.db~ database:

: sqlite> .open c:\sqlite\chinook.db

#+cindex:open database file
#+cindex:database file, open
If you want to open a specific database file when you connect to the SQlite
database, you use the following command:

#+begin_src sh
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

If you start a session with a database name that does not exist, the ~sqlite3~
tool will create the database file.

For example, the following command creates a database named sales in the
C:\sqlite\ directory:

#+begin_src sh
>sqlite3 c:\sqlite\sales.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

*** Show all available commands and their purposes
#+cindex:@command{.help} command
To show all available commands and their purpose, you use the ~.help~ command
as follows:

: .help

*** Show databases in the current database connection
#+cindex:@command{.databases} command
#+cindex:~code{main} database
To show all databases in the current connection, you use the ~.databases~
command.  The ~.databases~ command displays at least one database with the
name: ~main~.

For example, the following command shows all the databases of the current
connection:

#+begin_src sql
sqlite> .database
seq  name             file
---  ---------------  --------------------------
0    main             c:\sqlite\sales.db
sqlite>
#+end_src

#+cindex:@command{ATTACH DATABASE} statement
To add an additional database in the current connection, you use the =ATTACH
DATABASE= statement.  The following statement adds the =chinook= database to
the current connection.

: sqlite> ATTACH DATABASE "c:\sqlite\chinook.db" AS chinook;

Now if you run the ~.database~ command again, the ~sqlite3~ returns two
databases: =main= and =chinook=.

#+begin_src sql
sqlite> .databases
seq  name             file
---  ---------------  ---------------------
0    main             c:\sqlite\sales.db
2    chinook          c:\sqlite\chinook.db
#+end_src

*** Exit sqlite3 tool
#+cindex:@command{.exit} command
To exit the ~sqlite3~ program, you use the ~.exit~ command.

: sqlite>.exit

*** Show tables in a database
#+cindex:@command{.tables} command
To display all the tables in the current database, you use the ~.tables~
command.  The following commands open a new database connection to the
=chinook= database and display the tables in the database.

#+begin_src sql
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite> .tables
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
sqlite>
#+end_src

#+cindex:@command{.table} pattern command
#+cindex:@command{LIKE} operator
If you want to find tables based on a specific pattern, you use the ~.table~
pattern command.  The ~sqlite3~ uses the =LIKE= operator for pattern matching.

For example, the following statement returns the table that ends with the
string =es=.

#+begin_src sql
sqlite> .table '%es'
employees    genres       invoices     media_types
sqlite>
#+end_src

*** Show the structure of a table
#+cindex:@command{.schema} command
To display the structure of a table, you use the ~.schema TABLE~ command.  The
=TABLE= argument could be a pattern.  If you omit it, the ~.schema~ command will
show the structures of all the tables.

The following command shows the structure of the =albums= table.

#+begin_src sql
sqlite> .schema albums
CREATE TABLE "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON "albums" ([ArtistId]);
sqlite>
#+end_src

#+cindex:@command{.fullschema} command
To show the schema and the content of the =sqlite_stat= tables, you use the
~.fullschema~ command.

: sqlite>.fullschema

*** Show indexes
#+cindex:@command{.indexes} command
To show all indexes of the current database, you use the ~.indexes~ command as
follows:

#+begin_src text
sqlite> .indexes
IFK_AlbumArtistId
IFK_CustomerSupportRepId
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
IFK_InvoiceLineInvoiceId
IFK_InvoiceLineTrackId
IFK_PlaylistTrackTrackId
IFK_TrackAlbumId
IFK_TrackGenreId
IFK_TrackMediaTypeId
#+end_src

To show the indexes of a specific table, you use the ~.indexes TABLE~ command.
For example, to show indexes of the =albums= table, you use the following
command:

#+begin_src text
sqlite> .indexes albums
IFK_AlbumArtistId
#+end_src

#+cindex:@command{LIKE} operator
To show indexes of the tables whose names end with =es=, you use a pattern of
the =LIKE= operator.

#+begin_src text
sqlite> .indexes %es
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
#+end_src

*** Save the result of a query into a file
#+cindex:@command{.output} command
#+cindex:@command{.once} command
To save the result of a query into a file, you use the ~.output FILENAME~
command.  Once you issue the ~.output~ command, all the results of the
subsequent queries will be saved to the file that you specified in the
=FILENAME= argument.  If you want to save the result of the next single query
only to the file, you issue the ~.once FILENAME~ command.

To display the result of the query to the standard output again, you issue the
~.output~ command without arguments.

The following commands select the title from the albums table and write the
result to the ~albums.txt~ file.

#+begin_src sql
sqlite> .output albums.txt
sqlite> SELECT title FROM albums;
#+end_src

*** Execute SQL statements from a file
Suppose we have a file named ~commands.txt~ in the ~c:/sqlite/~ folder with the
following content:

#+begin_src sql
SELECT albumid, title
FROM albums
ORDER BY title
LIMIT 10;
#+end_src

To execute the SQL statements in the ~commands.txt~ file, you use the ~.read
FILENAME~ command as follows:

#+begin_src text
sqlite> .mode column
sqlite> .read c:/sqlite/commands.txt
156         ...And Justice For All
257         20th Century Masters -
296         A Copland Celebration,
94          A Matter of Life and D
95          A Real Dead One
96          A Real Live One
285         A Soprano Inspired
139         A TempestadeTempestade
203         A-Sides
160         Ace Of Spades
#+end_src

* Basic SQLite tutorial
This section presents basic SQL statements that you can use with SQLite.  You
will first start querying data from the [[http://www.sqlitetutorial.net/sqlite-sample-database/][sample database]].

** Simple query
- http://www.sqlitetutorial.net/sqlite-select/

  #+cindex:SELECT statement
- SQLite Select ::

     - http://www.sqlitetutorial.net/sqlite-select/

     query data from a single table


#+cindex:@command[SELECT} statement
*Summary*: in this tutorial, you will learn how to use SQLite =SELECT=
statement to query data from a single table.

The =SELECT= statement is the most commonly used statements in SQL.  The SQLite
=SELECT= statement provides all features of the =SELECT= statement in SQL
standard.

*** Simple uses of =SELECT= statement
You can use the =SELECT= statement to perform a simple calculation as follows:

#+begin_src sql
SELECT
 1 + 1;
#+end_src

#+cindex:expessions, multiple, @command{SELECT}
You can use multiple expressions in the SELECT statement as follows:

#+begin_src sql
SELECT
 10 / 5, 2 * 4 ;
#+end_src

*** Querying data from a table using the =SELECT= statement
We often use the =SELECT= statement to query data from one or more table.  The
syntax of the =SELECT= statement is as follows:

#+begin_src sql
SELECT DISTINCT column_list
FROM table_list
  JOIN table ON join_condition
WHERE row_filter
ORDER BY column
LIMIT count OFFSET offset
GROUP BY column
HAVING group_filter;
#+end_src

The =SELECT= statement is the most complex statement in SQLite.  To help easier
to understand each part, we will break the =SELECT= statement into multiple
easy-to-understand tutorials.

#+cindex:@command{ORDER BY} clause
#+cindex:sort result set
- Use =ORDER BY= clause to sort the result set

  #+cindex:@command{DISTINCT} clause
  #+cindex:query unique rows
- Use =DISTINCT= clause to query unique rows in a table

  #+cindex:@command{WHERE} clause
  #+cindex:filter rows
- Use =WHERE= clause to filter rows in the result set

  #+cindex:@command{LIMIT OFFSET} clause
  #+cindex:constrain number of rows
- Use =LIMIT OFFSET= clauses to constrain the number of rows returned

  #+cindex:@command{INNER JOIN}
  #+cindex:@command{LEFT JOIN}
  #+cindex:query data from multiple tables
  #+cindex:join
- Use =INNER JOIN= or =LEFT JOIN= to query data from multiple tables using
  join.

  #+cindex:@command{GROUP BY}
  #+cindex:groups
  #+cindex:aggregrate function
- Use =GROUP BY= to get the group rows into groups and apply aggregate function
  for each group.

  #+cindex:{HAVING} clause
  #+cindex:filter groups
- Use =HAVING= clause to filter groups


#+cindex:query data from single table
#+cindex:@command{FROM} clause, with @command{SELECT} clause
In this tutorial, we are going to focus on the simplest form of the =SELECT=
statement that allows you to query data from a single table.

#+begin_src sql
SELECT column_list
FROM table;
#+end_src

Even if the =SELECT= clause appears before the =FROM= clause, SQLite evaluates
the =FROM= clause first and then the =SELECT= clause; therefore:

#+cindex:@command{FROM} clause
- First, you specify the table where you want to get data from in the =FROM=
  clause.  Notice that you can have more than one table in the =FROM= clause.
  We will discuss it in the subsequent tutorial.

  #+cindex:column, specify using @command{SELECT}
  #+cindex:@command{SELECT} clause
- Second, you specify a column or a list of comma-separated columns in the
  =SELECT= clause.


You use the semicolon (=;=) to terminate the statement.

*** SQLite =SELECT= examples
Let’s take a look at the =tracks= table in the sample database.

[[file:figs/tracks.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/tracks.png]]

The =tracks= table contains columns and rows.  It looks like a spreadsheet.

[[file:figs/Tracks-Table-data.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/Tracks-Table-data.jpg]]

To get data from the tracks table such as =trackid=, =track name=, =composer=,
and =unit price=, you use the following statement:

#+begin_src sql
SELECT
 trackid,
 name,
 composer,
 unitprice
FROM
 tracks;
#+end_src

You specify a list column names, which you want to get data, in the =SELECT=
clause and the tracks table in the =FROM= clause.  SQLite returns the following
result:

[[file:figs/Tracks-Table-partial-data.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/Tracks-Table-partial-data.jpg]]

To get data from all columns, you specify the columns of the =tracks= table in
the =SELECT= clause as follows:

#+begin_src sql
SELECT
 trackid,
 name,
 albumid,
 mediatypeid,
 genreid,
 composer,
 milliseconds,
 bytes,
 unitprice
FROM
 tracks;
#+end_src

For a table with many columns, the query would be so long that time-consuming
to type.  To avoid this, you can use the asterisk (=*=), which is the shorthand
for all columns of the table as follows:

#+begin_src sql
SELECT
 *
FROM
 tracks;
#+end_src

The query is shorter and cleaner now.

However…

You should use the asterisk (=*=) for the testing purpose only, not in the real
application development.

Because…

When you develop an application, you should control what SQLite returns to your
application.  Suppose, a table has 3 columns, and you use the asterisk (=*=) to
retrieve the data from all three columns.

What if someone removes a column? Your application would not be working
properly, because it assumes that there are three columns returned and the
logic to process those three columns would be broken.

If someone adds more columns, your application may work but it gets more data
than needed, which creates more I/O overhead between the database and
application.

So try to avoid using the asterisk (=*=) as a good habit when you use the
=SELECT= statement.

** Sorting rows
- http://www.sqlitetutorial.net/sqlite-order-by/

- SQLite Order By ::

     sort the result set in ascending or descending order

#+cindex:@command{ORDER BY} clause
#+cindex:sort result set, @command{ORDER BY}
*Summary*: in this tutorial, you will learn how to sort the result set using
SQLite =ORDER BY= clause.

*** Introduction to SQLite =ORDER BY= clause
SQLite stores rows in a table in an unspecified order.  It means that the rows
in the table may or may not be in the order that they were inserted.

If you use the =SELECT= statement to query data from a table, the order of rows
in the result set is unspecified.  To sort the result set, you add the =ORDER
BY= clause in the =SELECT= statement as follows:

#+begin_src sql
SELECT
 column_list
FROM
 table
ORDER BY
 column_1 ASC,
 column_2 DESC;
#+end_src

The =ORDER BY= clause comes after the =FROM= clause.  The =ORDER BY= clause
allows you to sort the result set based on one or more columns in different
orders: ascending and descending.

#+cindex:@command{ASC} keyword
#+cindex:@command{DESC} keyword
#+cindex:ascending order
#+cindex:descending order
#+cindex:order of sert, ascending or descending
You put the column name that you want to use to sort after the =ORDER BY=
clause followed by the =ASC= or =DESC= keyword.  The =ASC= keyword means
ascending order, and =DESC= keyword means descending orders.

If you don’t specify the =ASC= or =DESC= keyword, SQLite uses =ASC= or
ascending order by default.

#+cindex:sort multiple columns
In case you want to sort the result set by multiple columns, you use a comma
(=,=) to separate columns.  The =ORDER BY= clause sorts rows using columns from
left to right.  In other words, the =ORDER BY= clause sorts the rows using the
first column in the list.  Then, it sorts the sorted rows using the second
column, and so on.

You can sort the result set using a column that does not appear in the column
list of the =SELECT= clause.

#+cindex:@code{NULL} value
SQLite processes =NULL= value differently.  A row with a =NULL value is higher
than rows with regular values in ascending order, and it is reversed for
descending order.

*** SQLite =ORDER BY= clause example
Let’s take the =tracks= table in the sample database for the demonstration.

[[file:figs/tracks.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/tracks.png]]

Suppose, you want to get data from =name=, =milliseconds=, and =album id=
columns, you use the following statement:

#+begin_src sql
SELECT
 name,
 milliseconds,
 albumid
FROM
 tracks;
#+end_src

[[file:figs/tracks-table-data-without-sorting.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/tracks-table-data-without-sorting.jpg]]

The =SELECT= statement that does not use =ORDER BY= clause returns a result set
that is not in any order.

Suppose you want to sort the result set based on =AlbumId= column in ascending
order, you use the following statement:

#+begin_src sql
SELECT
 name,
 milliseconds,
 albumid
FROM
 tracks
ORDER BY
 albumid ASC;
#+end_src

[[file:figs/SQLite-ORDER-BY-example.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-ORDER-BY-example.jpg]]

The result set now is sorted by the =AlbumId= column in ascending order as
shown in the screenshot.

SQLite uses =ASC= by default so you can omit it in the above statement as
follows:

#+begin_src sql
SELECT
 name,
 milliseconds, 
 albumid
FROM
 tracks
ORDER BY
 albumid;
#+end_src

Suppose you want to sort the sorted result (by =AlbumId=) above by the
=Milliseconds= column in descending order.  In this case, you need to add the
=Milliseconds= column to the =ORDER BY= clause as follows:

#+begin_src sql
SELECT
 name,
 milliseconds, 
 albumid
FROM
 tracks
ORDER BY
 albumid ASC,
 milliseconds DESC;
#+end_src

[[file:figs/SQLite-ORDER-BY-multiple-columns-example.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-ORDER-BY-multiple-columns-example.jpg]]

SQLite sorts rows by =AlbumId= column in ascending order first.  Then, it sorts
the sorted result set by the =Milliseconds= column in descending order.

If you look at the tracks of the album with =AlbumId= 1, you find that the order
of tracks changes between the two statements.

*** SQLite =ORDER BY= with the column position

Instead of specifying the names of columns, you can use the column’s position
in the =ORDER BY= clause.

For example, the following statement sorts the tracks by both =AlbumId= and
=Milliseconds= in ascending order.

#+begin_src sql
SELECT
 name,
 milliseconds, 
 albumid
FROM
 tracks
ORDER BY
 3,2;
#+end_src

The number 3 and 2 refers to the =AlbumId= and =Milliseconds= in the column
list that appears in the =SELECT= clause.

[[file:figs/SQLite-ORDER-BY-multiple-columns-by-positions.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-ORDER-BY-multiple-columns-by-positions.jpg]]

** Filtering data
*** SQLite Select Distinct
- http://www.sqlitetutorial.net/sqlite-select-distinct

- query unique rows from a table using the [[http://www.sqlitetutorial.net/sqlite-select-distinct][=DISTINCT=]] clause.

#+cindex:@code{SELECT DISTINCT} clause
*Summary*: in this tutorial, you will learn how to use the SQLite =SELECT
DISTINCT= clause to remove duplicate rows in the result set.

**** Introduction to SQLite =SELECT DISTINCT= clause
The =DISTINCT= clause is an optional clause of the =SELECT= statement.  The
=DISTINCT= clause allows you to remove the duplicate rows in the result set.

The following statement illustrates the syntax of the DISTINCT clause:

#+begin_src sql
SELECT DISTINCT
 column_list
FROM
 table;
#+end_src

The =DISTINCT= clause must appear after the =SELECT= clause.

You put a column or a list of columns after the =DISTINCT= clause.  If you use
one column, SQLite uses that column to evaluate the duplicate.  In case you use
multiple columns, SQLite uses the combination of those columns to evaluate the
duplicate.

SQLite considers =NULL= values as duplicates.  If you use the =DISTINCT= clause
with a column that has =NULL= values, SQLite will keep one row of a =NULL=
value.

**** SQLite =SELECT DISTINCT= examples

**** SQLite =SELECT DISTINCT= on multiple columns
The following statement gets all the cities and countries of all customers.

#+begin_src sql
SELECT
 city,
 country
FROM
 customers
ORDER BY
 country;
#+end_src

[[file:figs/SQLite-DISTINCT-multiple-columns.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-DISTINCT-multiple-columns.jpg]]

The result set contains duplicate city and country e.g., Sao Paulo in Brazil as
shown in the screenshot above.

To remove duplicate city and country, you apply the =DISTINCT= clause to both
city and country columns as the shown in the following query:

#+begin_src sql
SELECT  DISTINCT
 city,
 country
FROM
 customers
ORDER BY
 country;
#+end_src

As mentioned earlier, SQLite uses the combination of city and country to
evaluate the duplicate.

**** SQLite SELECT DISTINCT with NULL values example

To find the names of companies of our customers, you query data from company
column of the =customers= table.

#+begin_src sql
SELECT
 company
FROM
 customers;
#+end_src

It returns 59 rows with many =NULL= values.

Now, if you apply the =DISTINCT= clause to the statement, it will keep only one
row with a =NULL= value.

#+begin_src sql
SELECT DISTINCT
 company
FROM
 customers;
#+end_src

[[file:figs/SQLite-SELECT-with-DISTINCT-NULL-values.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-SELECT-with-DISTINCT-NULL-values.jpg]]

The statement returns 11 rows with one =NULL= value.

*** SQLite Where
- http://www.sqlitetutorial.net/sqlite-where/

- filter rows of a result set using various conditions


*Summary*: in this tutorial, you will learn how to use SQLite =WHERE= clause to
specify the search condition for rows returned by the query.

**** Introduction to SQLite =WHERE= clause
#+cindex:@commnand{WHERE} clause
The =WHERE= clause is an optional clause of the =SELECT= statement.  It appears
after the =FROM= clause as the following statement:

#+begin_src sql
SELECT
 column_list
FROM
 table
WHERE
 search_condition;
#+end_src

#+cindex:filter data using @command{WHERE} clause
#+cindex:predicate list, @command{HWERE} clause
You add a =WHERE= clause to the =SELECT= statement to filter data returned by
the query.  The =WHERE= clause is also known as a set of conditions or a
predicate list.

When evaluating a SELECT statement with a WHERE clause, SQLite uses the
following steps:

1. First, check the table in the =FROM= clause.

2. Second, evaluate the conditions in the =WHERE= clause to get the rows that
   met the conditions.

3. Third, make the final result set based on the rows in the previous step with
   columns in the =SELECT= clause.


The search condition in the =WHERE= has the following form:

: left_expression COMPARISON_OPERATOR right_expression

For example, you can form a search condition as follows:

#+cindex:@command{IN}
#+cindex:@command{LIKE}
#+cindex:@command{BETWEEN}
#+begin_src sql
WHERE column_1 = 100;

WHERE column_2 IN (1,2,3);

WHERE column_3 LIKE 'An%';

WHERE column_4 BETWEEN 10 AND 20;
#+end_src

#+cindex:@command{UPDATE} statement
#+cindex:@command{DELETE}
Besides the =SELECT= statement, you can use the =WHERE= clause in the =UPDATE=
and =DELETE= statements.

**** SQLite comparison operators
#+cindex:comparison operator
A comparison operator tests if two expressions are the same.  The following
table illustrates the comparison operators that you can use to construct
expressions.

| Operator | Meaning                  |
|----------+--------------------------|
| =        | Equal to                 |
| <> or != | Not equal to             |
| <        | Less than                |
| >        | Greater than             |
| <=       | Less than or equal to    |
| >=       | Greater than or equal to |
|----------+--------------------------|

**** SQLite logical operators
#+cindex:logical operators
Logical operators allow you to test the truth of some expressions.  A logical
operator returns 1, 0, or a =NULL= value.

Notice that SQLite does not provide Boolean data type therefore 1 means =TRUE=,
and 0 means =FALSE=.

The following table illustrates the SQLite logical operators:

| Operator | Meaning                                                                             |
|----------+-------------------------------------------------------------------------------------|
| ALL      | returns 1 if all expressions are 1.                                                 |
| AND      | returns 1 if both expressions are 1, and 0 if one of the expressions is 0.          |
| ANY      | returns 1 if any one of a set of comparisons is 1.                                  |
| BETWEEN  | returns 1 if a value is within a range.                                             |
| EXISTS   | returns 1 if a subquery contains any rows.                                          |
| IN       | returns 1 if a value is in a list of values.                                        |
| LIKE     | returns 1 if a value matches a pattern                                              |
| NOT      | reverses the value of other operators such as NOT EXISTS, NOT IN, NOT BETWEEN, etc. |
| OR       | returns true if either expression is 1                                              |
|----------+-------------------------------------------------------------------------------------|

**** SQLite =WHERE= clause examples
We will use the =tracks= table in the sample database to demonstrate how to use
the =WHERE= clause.

**** SQLite =WHERE= clause with =LIKE= operator example
#+cindex:@command{LIKE} operator
Sometimes, you may not remember exactly the data that you want to search.  In
this case, you perform an inexact search using the =LIKE= operator.

For example, to find which tracks composed by Smith, you use the =LIKE= operator
as follows:

#+begin_src sql
SELECT
 name,
 albumid,
 composer
FROM
 tracks
WHERE
 composer LIKE '%Smith%'
ORDER BY
 albumid;
#+end_src

**** SQLite =WHERE= clause with the =IN= operator example
#+cindex:@command{IN} operator
The =IN= operator allows you to check whether a value is in a list of
comma-separated list of values.  For example, to find tracks that have media
type id is 1 or 2, you use the =IN= operator as the following statement:

#+begin_src sql
SELECT
 name,
 albumid,
 mediatypeid
FROM
 tracks
WHERE
 mediatypeid IN (2, 3);
#+end_src

*** SQLite Limit
- http://www.sqlitetutorial.net/sqlite-limit/

- constrain the number of rows that you want to return.  The =LIMIT= clause
  helps you get the necessary data returned by a query.


*Summary*: in this tutorial, you will learn how to use SQLite =LIMIT= clause to
constrain the number of rows returned by a query.

**** Introduction to SQLite LIMIT clause
#+cindex:@command{LIMIT} clause
#+cindex:constrail number of rows, @command{LIMIT}
The =LIMIT= clause is an optional part of the =SELECT= statement.  You use the
=LIMIT= clause to constrain the number of rows returned by the query.

For example, a =SELECT= statement returns one million rows.  However, if you
just need the first 10 rows in the result set, you add the =LIMIT= clause to the
=SELECT= statement to get exact 10 rows.

The following illustrates the syntax of the =LIMIT= clause.

#+begin_src sql
SELECT
 column_list
FROM
 table
LIMIT row_count;
#+end_src

#+cindex:@code{row_count}
The =row_count= is a positive integer that specifies the number of rows
returned.

For example, to get the first 10 rows in the =tracks= table, you use the
following statement:

#+begin_src sql
SELECT
 trackId,
 name
FROM
 tracks
LIMIT 10;
#+end_src

#+cindex:@command{OFFSET} keyword
If you want to get the first 10 rows starting from the 10th row of the result
set, you use =OFFSET= keyword as the following:

#+begin_src sql
SELECT
 column_list
FROM
 table
LIMIT row_count OFFSET offset;
#+end_src

#+cindex:@command{LIMIT OFFSET} clause shorthand syntax
Or you can use the following shorthand syntax of the =LIMIT OFFSET= clause:

#+begin_src sql
SELECT
 column_list
FROM
 table
LIMIT offset, row_count;
#+end_src

For example, to get 10 rows starting from the 10th row in the =tracks= table, you
use the following statement:

#+begin_src sql
SELECT
 trackId,
 name
FROM
 tracks
LIMIT 10 OFFSET 10;
#+end_src

#+cindex:paginate result sets, @command{OFFSET}
You often find the uses of =OFFSET= in web applications for paginating result
sets.

**** SQLite =LIMIT= and =ORDER BY= clause
#+cindex:@command{LIMIT ORDER BY}
We typically use the =LIMIT= clause with =ORDER BY= clause, because we are
interested in getting the number of rows in a specified order, not in
unspecified order.

The =ORDER BY= clause appears before the =LIMIT= clause in the =SELECT=
statement.  SQLite sorts the result set before getting the number of rows
specified in the =LIMIT= clause.

#+begin_src sql
SELECT
 column_list
FROM
 table
ORDER BY
 column_1
LIMIT row_count;
#+end_src

For example, to get the top 10 largest tracks in bytes, you use the following
query:

#+begin_src sql
SELECT
 trackid,
 name,
 bytes
FROM
 tracks
ORDER BY
 bytes DESC
LIMIT 10;
#+end_src

To get 5 shortest tracks, you sort the tracks by length specified by
milliseconds column using =ORDER BY= clause and get first 5 rows using =LIMIT=
clause.

#+begin_src sql
SELECT
 trackid,
 name,
 milliseconds
FROM
 tracks
ORDER BY
 milliseconds ASC
LIMIT 5;
#+end_src

**** Getting the n^th highest and lowest values
#+cindex:nth highest, lowest
You can use the =ORDER BY= and =LIMIT= clauses to get the n^th highest or lowest
value row.  For example, you may want to know the second longest track, the
third smallest track, etc.

To do this, you use the following steps:

1. First, use =ORDER BY= to sort the result set in ascending order in case you
   want to get the n^th lowest value, or descending order if you want to get the
   n^th highest value.

2. Second, use the =LIMIT OFFSET= clause to get the n^th highest or the n^th
   lowest row.


The following statement returns the second longest track in the tracks table.

#+begin_src sql
SELECT
 trackid,
 name,
 milliseconds
FROM
 tracks
ORDER BY
 milliseconds DESC
LIMIT 1 OFFSET 1;
#+end_src

The following statement gets the third smallest track on the =tracks= table.

#+begin_src sql
SELECT
 trackid,
 name,
 bytes
FROM
 tracks
ORDER BY
 bytes
LIMIT 1 OFFSET 2;
#+end_src

*** SQLite BETWEEN
- http://www.sqlitetutorial.net/sqlite-between/

- test whether a value is in a range of values


*Summary*: in this tutorial, you will learn how to use the SQLite =BETWEEN=
operator to test whether a value is in a range of values.

**** Introduction to SQLite =BETWEEN= Operator
#+cindex:@command{BETWEEN} operator
#+cindex:range of values
The =BETWEEN= operator is a logical operator that tests whether a value is in
range of values.  If the value is in the specified range, the =BETWEEN=
operator returns =true=.  The =BETWEEN= operator can be used in the =WHERE=
clause of the =SELECT=, =DELETE=, =UPDATE=, and =REPLACE= statements.

The following illustrates the syntax of the SQLite =BETWEEN= operator:
: test_expression BETWEEN low_expression AND high_expression

In this syntax:

- =test_expression= is an expression to test for in the range defined by
  =low_expression= and =high_expression=.

- =low_expression= and =high_expression= is any valid expression that specify
  the low and high values of the range.  The =low_expression= should be less
  than or equal to =high_expression=, or the =BETWEEN= is always returns
  =false=.

  #+cindex:@command{AND} keyword
- The =AND= keyword is a placeholder which indicates the =test_expression=
  should be within the range specified by =low_expression= and
  =high_expression=.


Note that the BETWEEN operator is inclusive.  It returns =true= when the
=test_expression= is less than or equal to =high_expression= and greater than
or equal to the value of =low_expression=:
: test_expression >= low_expression AND test_expression <= high_expression

To specify an exclusive range, you use the greater than (=>=) and less than
operators (=<=).

Note that if any input to the =BETWEEN= operator is =NULL=, the result is
=NULL=, or unknown to be precise.

{{{heading(NOT BETWEEN Operator)}}}

#+cindex:@command{NOT BETWEEN} operator
To negate the result of the =BETWEEN= operator, you use the =NOT BETWEEN=
operator as follows:
: test_expression NOT BETWEEN low_expression AND high_expression

The =NOT BETWEEN= returns =true= if the value of =test_expression= is less than
the value of =low_expression= or greater than the value of =high_expression=:
: test_expression < low_expression OR test_expression > high_expression

**** SQLite =BETWEEN= operator examples

We will use the =invoices= table from the sample database for the
demonstration:

[[file:figs/invoices.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/invoices.png]]

***** SQLite =BETWEEN= numeric values example

The following statement finds invoices whose total is =BETWEEN= 14.96 and
18.86:

#+begin_src sql
SELECT
    InvoiceId,
    BillingAddress,
    Total
FROM
    invoices
WHERE
    Total BETWEEN 14.91 and 18.86    
ORDER BY
    Total; 
#+end_src

Here is the output:

[[file:figs/SQLite-BETWEEN-Numbers-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-BETWEEN-Numbers-example.png]]

***** SQLite =NOT BETWEEN= numeric values example

To find the invoices whose total are not between 1 and 20, you use the =NOT
BETWEEN= operator as shown in the following query:

#+begin_src sql
SELECT
    InvoiceId,
    BillingAddress,
    Total
FROM
    invoices
WHERE
    Total NOT BETWEEN 1 and 20
ORDER BY
    Total;
#+end_src

***** SQLite =BETWEEN= dates example

The following example finds invoices whose invoice dates are from January 1
2010 and January 31 2010:

#+begin_src sql
SELECT
    InvoiceId,
    BillingAddress,
    InvoiceDate,
    Total
FROM
    invoices
WHERE
    InvoiceDate BETWEEN '2010-01-01' AND '2010-01-31'
ORDER BY
    InvoiceDate;
#+end_src

*** SQLite IN
- http://www.sqlitetutorial.net/sqlite-in/

- check if a value matches any value in a list of value or subquery


#+cindex:@command{IN} operator
#+cindex:match values
*Summary*: in this tutorial, you will learn how to use the SQLite =IN= operator
to determine whether a value matches any value in a list of values or a
subquery.

**** Introduction to the SQLite =IN= operator
The SQLite =IN= operator is used to determine whether a value matches any value
in a list or a subquery.  The syntax of the =IN= operator is as follows:

: expression [NOT] IN (value_list|subquery);

The =expression= can be any valid expression.  It can be a column of a table.

A list of values is a fixed value list or a result set of one column returned
by a subquery.  The returned type of the expression and values in the list must
be the same.

#+cindex:@command[NOT IN} operator
The =IN= operator returns =true= or =false= depending on whether the expression
matches any value in a list of values or not.  To negate the list of values, you
use the =NOT IN= operator.

**** SQLite =IN= operator examples

We will use the =tracks= table in the sample database for the demonstration.

[[file:figs/tracks.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/tracks.png]]

The following statement uses the =IN= operator to query the tracks whose media
type id is 1 or 2.

#+begin_src sql
SELECT
 trackid,
 name,
 mediatypeid
FROM
 tracks
WHERE
 mediatypeid IN (1, 2)
ORDER BY
 name ASC;
#+end_src

[[file:figs/SQLite-IN-Operator.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-IN-Operator.jpg]]


#+cindex:@command[OR} operator
You can achieve the same result using the =OR= operator.

#+begin_src sql
SELECT
 trackid,
 name,
 MediaTypeId
FROM
 tracks
WHERE
 mediatypeid = 1 OR mediatypeid = 2
ORDER BY
 name ASC;
#+end_src

Using the =IN= operator is much shorter.  If you have a query that uses many
=OR= operators in an expression, you can use the =IN= operator to replace the
=OR= operators to make the query more readable.

**** SQLite =IN= operator with a subquery example
The following query returns a list of album id of the artist id 12:

#+begin_src sql
SELECT
 albumid
FROM
 albums
WHERE
 artistid = 12;
#+end_src

To get the tracks that belong to the artist id 12, you can combine the =IN=
operator with a subquery as follows:

#+begin_src sql
SELECT
 trackid,
 name,
 albumid
FROM
 tracks
WHERE
 albumid IN (
 SELECT
 albumid
 FROM
 albums
 WHERE
 artistid = 12
 );
#+end_src

[[file:figs/SQLite-IN-subquery-example.jpg][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-IN-subquery-example.jpg]]

*** SQLite Like
- http://www.sqlitetutorial.net/sqlite-like/

- query data based on pattern matching using wildcard characters: percent sign
  (=%=) and underscore (=_=)


*Summary*: in this tutorial, you will learn how to query data based on pattern
matching using SQLite LIKE operator.

**** Introduction to SQLite =LIKE= operator

Sometimes, you don’t know exactly the complete keyword that you want to
query.  For example, you may know that your most favorite song contains the
word, "elevator" but you don’t know exactly the name.

#+cindex:@command{LIKE} operator
To query data based on partial information, you use the SQLite =LIKE= operator
in the =WHERE= clause of the =SELECT= statement as follows:

#+begin_src sql
SELECT
 column_list
FROM
 table_name
WHERE
 column_1 LIKE pattern;
#+end_src

Note that you can also use the =LIKE= operator in the =WHERE= clause of other
statements such as =DELETE= and =UPDATE=.

There are two ways to construct a pattern: using percent sign =%= and
underscore =_= wildcards:

1. The percent sign =%= wildcard matches any sequence of zero or more
   characters.

2. The underscore =_= wildcard matches any single character.

**** The percent sign =%= wildcard examples
The percent sign =s%= matches any string that starts with =s=, e.g., =son=,
=so=, etc.  The =%er= pattern matches any string that ends with er e.g.,
=peter=, =clever=, etc.  And the =%per%= pattern matches any string that
contains =per= such as =percent=, =peeper=, etc.

**** The underscore =_= wildcard examples
The =h_nt= pattern matches =hunt=, =hint=, etc.  The =__pple= pattern matches
=topple=, =supple=, =tipple=, etc.


#+cindex:case sensitive, insensitive
#+cindex:Unicode
#+cindex:ASCII
#+cindex:@command{PRAGMA}, case sensitive
Note that SQLite =LIKE= operator is case-insensitive.  It means ="A" LIKE "a"=
is =true=.  However, for Unicode characters that are not in the ASCII range,
SQLite =LIKE= operator is case sensitive e.g., ="Ä" LIKE "ä"= is =false=.  In
case you want to make =LIKE= case sensitive, you use the following =PRAGMA=:

: PRAGMA case_sensitive_like = true;

**** SQLite =LIKE= and escape character
#+cindex:escape character
#+cindex:@command{ESCAPE} clause
If the pattern that you want to match contains =%= or =_=, you must use an
escape character in an optional =ESCAPE= clause as follows:

: column_1 LIKE pattern ESCAPE "escape_character";

For example, you want to find =get_value= in the table, you put the =_= as the
escape character like the following expression:

: column_1 LIKE '%get_value%' ESCAPE '_';

**** SQLite LIKE examples

We use the =tracks= table in the sample database for the purpose of
demonstration.

[[file:figs/tracks.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/tracks.png]]

To find the tracks whose names start with the =Wild= literal string, you use the
percent sign =%= wildcard at the end of the pattern.

#+begin_src sql
SELECT
 trackid,
 name 
FROM
 tracks
WHERE
 name LIKE 'Wild%'
#+end_src

[[file:figs/SQLite-LIKE-percentage-wildcard.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-LIKE-percentage-wildcard.png]]

To find the tracks whose names end with =Wild= word, you use =%= wildcard at
the beginning of the pattern.

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name LIKE '%Wild'
#+end_src

[[file:figs/SQLite-LIKE-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-LIKE-example.png]]

To find the tracks whose names contain the =Wild= literal string, you use =%=
wildcard at the beginning and end of the pattern:

#+begin_src sql
SELECT
 trackid,
 name 
FROM
 tracks
WHERE
 name LIKE '%Wild%';
#+end_src

[[file:figs/SQLite-LIKE-wildcard-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-LIKE-wildcard-example.png]]

The following statement finds the tracks whose names contain: zero or more
characters (=%=), followed by =Br=, followed by a character (=_=), followed by
=wn=, and followed by zero or more characters (=%=):

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name LIKE '%Br_wn%';
#+end_src

*** SQLite Glob
- http://www.sqlitetutorial.net/sqlite-glob/

- determine whether a string matches a specific UNIX-pattern


*Summary*: in this tutorial, you will learn how to use the SQLite GLOB operator
to determine whether a string matches a specific pattern.

**** Introduction to the SQLite =GLOB= operator
The =GLOB= operator is similar to the LIKE operator.  The =GLOB= operator
determines whether a string matches a specific pattern.

Unlike the =LIKE= operator, the =GLOB= operator is case sensitive and uses the
=UNIX= wildcards.  In addition, the =GLOB= patterns do not have escape
character.

The following shows the =GLOB= wildcards:

- the asterisk (=*=) wildcard matches any number of characters.

- the question mark (=?=) wildcard matches exactly one character.


In addition, you can use the list wildcard =[]= to match one character from a
list of characters.  For example =[xyz]= match any single x, y, or z character.

The list wildcard also allows a range of characters e.g., =[a-z]= matches any
single lowercase character from a to z. The =[a-zA-Z0-9]= pattern matches any
single alphanumeric character, both lowercase and uppercase.

You use the =^= at the beginning of the list to match any character except any
character in the list.  For example, the =[^0-9]= pattern matches any single
character except a numeric character.

**** SQLite GLOB examples
The following statement finds tracks whose names start with the string =Man=.  The
pattern =Man*= matches any string that starts with =Man=.

#+begin_src sql
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB 'Man*';
#+end_src

The following statement gets the tracks whose names end with =Man=.  The
pattern =*Man= matches any string that ends with =Man=.

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*Man';
#+end_src

The following query finds the tracks whose names start with any single
character (=?=), followed by the string ere and then any number of character
(=*=).

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '?ere*';
#+end_src

To find the tracks whose names contain numbers, you can use the list wildcard
=[0-9]= as follows:

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*[1-9]*';
#+end_src

Or to find the tracks whose name does not contain any number, you place the =^=
at the beginning of the list:

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*[^1-9]*';
#+end_src

The following statement finds the tracks whose names end with a number.

#+begin_src sql
SELECT
 trackid,
 name
FROM
 tracks
WHERE
 name GLOB '*[1-9]';
#+end_src

** Joining tables
- SQLite Inner Join ::

     query data from multiple tables using inner join clause.

- SQLite Left Join ::

     combine data from multiple tables using left join clause.

- SQLite Cross Join ::

     show you how to use the cross join clause to produce a cartesian product
     of result sets of the tables involved in the join.

- SQLite Self Join ::

     join a table to itself to create a result set that joins rows with other
     rows within the same table.

- SQLite Full Outer Join ::

     show you how to emulate the full outer join in the SQLite using left join
     and union clauses.

** Grouping data

*** SQLite =GROUP BY= Clause
- http://www.sqlitetutorial.net/sqlite-group-by/

- SQLite Group By ::

     combine a set of rows into groups based on specified criteria. The GROUP
     BY clause helps you summarize data for reporting purposes.


*Summary*: in this tutorial, you will learn how to use SQLite GROUP BY clause
to make a set of summary rows from a set of rows.

**** Introduction to SQLite GROUP BY clause
#+cindex:@command{GROUP BY} clause
#+cindex:summary rows, @command{GROUP BY}
The =GROUP BY= clause is an optional clause of the =SELECT= statement.  The
=GROUP BY= clause a selected group of rows into summary rows by values of one
or more columns.

The =GROUP BY= clause returns one row for each group.  For each group, you can
apply an aggregate function such as =MIN=, =MAX=, =SUM=, =COUNT=, or =AVG= to
provide more information about each group.

The following statement illustrates the syntax of the SQLite GROUP BY clause.

#+begin_src sql
SELECT
    column_1,
    aggregate_function(column_2)
FROM
    table
GROUP BY
    column_1,
    column_2;
#+end_src

The =GROUP BY= clause comes after the =FROM= clause of the =SELECT= statement.
In case a statement contains a =WHERE= clause, the =GROUP BY= clause must come
after the =WHERE= clause.

Following the =GROUP BY= clause is a column or a list of comma-separated
columns used to specify the group.

**** SQLite =GROUP BY= examples

**** SQLite =HAVING=
- http://www.sqlitetutorial.net/sqlite-having/

- SQLite Having ::

                   specify the conditions to filter the groups summarized by
                   the =GROUP BY= clause.



*Summary*: in this tutorial, you will learn how to use SQLite HAVING clause to
specify a filter condition for a group or an aggregate.

**** Introduction to SQLite =HAVING= clause
#+cindex:@command{HAVING} clause
#+cindex:search condition, @command{HAVING}
SQLite =HAVING= clause is an optional clause of the =SELECT= statement.  The
=HAVING= clause specifies a search condition for a group.

You often use the =HAVING= clause with the =GROUP BY= clause.  The =GROUP BY=
clause groups a set of rows into a set of summary rows or groups.  Then the
=HAVING= clause filters groups based on specified conditions.

If you use a =HAVING= clause without the =GROUP BY= clause, the =HAVING= clause
behaves like a =WHERE= clause.  Note that the =HAVING= clause is applied after
=GROUP BY= clause, while the =WHERE= clause is applied before.

The following illustrates the syntax of the =HAVING= clause:

#+begin_src sql
SELECT
 column_1,
 aggregate_function (column_2)
FROM
 table
GROUP BY
 column_1
HAVING
 search_condition;
#+end_src

SQLite evaluates the =search_condition= for each group as a Boolean expression.
It only includes a group in the final result set if the evaluation is =true=.

**** SQLite =HAVING= clause examples
We will use the =tracks= table in the sample database for demonstration.

To find the number of tracks for each album, you use =GROUP BY= clause as
follows:

#+begin_src sql
SELECT
 albumid,
 COUNT(trackid)
FROM
 tracks
GROUP BY
 albumid;
#+end_src

To find the numbers of tracks for the album with id 1, we add a =HAVING= clause
to the following statement:

#+begin_src sql
SELECT
 albumid,
 COUNT(trackid)
FROM
 tracks
GROUP BY
 albumid
HAVING albumid = 1;
#+end_src

We have referred to the =AlbumId= column in the =HAVING= clause.

To find albums that have the number of tracks between 18 and 20, we refer to
the aggregate function in the =HAVING= clause as the following statement:

#+begin_src sql
SELECT
 albumid,
 COUNT(trackid)
FROM
 tracks
GROUP BY
 albumid
HAVING count(albumid) BETWEEN 18 AND 20
ORDER BY albumid;
#+end_src

**** SQLite =HAVING= clause with =INNER JOIN= example

** Set operators
- SQLite Union ::

                  combine result sets of multiple queries into a single result
                  set.  We also discuss the differences between =UNION= and =UNION
                  ALL= clauses.

- SQLite Except ::

                   compare the result sets of two queries and returns distinct
                   rows from the left query that are not output by the right
                   query.

- SQLite Intersect ::

     compare the result sets of two queries and returns distinct rows that are
     output by both queries.

** Subquery
- SQLite Subquery ::

     introduce you to the SQLite subquery and correlated subquery.

- SQLite EXISTS ::

                   test for the existence of rows returned by a subquery.

** More querying techniques
- SQLite Case ::

                 add conditional logic to the query.

** Changing data
This section guides you how to update data in the table using insert, update,
and delete statements.

*** SQLite =INSERT=---inserting a single row into a table
- http://www.sqlitetutorial.net/sqlite-insert/

- SQLite Insert ::

                   insert rows into a table


*Summary*: in this tutorial, you will learn how to use SQLite =INSERT=
statement to insert new rows into a table.

To insert data into a table, you use the =INSERT= statement.  SQLite provides
various forms of the =INSERT= statements that allow you to insert a single row,
multiple rows, and default values into a table.

In addition, you can insert a row into a table using data provided by a
=SELECT= statement.

**** SQLite INSERT --- inserting a single row into a table
#+cindex:@command{INSERT} statement
To insert a single row into a table, you use the following form of the =INSERT=
statement:

#+begin_src sql
INSERT INTO table1 (
 column1,
 column2 ,..)
VALUES
 (
 value1,
 value2 ,...);
#+end_src

Let’s examine the =INSERT= statement in more detail:

- First, specify a table to which you want to insert data after the =INSERT
  INTO= clause.

- Second, add a comma-separated list of columns.  This list is optional.

- Third, add a comma-separated list of values after the =VALUES= clause.  If
  you omit the column list, you have to specify values for all columns in the
  value list.  The number of values must be the same as the number of columns.


We will take the =artists= table in the sample database for the demonstration.

For example, to insert a new row into the =artists= table, you use the
following statement.

#+begin_src sql
INSERT INTO artists (name)
VALUES
 ('Bud Powell');
#+end_src

Because the =artistid= column is an auto-increment column, you can ignore it in
the statement.  SQLite takes the next number to insert into the =artistid=
column.

You can verify the insert operation using the following =SELECT= statement:

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists
ORDER BY
 artistid DESC
LIMIT 1;
#+end_src

As you see, we have a new row in the =artists= table.

**** SQLite =INSERT= --- Inserting multiple rows into a table
To insert multiple rows into a table, you use the following form of the
=INSERT= statement:

#+begin_src sql
INSERT INTO table1 (
 column1,
 column2 ,..)
VALUES
 (
 value1,
 value2 ,...),
 (
 value1,
 value2 ,...),
        ...
 (
 value1,
 value2 ,...);
#+end_src

Each values list following the =VALUES= clause is a row that you want to insert
into the table.  For example, to insert three new rows into the artists table,
you use the following statement:

#+begin_src sql
INSERT INTO artists (name)
VALUES
 ("Buddy Rich"),
 ("Candido"),
 ("Charlie Byrd");
#+end_src

SQLite issued a message: =Row Affected: 3=

You can verify the result using the following statement:

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists
ORDER BY
 artistid DESC
LIMIT 3;
#+end_src

**** SQLite =INSERT= --- Inserting default values
When you created a new table using =CREATE TABLE= statement, you defined
default values for columns, or a =NULL= value if a default value is not
specified.

#+cindex:@command{INSERT DEFAULT VALUES} statement
The third form of the =INSERT= statement is =INSERT DEFAULT VALUES=.  It
inserts a new row into a table using the default values or =NULL= values of the
column.

For example, to insert a new row into the artists table using =INSERT DEFAULT
VALUES=, you use the following statement:

: INSERT INTO artists DEFAULT VALUES;

To verify the insert, you use the following statement:

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists
ORDER BY
 artistid DESC;
#+end_src

The default value of the =artistid= column is the next integer in the sequence.

However, the =name= column does not have any default value, the =INSERT DEFAULT
VALUES= statement inserts a =NULL= value into the =name= column.

**** SQLite =INSERT= --- Inserting new rows with data provided by a =SELECT= statement
Suppose you want to backup the =artists= table, you create a new table named
=artists_backup= as follows:

#+begin_src sql
CREATE TABLE artists_backup(
 artistid INTEGER PRIMARY KEY AUTOINCREMENT,
 name NVARCHAR
);
#+end_src

To insert data into the =artists_backup= table with the data from the =artists=
table, you use the =INSERT INTO SELECT= statement as follows:

#+begin_src sql
INSERT INTO artists_backup SELECT
 artistid,
 name
FROM
 artists;
#+end_src

If you query data from the =artists_backup= table, you will see all data in the
=artists= table.

#+begin_src sql
SELECT
 *
FROM
 artists_backup;
#+end_src

*** SQLite =UPDATE=
- http://www.sqlitetutorial.net/sqlite-update/

- SQLite Update ::

      update existing rows in a table.


*Summary*: in this tutorial, you will learn how to use SQLite =UPDATE=
statement to update data of existing rows in the table.

**** Introduction to SQLite =UPDATE= statement
#+cindex:@command{UPDATE} statement
To update existing data in a table, you use SQLite =UPDATE= statement.  The
following illustrates the syntax of the =UPDATE= statement:

#+begin_src sql
UPDATE table
SET column_1 = new_value_1,
    column_2 = new_value_2
WHERE
    search_condition 
ORDER column_or_expression
LIMIT row_count OFFSET offset;
#+end_src

First, you specify the table where you want to update after the =UPDATE=
clause.

Second, the =SET= clause allows you to update data in one or more columns
determined by a list of comma-separated assignments.  Each assignment specifies
a column name on the left side the assignment operator (=) and a literal value,
an expression, or data from a subquery on the right side of the assignment
operator.

Third, the =WHERE= clause specifies the rows that you want to update.  The
=WHERE= clause is an optional clause.  If you omit the =WHERE= clause, the
=UPDATE= statement updates data in all rows of the table.

Fourth, SQLite allows you to use the =ORDER BY= and =LIMIT= clauses in the
=UPDATE= statement.  The =LIMIT= clause specifies the number of rows to be
updated.

Notice that if use a negative value in the =LIMIT= clause, SQLite assumes that
there are no limit and updates all rows that meet the condition in the
preceding =WHERE= clause.

The =ORDER BY= clause goes with the =LIMIT= clause to control exactly which
rows to update.  Otherwise, you will never know which row will actually be
updated.  Because without the =ORDER BY= clause, the order of the result set is
unspecified.

**** SQLite =UPDATE= statement examples
We will use the =employees= table in the sample database for the demonstration
of the =UPDATE= statement.

The following =SELECT= statement gets partial data from the =employees= table:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 title,
 email
FROM
 employees;
#+end_src

***** Update one column example
Suppose, Jane got married and she wanted to change her last name to her
husband’s last name i.e., Smith.  In this case, you can update Jane’s last name
using the following statement:

#+begin_src sql
UPDATE employees
SET lastname = 'Smith'
WHERE
 employeeid = 3;
#+end_src

The expression in the =WHERE= clause makes sure that we update Jane’s record
only.  We set the =lastname= column to a literal string =Smith=.

To verify the =UPDATE=, you use the following statement:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 title,
 email
FROM
 employees
WHERE
 employeeid = 3;
#+end_src

***** Update multiple columns example
Suppose Park Margaret locates in Toronto and you want to change his address,
city, and state information.  You can use the =UPDATE= statement to update
multiple columns as follows:

#+begin_src sql
UPDATE employees
SET city = 'Toronto',
    state = 'ON',
    postalcode = 'M5P 2N7'
WHERE
    employeeid = 4;
#+end_src

To verify the =UPDATE=, you use the following statement:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 state,
 city,
 PostalCode
FROM
 employees
WHERE
 employeeid = 4;
#+end_src

***** Update with =ORDER BY= and =LIMIT= clauses example
Note that you need to build SQLite with =SQLITE_ENABLE_UPDATE_DELETE_LIMIT=
option in order to perform =UPDATE= statement with optional =ORDER BY= and
=LIMIT= clauses.

Let’s check the email addresses of employees in the employees table:

#+begin_src sql
SELECT
 employeeid,
 firstname,
 lastname,
 email
FROM
 employees;
#+end_src

To update one row in the employees table, you use =LIMIT 1= clause.  To make
sure that you update the first row of employees sorted by the first name, you
add the =ORDER BY firstname= clause.

So the following statement updates email of Andrew Adams:

#+begin_src sql
UPDATE employees
SET email = lower(
 firstname || "." || lastname || "@chinookcorp.com"
)
ORDER BY
 firstname
LIMIT 1;
#+end_src

The new email is the combination of the first name, dot (=.=), last name and the
suffix =@chinookcorp.com=

The =LOWER= function converts the email to lower case.

***** Update all rows example
To update all rows in the =employees= table, you skip the =WHERE= clause.  For
example, to standardize the email addresses of all employees, you use the
following statement:

#+begin_src sql
UPDATE employees
SET email = lower(
 firstname || "." || lastname || "@chinookcorp.com"
);
#+end_src

*** SQLite =DELETE=
- http://www.sqlitetutorial.net/sqlite-delete/

- SQLite Delete ::

                   delete rows from a table.


*Summary*: this tutorial shows you how to use SQLite DELETE statement to remove
rows from a table.

**** Introduction to SQLite =DELETE= statement
#+cindex:@command{DELETE} statement
You have learned how to insert a new row into a table and update existing data
of a table.  Sometimes, you need to remove rows from a table.  In this case, you
use SQLite =DELETE= statement.

The SQLite =DELETE= statement allows you to delete one row, multiple rows, and
all rows in a table.  The syntax of the SQLite =DELETE= statement is as
follows:

#+begin_src sql
DELETE
FROM
 table
WHERE
 search_condition;
#+end_src

In this syntax:

- First, specify the table where you want to remove rows after the =DELETE FROM=
  clause.

- Second, add a search condition in the =WHERE= clause to identify which row to
  remove.  The =WHERE= clause is an optional part of the =DELETE= statement.
  If you omit the =WHERE= clause, all rows in the table will be removed.


SQLite also provides an extension to the =DELETE= statement by adding =ORDER
BY= and =LIMIT= clauses.  If you compile SQLite with the
=SQLITE_ENABLE_UPDATE_DELETE_LIMIT= compile-time option, you can use the =ORDER
BY= and =LIMIT= clause in the =DELETE= statement like the following form:

#+begin_src sql
DELETE
FROM 
   table
WHERE search_condition
ORDER BY criteria
LIMIT row_count OFFSET offset;
#+end_src

The =ORDER BY= clause sorts the rows filtered by the preceding
=search_condition= in the =WHERE= clause and the =LIMIT= clause specifies the
number of rows that will be deleted.

#+cindex:truncate optimization
Notice that when you use the =DELETE= statement without a =WHERE= clause on a
table that has no triggers, SQLite will delete all rows in one shot instead of
visiting and deleting each row.  This feature is known as =truncate
optimization=.

**** SQLite =DELETE= statement examples
We will use the =artists_backup= table that we created in the how to insert
rows into table tutorial.

#+begin_src sql
SELECT
 artistid,
 name
FROM
 artists_backup;
#+end_src

We have 280 rows in the =artists_backup= table.

To remove an artist with =id 1=, you use the following statement:

#+begin_src sql
DELETE
FROM
 artists_backup
WHERE
 artistid = 1;
#+end_src

Because we use =artistid= to identify the artist, the statement removed exactly
1 row.

Suppose we want to remove artists whose names contain the literal string
=Santana=:

#+begin_src sql
DELETE
FROM
 artists_backup
WHERE
 name LIKE '%Santana%';
#+end_src

There are 9 rows whose values in the name column contain the =Santana= literal
string; therefore, these 9 rows were removed.

To remove all rows in the =artists_backup= table, you just need to omit the
=WHERE= clause as the following statement:

#+begin_src sql
DELETE
FROM
 artists_backup;
#+end_src

*** SQLite =REPLACE=
- http://www.sqlitetutorial.net/sqlite-replace-function/

- SQLite Replace ::

                    insert a new row or replace the existing row in a table.


#+cindex:@command{REPLACE()} function
*Summary*: in this tutorial, you will learn how to use SQLite ~REPLACE()~
function to replace all occurrences of a specified string with another string.

**** Introduction to SQLite ~REPLACE()~ function
The SQLite ~REPLACE()~ function is a string function that allows you to replace
all occurrences of a specified string with another string.

The following shows the syntax of the ~REPLACE()~ function:

: REPLACE(string,pattern,replacement)

In this syntax:

- =string= is the string that you want to perform the replacement.

- =pattern= is the substring to be found in the original string

- =replacement= is the replacement string.


The ~REPLACE()~ function is useful for updating character data in a table e.g.,
update the dead links and typos.

**** SQLite ~REPLACE()~ function examples
Let’s take some examples of using the ~REPLACE()~ function.

***** SQLite ~REPLACE()~ function simple example
The following example replaces the string 'A' in the string 'AA B CC AAA' with
the new string 'Z':

#+begin_src sql
SELECT
    REPLACE('AA B CC AAA','A','Z');
#+end_src

The following statement uses the ~REPLACE()~ function to replace the string
'This' in the string 'This is a cat' with the new string 'That':

#+begin_src sql
SELECT
    REPLACE('This is a cat','This','That');
#+end_src

***** SQLite ~REPLACE()~ string in a table example
First, create a new table named =contacts= that consists of four columns:
=contact_id=, =first_name=, =last_name=, and =phone=:

#+begin_src sql
CREATE TABLE contacts (
    contact_id INT PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    phone TEXT NOT NULL
);
#+end_src

Next, insert into the =contacts= table some rows:

#+begin_src sql
INSERT INTO contacts(first_name, last_name, phone)
VALUES('John','Doe','410-555-0168');
INSERT INTO contacts(first_name, last_name, phone)
VALUES('Lily','Bush','410-444-9862');
#+end_src

Then, query data from the =contacts= table:

#+begin_src sql
SELECT 
    first_name, 
    last_name,
    phone
FROM 
    contacts;
#+end_src

After that, update the phone area code from local (410) to international
one(+1-410):

#+begin_src sql
UPDATE
    contacts
SET
    phone = REPLACE(phone,'410','+1-410');
#+end_src

Finally, query data from the contacts table to verify if the phone has been
updated:

#+begin_src sql
SELECT 
    first_name, 
    last_name,
    phone
FROM 
    contacts;
#+end_src

** Transactions
- http://www.sqlitetutorial.net/sqlite-transaction/

- SQLite Transaction ::

     show you how to handle transactions.


*Summary*: in this tutorial, we will show you how to use the SQLite transaction
to ensure the integrity and reliability of the data.

*** SQlite & ACID
#+cindex:ACID
#+cindex:transactional database
SQlite is a transactional database, ensuring that all /changes/ and /queries/
are (ACID):
- atomic,
- consistent,
- isolated, and
- durable


#+cindex:transactions
SQLite guarantees all the transactions are ACID compliant even if the
transaction is interrupted by program crash, operation system dump, or power
failure to the computer.


- Atomic :: a transaction should be atomic. It means that a change cannot be
            broken down into smaller ones. When you commit a transaction,
            either the entire transaction is applied or not applied. It cannot
            be only part of the transaction to be applied.

- Consistent :: a transaction must ensure to change the database from one valid
                state to another. When a transaction starts and executes
                statements to modify data, the database becomes
                inconsistent. However, when the transaction is committed or
                rolled back, it is important that the transaction must keep the
                database consistent.

- Isolation :: a pending transaction must be isolated from other clients. When
               a client starts a transaction and executes the INSERT or UPDATE
               statement to change the data, those changes are only visible to
               the client, not other clients. On the other hand, the changes
               committed by other clients after the transaction started should
               not be visible to this client.

- Durable :: if a transaction is successfully committed, the changes must be
             permanent in the database regardless of the condition such as
             power failure or program crash. On the contrary, if the program
             crashes before the transaction is committed, the change should not
             be present.


**** SQLite transaction statements
#+cindex:auto-commit mode
By default, SQLite is in auto-commit mode.  It means that for each command,
SQLite starts, processes, and commits the transaction automatically.

#+cindex:transaction, start
To start a transaction explicitly, you use the following steps:

#+cindex:@command{BEGIN TRANSACTION} command
First, open a transaction by issuing the =BEGIN TRANSACTION= command.

: BEGIN TRANSACTION;

#+cindex:transaction, open
#+cindex:open transaction
After executing the =BEGIN TRANSACTION= statement, the transaction is open until
it is explicitly committed or rolled back.

Second, issue the SQL commands to select or update data in the database.  Note
that the change is only visible to the client.

#+cindex:@command{COMMIT} statement
#+cindex:@command{COMMIT TRANSACTION} statement
Third, to commit the changes to the database, you use the =COMMIT= or =COMMIT
TRANSACTION= statement.

: COMMIT;

#+cindex:@command{ROLLBACK} statement
For any reason, if you do not want to commit the transaction, you can roll it
back using the =ROLLBACK= or =ROLLBACK TRANSACTION= statement.

: ROLLBACK;

**** SQLite transaction example
We will create two new tables: =accounts= and =account_changes= for the
demonstration.

The =accounts table stores data about the account numbers and their balances.
The =account_changes= table stores changes of the accounts.

First, the following =CREATE TABLE= statements create the new tables.

#+begin_src sql
CREATE TABLE IF NOT EXISTS accounts (
    account_no INTEGER PRIMARY KEY
                       NOT NULL,
    balance    DECIMAL NOT NULL
                       DEFAULT 0
);

CREATE TABLE IF NOT EXISTS account_changes(
    account_no integer not null,
    flag text not null,
    amount decimal not null,
    changed_at text not null
);
#+end_src

Second, insert some sample data into the =accounts= table.

#+begin_src sql
INSERT INTO accounts (
                         account_no,
                         balance
                     )
                     VALUES (
                         100,
                         20100
                     );

INSERT INTO accounts (
                         account_no,
                         balance
                     )
                     VALUES (
                         200,
                         10100
                     );
#+end_src

#+begin_src sql
SELECT *
  FROM accounts;
#+end_src

Third, transfer 1000 from the account 100 to the account 200, and write the
changes to the =account_changes= table; perform all of the activities within the
same transaction.

#+begin_src sql
BEGIN TRANSACTION;

UPDATE accounts
   SET balance = balance - 1000
 WHERE account_no = 100;

UPDATE accounts
   SET balance = balance + 1000
 WHERE account_no = 200;

INSERT INTO account_changes(account_no,flag,amount,changed_at)
values(100,'-',1000,datetime('now'));

INSERT INTO account_changes(account_no,flag,amount,changed_at)
values(200,'+',1000,datetime('now'));

COMMIT;
#+end_src

** Data Definition
In this section, we show you how to create database objects such as tables,
views, indexes using SQL data definition language.

*** SQLite Data Types
- http://www.sqlitetutorial.net/sqlite-data-types/

- SQLite Data Types ::

     introduce you to the SQLite dynamic types system and its important
     concepts: storage classes, manifest typing, and type affinity.


*** SQLite =CREATE TABLE=
- http://www.sqlitetutorial.net/sqlite-create-table/

- SQLite Create Table ::

     show you how to create a new table in the database.


*** SQLite =PRIMARY KEY=
- http://www.sqlitetutorial.net/sqlite-primary-key/

- SQLite Primary Key ::

     show you how to define the primary key for a table.


*** SQLite =NOT NULL= Constraint
- http://www.sqlitetutorial.net/sqlite-not-null-constraint/

- SQLite NOT NULL constraint ::

     ensure values in a column are not NULL.


*** SQLite =UNIQUE= Constraint
- http://www.sqlitetutorial.net/sqlite-unique-constraint/

- SQLite UNIQUE constraint ::

     ensure values in a column or a group of columns are unique.


*** SQLite =CHECK= Constraint
- http://www.sqlitetutorial.net/sqlite-check-constraint/

- SQLite CHECK constraint ::

     ensure the values in a column meet a specified condition defined by an
     expression.


*** SQLite =AUTOINCREMENT= Attribute
- http://www.sqlitetutorial.net/sqlite-autoincrement/

- SQLite AUTOINCREMENT ::

     explain how =AUTOINCREMENT= attribute works and why you should avoid using it.


*** SQLite =ALTER TABLE= Statement
- http://www.sqlitetutorial.net/sqlite-alter-table/

- SQLite Alter Table ::

     show you how to use modify the structure of an existing table


*** SQLite =DROP TABLE= Statement
- http://www.sqlitetutorial.net/sqlite-drop-table/

- SQLite Drop Table ::

     guide you how to remove a table from the database.


*** SQLite =VACUUM= Command
- http://www.sqlitetutorial.net/sqlite-vacuum/

- SQLite VACUUM ::

                   show you how to optimize database file.

** Views
- http://www.sqlitetutorial.net/sqlite-create-view/

- SQLite Create View ::

      introduce you to the view concept and show you how to create a new view
     in the database.


*Summary*: in this tutorial, you will learn how to use the SQLite =CREATE VIEW=
statement to create a view.

*** What is a view
#+cindex:view definition
#+cindex:stored query
#+cindex:query, pack into named object
In database theory, a /view/ is a result set of a stored query.  A view is the
way to pack a query into a named object.

#+cindex:base tables
You can access the data of the underlying tables through the view.  The tables
that the query in the view definition refers to are called /base tables/.

A view is useful in some cases:

  #+cindex:abstraction layer, view
- First, views provide an abstraction layer over tables.  You can add and remove
  the columns in the view without touching the schema of the underlying tables.

  #+cindex:encapsulate complex queries, view
- Second, you can use views to encapsulate complex queries with joins to
  simplify the data access.


SQLite view is read only.  It means you cannot use =INSERT=, =DELETE=, and
=UPDATE= statement to update data in the base tables through the view.

*** SQLite =CREATE VIEW= statement
#+cindex:@command{CREATE VIEW} statement
To create a view, you use the =CREATE VIEW= statement as follows:

#+begin_src sql
CREATE [TEMP] VIEW [IF NOT EXISTS] view_name(column-name-list)
AS
   select-statement;
#+end_src

#+cindex:@command{IF NOT EXISTS} option
First, you need to assign the view a name.  The =IF NOT EXISTS= option helps
you prevent an error of creating a view that already exists.

Second, if you want the view to be only visible in the current database
connection, you need to create a temporary view using the =TEMP= or =TEMPORARY=
option.  SQLite automatically removes the temporary views whenever the database
connection is closed.

Third, you specify the =SELECT= statement for the view.  By default, the
columns of the view derive from the result set of the =SELECT= statement.
However, you can use different columns for the view by specifying the columns
(=column-name-list=) explicitly after the view’s name.

*** SQLite =CREATE VIEW= example
The following query gets data from the tracks, albums, and genres tables in the
sample database using the inner join clause.

#+begin_src sql
SELECT
 trackid,
 tracks.name,
 albums.Title AS album,
 media_types.Name AS media,
 genres.Name AS genres
FROM
 tracks
INNER JOIN albums ON Albums.AlbumId = tracks.AlbumId
INNER JOIN media_types ON media_types.MediaTypeId = tracks.MediaTypeId
INNER JOIN genres ON genres.GenreId = tracks.GenreId;
#+end_src

To create a view based on this query, you use the following statement:

#+begin_src sql
CREATE VIEW v_tracks
AS
SELECT
 trackid,
 tracks.name,
 albums.Title AS album,
 media_types.Name AS media,
 genres.Name AS genres
FROM
 tracks
INNER JOIN albums ON Albums.AlbumId = tracks.AlbumId
INNER JOIN media_types ON media_types.MediaTypeId = tracks.MediaTypeId
INNER JOIN genres ON genres.GenreId = tracks.GenreId;
#+end_src

From now on, you just use the following simple query instead of the complex one
above.

#+begin_src sql
SELECT
 *
FROM
 v_tracks;
#+end_src

*** Removing views
#+cindex:@command{DROP VIEW} statement
To remove a view from the database, you use the =DROP VIEW= statement as
follows:

: DROP VIEW [IF EXISTS] view_name;

You need to specify the view name in the =DROP VIEW= statement to remove the
view.  Note that the =DROP VIEW= statement removes the view object only; no
actual data in the base tables is changed.

#+cindex:@command{IF EXISTS} option
If you remove an non-existent view, SQLite issues an error.  To avoid this, you
use the =IF EXISTS= option.  In case the view does not exist and you try to
remove it, SQLite just ignores the statement.

For example, the following statement removes the v_tracks view from the
database:

: DROP VIEW v_tracks;

** Indexes

*** SQLite Index
- http://www.sqlitetutorial.net/sqlite-index/

- SQLite Index ::

                  teach you about the index and how to utilize indexes to speed
                  up your queries.


*Summary*: in this tutorial, you will learn how to use SQLite indexes to query
data faster, speed up sort operation, and enforce unique constraints.

**** What is an Index
#+cindex:table, definition
In relational databases, a table is a list of rows.  At the same time, each row
has the same column structure that consists of cells.  Each row also has a
consecutive =rowid= sequence number used to identify the row.  Therefore, we can
consider a /table/ as a list of pairs: =(rowid, row)=.

#+cindex:index, definition
Unlike a table, an index has an opposite relationship: =(row, rowid)=.  An
/index/ is an additional data structure that helps speed up querying, join, and
grouping operations.

[[file:figs/SQLite-Index.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-Index.png]]

#+cindex:B-tree index
SQLite uses B-tree index.  =B= stands for /balanced/.  The B-tree keeps the
amount of data on its both side balanced so that the number of levels that must
be traversed to locate a row is always in the same approximate number.  In
addition, querying using equality and ranges on B-tree indexes are very
efficient.

**** How indexes work
Each index must be associated with a specific table.  An index consists of one
or more columns, but all columns of an index must be in the same table.  A table
may have multiple indexes.

Whenever you create an index, SQLite creates a B-tree structure to hold the
index data.

The index contains data from the columns that you specify in the index and the
corresponding rowid value.  This helps SQlite find the row quickly based on the
values of the indexed columns.

Imagine an index in the database like an index of a book.  By looking at the
index, you can quickly identify the page number based on the keyword.

**** SQLite =CREATE INDEX= statement
#+cindex:@command{CREATE INDEX} statement
To create an index, you use the =CREATE INDEX= statement.  The following
illustrates its syntax:

: CREATE [UNIQUE] INDEX index_name ON table_name(indexed_column);

To create an index, you specify three important items of information:

- The table that the index associated with.

- The a list of indexed column.

- The name of the index.


#+cindex:@command{UNIQUE} option
In case you want to make sure that the value of the column is unique like
email, phone, etc., you use the =UNIQUE= option in the =CREATE INDEX=
statement.

**** SQLite =UNIQUE= index example
Let’s create a new table named =contacts= for demonstration.

#+begin_src sql
CREATE TABLE contacts (
 first_name text NOT NULL,
 last_name text NOT NULL,
 email text NOT NULL
);
#+end_src

Suppose you want to enforce that the email is unique; you create a unique index
as follows:

: CREATE UNIQUE INDEX idx_contacts_email ON contacts (email);

To test this, first, you insert a row into the =contacts= table.

#+begin_src sql
INSERT INTO contacts (first_name, last_name, email)
VALUES
 (
 'John',
 'Doe',
 'john.doe@sqlitetutorial.net'
 );
#+end_src

Second, try to insert another row with a duplicate email.

#+begin_src sql
INSERT INTO contacts (first_name, last_name, email)
VALUES
 (
 'Johny',
 'Doe',
 'john.doe@sqlitetutorial.net'
 );
#+end_src

SQLite issued an error message that the unique constraint failed.  This is
because when you inserted the second row, SQLite checked and made sure that the
email is unique across of rows in the contacts table.

Let’s insert two more rows into the =contacts= table.

#+begin_src sql
INSERT INTO contacts (first_name, last_name, email)
VALUES
 (
 'David',
 'Brown',
 'david.brown@sqlitetutorial.net'
 ),
 (
 'Lisa',
 'Smith',
 'lisa.smith@sqlitetutorial.net'
 );
#+end_src

If you query data in the contacts table using the email column, SQLite will use
the index to locate the data.  See the following statement.

#+begin_src sql
SELECT
 first_name,
 last_name,
 email
FROM
 contacts
WHERE
 email = 'lisa.smith@sqlitetutorial.net';
#+end_src

#+cindex:@command{EXPLAIN QUERY PLAN} statement
To check if SQLite uses index or not, you use the =EXPLAIN QUERY PLAN=
statement as follows:

#+begin_src sql
EXPLAIN QUERY PLAN
SELECT
 first_name,
 last_name,
 email
FROM
 contacts
WHERE
 email = 'lisa.smith@sqlitetutorial.net';
#+end_src

**** SQLite multicolumn index example
If you create an index that consists of one column, SQLite uses that column as
the sort key.  In case you create an index that has multiple columns, SQLite
uses the additional columns as the second, third, … sort keys.

SQLite sorts the data on the multicolumn index by the first column specified in
the =CREATE INDEX= statement.  Then it sorts the duplicate values by the second
column, and so on.

Therefore, the column order is very important when you create the multicolumn
index.

To utilize a multicolumn index, the query must contain the condition that has
the same column order as defined in the index.

The following statement creates a multicolumn index on the =first_name= and
=last_name= columns of the contacts table:

#+begin_src sql
CREATE INDEX idx_contacts_name 
ON contacts (first_name, last_name);
#+end_src

If you query the contacts table with the one of following conditions in the
=WHERE= clause, SQLite will utilize the multicolumn index to search for data.

1. Querying by the =first_name= column.

   #+begin_src sql
   WHERE
    first_name = 'John';
   #+end_src

2. Querying by both =first_name= and =last_name= columns:

   #+begin_src sql
   WHERE
     first_name = 'John' AND last_name = 'Doe';
   #+end_src


However, SQLite will not use the multicolumn index if you use one of the
following conditions.

1. Querying by the =last_name= column only.

   #+begin_src sql
   WHERE
     last_name = 'Doe';
   #+end_src

2. Querying by =first_name= OR =last_name= columns.

   #+begin_src sql
   last_name = 'Doe' OR first_name = 'John';
   #+end_src


**** SQLite =DROP INDEX= statement
To remove an index, you use the =DROP INDEX= statement as follows:

: DROP INDEX [IF EXISTS] index_name;

The =IF EXISTS= option prevents you from an error of removing a non-existent
index.

For example, to remove the =idx_contact_name= index, you use the following
statement:

: DROP INDEX idx_contacts_name;

The =idx_contacts_name= index is removed completely from the disk.


*** SQLIte Expression-based Index
- http://www.sqlitetutorial.net/sqlite-index-expression/

- SQLite Index for Expressions ::

     show you how to use the expression-based index.

** Triggers

- SQLite Trigger ::

                    manage triggers in SQLite database.

** Full-text Search

- SQLite full-text search ::

     get started with the full-text search in SQLite.

** SQLite Tools
*** SQLite Commands
- http://www.sqlitetutorial.net/sqlite-commands/

- SQLite Commands ::

     show you the most commonly used command in sqlite3 program.


*Summary*: in this tutorial, we will introduce you to the most commonly used
SQLite commands of the ~sqlite3~ command line program.

The SQLite project delivers a simple command-line tool named ~sqlite3~ (or
sqlite3.exe on Windows) that allows you to interact with the SQLite databases
using SQL statements and commands.

**** Connect to an SQLite database
To start the ~sqlite3~, you type the ~sqlite3~ as follows:

#+begin_src sh
>sqlite3
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
#+end_src

By default, an SQLite session uses the in-memory database; therefore all
changes will be gone when the session ends.

To open a database file, you use the ~.open FILENAME~ command.  The following
statement ~open~'S the ~chinook.db~ database:

: sqlite> .open c:\sqlite\chinook.db

If you want to open a specific database file when you connect to the SQlite
database, you use the following command:

#+begin_src sh
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

If you start a session with a database name that does not exist, the ~sqlite3~
tool will create the database file.

For example, the following command creates a database named =sales= in the
~C:\sqlite\ directory~:

#+begin_src sh
>sqlite3 c:\sqlite\sales.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

**** Show all available commands and their purposes
#+cindex:@command{.help} command
To show all available commands and their purpose, you use the ~.help~ command as
follows:

: .help

**** Show databases in the current database connection
#+cindex:@command{.databases} command
To show all databases in the current connection, you use the ~.databases~
command.  The ~.databases~ command displays at least one database with the
name: =main=.

For example, the following command shows all the databases of the current
connection:

#+begin_src sh
sqlite> .database
seq  name             file
---  ---------------  --------------------------
0    main             c:\sqlite\sales.db
sqlite>
#+end_src

To add an additional database in the current connection, you use the =ATTACH
DATABASE= statement.  The following statement adds the =chinook= database to
the current connection.

: sqlite> ATTACH DATABASE "c:\sqlite\chinook.db" AS chinook;

Now if you run the ~.database~ command again, the ~sqlite3~ returns two
databases: =main= and =chinook=.

#+begin_src sh
sqlite> .databases
seq  name             file
---  ---------------  ---------------------
0    main             c:\sqlite\sales.db
2    chinook          c:\sqlite\chinook.db
#+end_src

**** Exit ~sqlite3~ tool
#+cindex:@command{.exit} command
To exit the ~sqlite3~ program, you use the ~.exit~ command.

: sqlite>.exit

**** Show tables in a database
#+cindex:@command{.tables} command
To display all the tables in the current database, you use the ~.tables~
command.  The following commands open a new database connection to the
=chinook= database and display the tables in the database.

#+begin_src sh
>sqlite3 c:\sqlite\chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite> .tables
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
sqlite>
#+end_src

#+cindex:@command{.table pattern} command
#+cindex:@command{LIKE} operator
If you want to find tables based on a specific pattern, you use the ~.table
pattern~ command.  The ~sqlite3~ uses the =LIKE= operator for pattern matching.

For example, the following statement returns the table that ends with the
string =es=.

#+begin_src sh
sqlite> .table '%es'
employees    genres       invoices     media_types
sqlite>
#+end_src

**** Show the structure of a table
#+cindex:@command{.schema TABLE} command
#+cindex:schema
To display the structure of a table, you use the ~.schema TABLE~ command.  The
=TABLE= argument could be a pattern.  If you omit it, the ~.schema~ command
will show the structures of all the tables.

The following command shows the structure of the =albums= table.

#+begin_src sql
sqlite> .schema albums
CREATE TABLE "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON "albums" ([ArtistId]);
sqlite>
#+end_src

#+cindex:@command{.fullschema} command
To show the schema and the content of the =sqlite_stat= tables, you use the
~.fullschema~ command.

: sqlite>.fullschema

**** Show indexes
#+cindex:@command{.indexes} command
To show all indexes of the current database, you use the ~.indexes~ command as
follows:

#+begin_src sh
sqlite> .indexes
IFK_AlbumArtistId
IFK_CustomerSupportRepId
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
IFK_InvoiceLineInvoiceId
IFK_InvoiceLineTrackId
IFK_PlaylistTrackTrackId
IFK_TrackAlbumId
IFK_TrackGenreId
IFK_TrackMediaTypeId
#+end_src

#+cindex:@command{.indexes TABLE} command
To show the indexes of a specific table, you use the ~.indexes TABLE~ command.
For example, to show indexes of the =albums= table, you use the following
command:

#+begin_src sh
sqlite> .indexes albums
IFK_AlbumArtistId
#+end_src

To show indexes of the tables whose names end with =es=, you use a pattern of
the =LIKE= operator.

#+begin_src sh
sqlite> .indexes %es
IFK_EmployeeReportsTo
IFK_InvoiceCustomerId
#+end_src

**** Save the result of a query into a file
#+cindex:@command{.output FILENAME} command
#+cindex:@command{.once FILENAME} command
To save the result of a query into a file, you use the ~.output FILENAME~
command.  Once you issue the ~.output~ command, all the results of the
subsequent queries will be saved to the file that you specified in the FILENAME
argument.  If you want to save the result of the next single query only to the
file, you issue the ~.once FILENAME~ command.

To display the result of the query to the standard output again, you issue the
~.output~ command without arguments.

The following commands select the title from the =albums= table and write the
result to the ~albums.txt~ file.

#+begin_src sh
sqlite> .output albums.txt
sqlite> SELECT title FROM albums;
#+end_src

**** Execute SQL statements from a file
Suppose we have a file named ~commands.txt~ in the ~c:/sqlite/~ folder with the
following content:

#+begin_src sql
SELECT albumid, title
FROM albums
ORDER BY title
LIMIT 10;
#+end_src

#+cindex:@command{.read FILENAME} command
#+cindex:execute SQL from file
#+cindex:file, execute statements from
To execute the SQL statements in the ~commands.txt~ file, you use the ~.read
FILENAME~ command as follows:

#+begin_src sh
sqlite> .mode column
sqlite> .read c:/sqlite/commands.txt
156         ...And Justice For All
257         20th Century Masters -
296         A Copland Celebration,
94          A Matter of Life and D
95          A Real Dead One
96          A Real Live One
285         A Soprano Inspired
139         A TempestadeTempestade
203         A-Sides
160         Ace Of Spades
#+end_src

*** SQLite =SHOW TABLES=
- http://www.sqlitetutorial.net

- SQLite Show Tables ::

     list all tables in a database.


*Summary*: in this tutorial, you will learn various ways to show tables from an
SQLite database by using SQLite command line shell program or by querying data
from =sqlite_master= tables.

**** Showing tables using the sqlite command line shell program
To show tables in a database using the ~sqlite3~ command line shell program,
you follow these steps:

First, open the database that you want to show the tables:

: sqlite> sqlite3 c:\sqlite\db\chinook.db

The above statement opened the database named ~chinook.db~ that locates in the
~c:\sqlite\db~ directory.

#+cindex:@command{.tables} command
Second, type the ~.tables~ command:

: sqlite> .tables

The ~.tables~ command lists all tables in the =chinook= database:

#+begin_src sh
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
#+end_src

#+cindex:@command{.table} command
#+cindex:@command{.ta} command
Note that both ~.tables~, ~.table~ have the same effect.  In addition, the
command ~.ta~ should work too.

The ~.tables~ command also can be used to show temporary tables.  See the
following example:

#+cindex:@command{CREATE TEMPORARY TABLE} command
First, create a new temporary table named =temp_table1=:

: sqlite> CREATE TEMPORARY TABLE temp_table1( name TEXT );

Second, list all tables from the database:

: sqlite> .tables

The following shows the output:

#+begin_src sh
albums            employees         invoices          playlists
artists           genres            media_types       temp.temp_table1
customers         invoice_items     playlist_track    tracks
#+end_src

Because the schema of temporary tables is =temp=, the command showed the names
of schema and table of the temporary table such as =temp.temp_table1=.

If you want to show tables with the specific name, you can add a matching
pattern:

: .tables pattern

The command works the same as =LIKE= operator.  The pattern must be surrounded
by single quotation marks (='=).

For example, to find tables whose names start with the letter ‘a’, you use the
following command:

: sqlite> .table 'a%'

Here is the output:

: albums   artists

To show the tables whose name contains the string =ck=, you use the =%ck%=
pattern as shown in the following command:

: sqlite> .tables '%ck%'

The output is as follows:

: playlist_track  tracks

**** Showing tables using SQL statement
Another way to list all tables in a database is to query them from the
=sqlite_master= table.

#+begin_src sql
SELECT 
    name
FROM 
    sqlite_master 
WHERE 
    type ='table' AND 
    name NOT LIKE 'sqlite_%';
#+end_src

In this query, we filtered out all tables whose names start with =sqlite_=n
such as =sqlite_stat1= and =sqlite_sequence= tables.  These tables are the
system tables managed internally by SQLite.

*** SQLite =DESCRIBE TABLE=
- http://www.sqlitetutorial.net/sqlite-tutorial/sqlite-describe-table/

- SQLite Describe Table ::

     show the structure of a table.


*Summary*: in this tutorial, you will learn about various ways to show the
structure of a table in SQLite.

**** Getting the structure of a table via the SQLite command line shell program
To find out the structure of a table via SQLite command line shell program, you
follow these steps:

First, connect to a database via the SQLite command line shell program:

: sqlite> sqlite3 c:\sqlite\db\chinook.db

Then, issue the following command:

#+cindex:@command{.schema TABLE_NAME} command
: .schema table_name

For example, to show the statement that created the =albums= table, you use the
following command:

: sqlite> .schema albums

Notice that you should /NOT/ use the semicolon (=;=).

Here is the output:

#+begin_src sql
CREATE TABLE IF NOT EXISTS "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON "albums" ([ArtistId]);
#+end_src

Another way to show the structure of a table is to use the following pragma
command:

#+begin_src sh
sqlite> .header on
sqlite> .mode column
sqlite> pragma table_info('albums');
#+end_src

Note that the first two commands are used to format the output nicely.

**** Getting the structure of a table using SQL statement
You can find the structure of a table by querying it from the =sqlite_master=
table as follows:

#+begin_src sql
SELECT
    sql 
FROM 
    sqlite_master 
WHERE 
    name = 'albums';
#+end_src

Here is the output:

#+begin_src sql
sql
----
CREATE TABLE "albums"
(
    [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    FOREIGN KEY ([ArtistId]) REFERENCES "artists" ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
)
#+end_src

*** SQLite ~.dump~ Command
- http://www.sqlitetutorial.net/sqlite-dump/

- SQLite Dump ::

                 how to use dump command to backup and restore a database.


*Summary*: in this tutorial, you will learn how to use the SQLite dump command
to backup and restore a database.

SQLite project delivers the ~sqlite3~ tool that allows you to interact with the
SQLite database using command-line shell program.

By using the ~sqlite3~ tool, you can use the SQL statements to query or update
data in the database.  In addition, you can use special commands, which are
known as dot-commands to perform various useful database operations.

#+cindex:@command{.dump} command
One of these dot-commands is the ~.dump~ command that gives you the ability to
dump the entire database or tables into a text file.

**** Dump the entire database into a file using SQLite dump command
The following command opens a new SQLite database connection to the
~chinook.db~ file.

#+begin_src sh
C:\sqlite>sqlite3 c:/sqlite/chinook.db
SQLite version 3.13.0 2016-05-18 10:57:30
Enter ".help" for usage hints.
sqlite>
#+end_src

To dump a database into a file, you use the ~.dump~ command.  The ~.dump~
command converts the entire structure and data of an SQLite database into a
single text file.

#+cindex:@command{.output FILENAME} command
By default, the ~.dump~ command outputs the SQL statements on screen.  To issue
the output to a file, you use the ~.output FILENAME~ command.

The following commands specify the output of the dump file to ~chinook.sql~ and
dump the =chinook= database into the ~chinook.sql~ file.

#+begin_src sh
sqlite> .output c:/sqlite/chinook.sql
sqlite> .dump
sqlite> .exit
#+end_src

**** Dump a specific table using the SQLite dump command
If you want to dump a specific table, you need to specify the table name
followed the ~.dump~ command.  For example, the following command saves the
=albums= table to the ~albums.sql~ file.

#+begin_src sh
sqlite> .output c:/sqlite/albums.sql
sqlite> .dump albums
sqlite> .quit
#+end_src

The following picture shows the content of the ~albums.sql~ file.

[[file:figs/SQLite-dump-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-dump-example.png]]

**** Dump tables structure only using schema command
If you want to dump the structures of tables in a database, you use the
~.schema~ command.  The following commands set the output file to
=chinook_structure.sql= file and save the structures of tables into the
=chinook_structure.sql= file.

#+begin_src sh
sqlite> .output c:/sqlite/chinook_structure.sql
sqlite> .schema
sqlite> .quit
#+end_src

The following picture shows the content of the =chinook_structure.sql= file.

[[file:figs/SQLite-dump-structure.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-dump-structure.png]]

**** Dump data of one or more tables into a file
To dump the data of a table into a text file, you use these steps:

#+cindex:@command{.mode} command
#+cindex:mode
First, set the mode to =insert= using the ~.mode~ command as follows:

: sqlite> .mode insert

From now on, every =SELECT= statement will issue the result as the =INSERT=
statements instead of pure text data.

Second, set the output to a text file instead of the default standard output.
The following command sets the output file to the ~data.sql~ file.

: sqlite> .output data.sql

Third, issue the =SELECT= statements to query data from a table that you want
to dump.  The following command returns data from the =artists= table.

: sqlite> select * from artists;

Check the content of the ~data.sql~ file; if everything is fine, you will see
the following output:

[[file:figs/SQLite-dump-data-only.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-dump-data-only.png]]

To dump data from other tables, you need to issue the =SELECT= statements to
query data from those tables.

*** SQLite ~.import~ Command
- http://www.sqlitetutorial.net/sqlite-import-csv/

- SQLite Import CSV ::

     how to import CSV file into a table.


*Summary*: this tutorial shows you various ways to import CSV data into an
SQLite table using ~sqlite3~ and SQLite Studio tools.

**** Importing a CSV file into a table using ~sqlite3~ tool
In the first scenario, you want to import data from CSV file into a table that
does not exist in the SQLite database.

1. First, the ~sqlite3~ tool creates the table.  The ~sqlite3~ tool uses the
   first row of the CSV file as the names of the columns of the table.

2. Second, the ~sqlite3~ tool imports data from the second row of the CSV file
   into the table.


We will import a CSV file named ~city.csv~ with two columns: name and
population.  You can download it here for practicing.

[[http://www.sqlitetutorial.net/wp-content/uploads/2016/05/city.csv][Download the city.csv file]]

To import the ~c:\sqlite\city.csv~ file into the =cities= table:

#+cindex:CSV mode
#+cindex:mode, CSV
First, set the mode to =CSV= to instruct the command-line shell program to
interpret the input file as a CSV file.  To do this, you use the ~.mode~
command as follows:

: sqlite> .mode csv

#+cindex:@command{.import FILE TABLE} command
Second, use the ~.import FILE TABLE~ command to import the data from the
~city.csv~ file into the =cities= table.

: sqlite>.import c:/sqlite/city.csv cities

To verify the import, you use the ~.schema~ command to display the structure of
the =cities= table.

#+begin_src sh
sqlite> .schema cities
CREATE TABLE cities(
  "name" TEXT,
  "population" TEXT
);
#+end_src

To view the data of the cities table, you use the following =SELECT= statement.

#+begin_src sql
SELECT name, 
       population
FROM cities;
#+end_src

In the second scenario, the table is already available in the database and you
just need to import the data.

First, remove the =cities= table that you have created.

: DROP TABLE IF EXISTS cities;

Second, use the following =CREATE TABLE= statement to create the =cities=
table.

#+begin_src sql
CREATE TABLE cities(
  name TEXT NOT NULL,
  population INTEGER NOT NULL 
);
#+end_src

If the table already exists, the ~sqlite3~ tool uses all the rows, including
the first row, in the CSV file as the actual data to import.  Therefore, you
should delete the first row of the CSV file.

The following commands import the =city_without_header.csv= file into the
=cities= table.

#+begin_src sh
sqlite> .mode csv
sqlite> .import c:/sqlite/city_no_header.csv cities
#+end_src

*** SQLite ~.export~ Command
- http://www.sqlitetutorial.net//sqlite-tutorial/sqlite-export-csv/

- SQLite Export CSV ::

     how to export an SQLite database to CSV files.


*Summary*: in this tutorial, you will learn how to export SQLite database to a
CSV file.

**** Export SQLite Database to a CSV file using sqlite3 tool
SQLite project provides you with a command-line program called ~sqlite3~ or
sqlite3.exe on Windows.  By using the ~sqlite3~ tool, you can use the SQL
statements and dot-commands to interact with the SQLite database.

#+cindex:exort data to CSV
#+cindex:CSV mode, export
To export data from the SQLite database to a CSV file, you use these steps:

1. Turn on the header of the result set using the ~.header on~ command.

2. Set the output mode to =CSV= to instruct the ~sqlite3~ tool to issue the
   result in the =CSV= mode.

3. Send the output to a CSV file.

4. Issue the query to select data from the table to which you want to export.


The following commands select data from the customers table and export it to
the ~data.csv~ file.

#+begin_src sh
>sqlite3 c:/sqlite/chinook.db
sqlite> .headers on
sqlite> .mode csv
sqlite> .output data.csv
sqlite> SELECT customerid,
   ...>        firstname,
   ...>        lastname,
   ...>        company
   ...>   FROM customers;
sqlite> .quit
#+end_src

If you check the ~data.csv~ file, you will see the following output.

[[file:figs/SQLite-Export-CSV-example.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-Export-CSV-example.png]]

Besides using the dot-commands, you can use the options of the ~sqlite3~ tool
to export data from the SQLite database to a CSV file.

For example, the following command exports the data from the =tracks= table to
a CSV file named ~tracks.csv~.

: >sqlite3 -header -csv c:/sqlite/chinook.db "select * from tracks;" > tracks.csv

[[file:figs/SQLite-Export-CSV-one-liner-option.png][file:/usr/local/dev/programming/DB/SQLite/SQLiteTutorial/figs/SQLite-Export-CSV-one-liner-option.png]]

If you have a file named ~query.sql~ that contains the script to query data,
you can execute the statements in the file and export data to a CSV file.

: >sqlite3 -header -csv c:/sqlite/chinook.db < query.sql > data.csv

* SQLite Functions
** SQLite Aggregate Functions
- http://www.sqlitetutorial.net/sqlite-aggregate-functions/

This tutorial shows you how to use the SQLite aggregate functions to find the
maximum, minimum, average, sum, and count of a set of values.

*Summary*: in this tutorial, you will learn about the SQLite aggregate
functions to find the maximum, minimum, average, sum, and count of a set of
values.
*** Overview of SQLite aggregate functions
Aggregate functions operate on a set of rows and return a single result.
Aggregate functions are often used in conjunction with =GROUP BY= and =HAVING=
clauses in the =SELECT= statement.

SQLite provides the following aggregate functions:

- AVG() – returns the average value of a group.

- COUNT() – returns the number of rows that match a specified condition

- MAX() – returns the maximum value in a group.

- MIN() – returns the minimum value in a group

- SUM() – returns the sum of values

- =GROUP_CONCAT(expression, separator)= – returns a string that is the
  concatenation of all non-NULL values of the input expression separated by the
  separator.
*** SQLite aggregate function syntax
The following shows the syntax of calling an aggregate function except for the
=GROUP_CONCAT()= function:

: aggregate_function (DISTINCT | ALL expression)

In this syntax:

- First, specify the name of the aggregate function such as =AVG=, =SUM=, or
  =COUNT=

- Second, specify the expression to which the aggregate function applies.


=DISTINCT= instructs the aggregate function to consider only unique values in
the calculation while =ALL= allows the aggregate function to take all values
including duplicates in its calculation.

*** SQLite aggregate function examples

** SQLite Date Functions
- http://www.sqlitetutorial.net/sqlite-date-functions/

This section provides you with SQLite date and time functions that help you
manipulate datetime data effectively.

| Name      | Description                                                                                           |
|-----------+-------------------------------------------------------------------------------------------------------|
| DATE      | calculate a date value based on multiple date modifiers.                                              |
| TIME      | calculate a time value based on multiple date modifiers.                                              |
| DATETIME  | calculate a date & time value based on one or more date modifiers.                                    |
| JULIANDAY | returns the Julian day, which is the number of days since noon in Greenwich on November 24, 4714 B.C. |
| STRFTIME  | format a date value based on a specified format string.                                               |
|-----------+-------------------------------------------------------------------------------------------------------|

** SQLite String Functions
- http://www.sqlitetutorial.net/sqlite-string-functions/


This section shows the most commonly used SQLite string functions that help you
manipulate character string data effectively.

The following table shows the commonly used SQLite string functions that
perform an operation on an input string and return a new string or a numeric
value.

** SQLite Window Functions
- http://www.sqlitetutorial.net/sqlite-window-functions/


SQLite window functions perform a calculation on a set of rows that are related
to the current row. Unlike aggregate functions, window functions do not cause
rows to become grouped into a single result row.

* SQLite Programming Interfaces
** SQLite Java
This SQLite Java section teaches you step by step how to interact with SQLite
database using Java JDBC API.

** SQLite Python
This section guides you how to work with the SQLite database using Python
sqlite3 module.

** SQLite PHP
This section shows you how to use PHP PDO to interact with SQLite databases. We
will walk you through the steps of setting up PHP project structure, connecting
to the SQLite database, and performing the common database operations.

** SQLite Node.js
- http://www.sqlitetutorial.net/sqlite-nodejs/


This section shows you how to interact with SQLite databases from Node.js
applications using the node sqlite3 module.

In this section, you will learn how to interact with SQLite databases from a
Node.js application using the ~sqlite3~ module.  After the tutorial, you will
know how to open a database connection and perform common database operations
such as select, insert, update, and delete.  In addition, you will learn how to
execute SQL statements in serialized mode or in parallel mode.

The ~sqlite3~ module is actively maintained and provides a rich set of
features:

- Simple API for query execution
- Parameters binding support
- Control the query execution flow, supporting both serialized and parallel
  modes.
- Comprehensive debugging support
- Full caching / Blob support
- SQLite extension support
- Bundles SQLite as a fallback


To understand how the ~sqlite3~ module works, you can use the following
tutorials in sequence:

* SQLite Resources
- http://www.sqlitetutorial.net/sqlite-resources/

** SQLite useful links

** SQLite interfaces

** SQLite GUI tools

* Command Line Shell For SQLite
- https://www.sqlite.org/cli.html

* SQLite Advanced Tutorials

** SQLite Window Frame

** SQLite =CUME_DIST=

** SQLite =PERCENT_RANK=

** SQLite =DENSE_RANK=

** SQLite =NTILE=

** SQLite =NTH_VALUE=

** SQLite =LAST_VALUE=

** SQLite =FIRST_VALUE=

* List of Figures
:PROPERTIES:
:unnumbered: t
:END:

#+texinfo:@listoffloats Figure

* Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:
* Export Options                                                   :noexport:
** HTML Export Options
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t date:nil
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+subtitle:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.50 (<a href="https://orgmode.org">Org</a> mode 9.2.3)
#+latex_header:

** Texinfo Export Options
#+texinfo_filename:SQLiteTutorial.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subtitle:
#+subauthor:
#+texinfo_dir_category: Databases
#+texinfo_dir_title:SQLite Tutorial
#+texinfo_dir_desc: Everything you need to know to start using SQLite effectively.
#+texinfo_printed_title:SQLite Tutorial

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h2>@@ $1 @@html:</h2>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h3>@@ $1 @@html:</h3>@@

* Local Variables                                                  :noexport:
# Local variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %:H:%:M$"
# End:
